local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/xmaHeptc/Kavo-UI-Library/main/source.lua"))()

local Window = Library.CreateLib("SCREEPSTU - v0.0.1", "Serpent")

local Tab = Window:NewTab("Script/Game Hub")

local Section = Tab:NewSection("+10 Scripts! (more scripts soon!)")

Section:NewButton("Clown Killing Reborn", "Cheating time!", function()
    pcall(function()
        Rox_Hub = true
        loadstring(game:HttpGet("https://gist.githubusercontent.com/HaxxV1/d7cfdb5090e819a84a8db22fb113f39d/raw"))()
        end)
        
end)

Section:NewButton("Aimbot", "-", function()
    loadstring(game:HttpGet("https://pastebin.com/raw/ygp8Enye"))()
end)

Section:NewButton("Aimbot 3.0", "-", function()
                                                -- Issues:
                                            -- I'm still working on Tracers, I know they can cause huge frame rate drops. (I think I got it running as smooth as it's going to get.)
                                            -- Phantom Forces: Weird positioning bug with tracers? Tracer positions a bit behind localplayer. (Maybe make the update faster? > RenderPriority.First ?

                                            -- Settings can be found on line: 51
                                            -- Don't change anything if you don't understand.

                                            local Plrs = game:GetService("Players")
                                            local Run = game:GetService("RunService")
                                            local CoreGui = game:GetService("CoreGui")
                                            local StartGui = game:GetService("StarterGui")
                                            local Teams = game:GetService("Teams")
                                            local UserInput = game:GetService("UserInputService")
                                            local Light = game:GetService("Lighting")
                                            local HTTP = game:GetService("HttpService")
                                            local RepStor = game:GetService("ReplicatedStorage")

                                            function GetCamera() -- Just in case some game renames the player's camera.
                                                return workspace:FindFirstChildOfClass("Camera")
                                            end

                                            local ChamsFolder = Instance.new("Folder", CoreGui)
                                            ChamsFolder.Name = "Chams"
                                            local PlayerChams = Instance.new("Folder", ChamsFolder)
                                            PlayerChams.Name = "PlayerChams"
                                            local ItemChams = Instance.new("Folder", ChamsFolder)
                                            ItemChams.Name = "ItemChams"

                                            local ESPFolder = Instance.new("Folder", CoreGui)
                                            ESPFolder.Name = "ESP Stuff"
                                            local PlayerESP = Instance.new("Folder", ESPFolder)
                                            PlayerESP.Name = "PlayerESP"
                                            local ItemESP = Instance.new("Folder", ESPFolder)
                                            ItemESP.Name = "ItemESP"

                                            local MyPlr = Plrs.LocalPlayer
                                            local MyChar = MyPlr.Character
                                            local MyMouse = MyPlr:GetMouse()
                                            local MyCam = GetCamera()
                                            if MyCam == nil then
                                                error("WHAT KIND OF BLACK MAGIC IS THIS, CAMERA NOT FOUND.")
                                                return
                                            end

                                            local Tracers = Instance.new("Folder", MyCam)
                                            Tracers.Name = "Tracers"
                                            local TracerData = { }
                                            local TracerMT = setmetatable(TracerData, {
                                                __newindex = function(tab, index, val)
                                                    rawset(tab, index, val)
                                                end
                                            })

                                            function RemoveSpacesFromString(Str)
                                                local newstr = ""
                                                for i = 1, #Str do
                                                    if Str:sub(i, i) ~= " " then
                                                        newstr = newstr .. Str:sub(i, i)
                                                    end
                                                end

                                                return newstr
                                            end

                                            function CloneTable(T)
                                                local temp = { }
                                                for i,v in next, T do
                                                    if type(v) == "table" then
                                                        temp[i] = CloneTable(v)
                                                    else
                                                        temp[i] = v 
                                                    end
                                                end
                                                return temp
                                            end

                                            local Bullshit = {
                                                ESPEnabled = false, -- Self explanatory. LEAVE OFF BY DEFAULT.
                                                CHAMSEnabled = false, -- Self explanatory. LEAVE OFF BY DEFAULT.
                                                TracersEnabled = false, -- Self explanatory. LEAVE OFF BY DEFAULT.
                                                DebugInfo = false, -- Self explanatory. LEAVE OFF BY DEFAULT.
                                                OutlinesEnabled = false,
                                                FullbrightEnabled = false,
                                                CrosshairEnabled = false,
                                                AimbotEnabled = false,
                                                Aimbot = false,
                                                TracersLength = 500, -- MAX DISTANCE IS 2048 DO NOT GO ABOVE OR YOU'LL ENCOUNTER PROBLEMS.
                                                ESPLength = 10000,
                                                CHAMSLength = 500,
                                                PlaceTracersUnderCharacter = false, -- Change to true if you want tracers to be placed under your character instead of at the bottom of your camera.
                                                FreeForAll = false, -- use for games that don't have teams (Apocalypse Rising)
                                                AutoFire = false,
                                                MobChams = false,
                                                MobESP = false,
                                                AimbotKey = "Enum.UserInputType.MouseButton2", -- Doesn't do anything yet.
                                                Colors = {
                                                    Enemy = Color3.new(1, 0, 0),
                                                    Ally = Color3.new(0, 1, 0),
                                                    Friend = Color3.new(1, 1, 0),
                                                    Neutral = Color3.new(1, 1, 1),
                                                    Crosshair = Color3.new(1, 0, 0),
                                                    ColorOverride = nil, -- Every player will have the chosen color regardless of enemy or ally.
                                                },

                                                -- VVVV DON'T EDIT BELOW VVVV --
                                                ClosestEnemy = nil,
                                                CharAddedEvent = { },
                                                OutlinedParts = { },
                                                WorkspaceChildAddedEvent = nil,
                                                LightingEvent = nil,
                                                AmbientBackup = Light.Ambient,
                                                ColorShiftBotBackup = Light.ColorShift_Bottom,
                                                ColorShiftTopBackup = Light.ColorShift_Top,
                                                FPSAverage = { },
                                                Blacklist = { },
                                                FriendList = { },
                                                CameraModeBackup = MyPlr.CameraMode,
                                                GameSpecificCrap = { 
                                                },
                                                Mob_ESP_CHAMS_Ran_Once = false,
                                            }

                                            function SaveBullshitSettings()
                                                local temp = { }
                                                local succ, out = pcall(function()
                                                    temp.TracersLength = Bullshit.TracersLength
                                                    temp.ESPLength = Bullshit.ESPLength
                                                    temp.CHAMSLength = Bullshit.CHAMSLength
                                                    temp.PlaceTracersUnderCharacter = Bullshit.PlaceTracersUnderCharacter
                                                    temp.FreeForAll = Bullshit.FreeForAll
                                                    temp.AutoFire = Bullshit.AutoFire
                                                    temp.AimbotKey = tostring(Bullshit.AimbotKey)
                                                    temp.MobChams = Bullshit.MobChams
                                                    temp.MobESP = Bullshit.MobESP
                                                    temp.Colors = { }
                                                    for i, v in next, Bullshit.Colors do
                                                        temp.Colors[i] = tostring(v)
                                                    end
                                                    writefile("ProjectBullshit.txt", HTTP:JSONEncode(temp))
                                                end)
                                                if not succ then
                                                    error(out)
                                                end
                                            end

                                            fuck = pcall(function()
                                                local temp = HTTP:JSONDecode(readfile("ProjectBullshit.txt"))
                                                if temp.MobChams ~= nil and temp.MobESP ~= nil then
                                                    for i, v in next, temp do
                                                        if i ~= "Colors" then
                                                            Bullshit[i] = v
                                                        end
                                                    end
                                                    for i, v in next, temp.Colors do
                                                        local r, g, b = string.match(RemoveSpacesFromString(v), "(%d+),(%d+),(%d+)")
                                                        r = tonumber(r)
                                                        g = tonumber(g)
                                                        b = tonumber(b)

                                                        temp.Colors[i] = Color3.new(r, g, b)
                                                    end
                                                    Bullshit.Colors = temp.Colors
                                                else
                                                    spawn(function()
                                                        SaveBullshitSettings()
                                                        local hint = Instance.new("Hint", CoreGui)
                                                        hint.Text = "Major update requried your settings to be wiped! Sorry!"
                                                        wait(5)
                                                        hint:Destroy()
                                                    end)
                                                end

                                                Bullshit.AutoFire = false
                                            end)

                                            -- Load blacklist file if it exists
                                            fuck2 = pcall(function()
                                                Bullshit.Blacklist = HTTP:JSONDecode(readfile("Blacklist.txt"))
                                            end)

                                            fuck3 = pcall(function()
                                                Bullshit.FriendList = HTTP:JSONDecode(readfile("Whitelist.txt"))
                                            end)

                                            local DebugMenu = { }
                                            DebugMenu["SC"] = Instance.new("ScreenGui", CoreGui)
                                            DebugMenu["SC"].Name = "Debug"
                                            DebugMenu["Main"] = Instance.new("Frame", DebugMenu["SC"])
                                            DebugMenu["Main"].Name = "Debug Menu"
                                            DebugMenu["Main"].Position = UDim2.new(0, 20, 1, -220)
                                            DebugMenu["Main"].Size = UDim2.new(1, 0, 0, 200)
                                            DebugMenu["Main"].BackgroundTransparency = 1
                                            DebugMenu["Main"].Visible = false
                                            if game.PlaceId == 606849621 then
                                                DebugMenu["Main"].Position = UDim2.new(0, 230, 1, -220)
                                            end
                                            DebugMenu["Main"].Draggable = true
                                            DebugMenu["Main"].Active = true
                                            DebugMenu["Position"] = Instance.new("TextLabel", DebugMenu["Main"])
                                            DebugMenu["Position"].BackgroundTransparency = 1
                                            DebugMenu["Position"].Position = UDim2.new(0, 0, 0, 0)
                                            DebugMenu["Position"].Size = UDim2.new(1, 0, 0, 15)
                                            DebugMenu["Position"].Font = "Arcade"
                                            DebugMenu["Position"].Text = ""
                                            DebugMenu["Position"].TextColor3 = Color3.new(1, 1, 1)
                                            DebugMenu["Position"].TextSize = 15
                                            DebugMenu["Position"].TextStrokeColor3 = Color3.new(0, 0, 0)
                                            DebugMenu["Position"].TextStrokeTransparency = 0.3
                                            DebugMenu["Position"].TextXAlignment = "Left"
                                            DebugMenu["FPS"] = Instance.new("TextLabel", DebugMenu["Main"])
                                            DebugMenu["FPS"].BackgroundTransparency = 1
                                            DebugMenu["FPS"].Position = UDim2.new(0, 0, 0, 15)
                                            DebugMenu["FPS"].Size = UDim2.new(1, 0, 0, 15)
                                            DebugMenu["FPS"].Font = "Arcade"
                                            DebugMenu["FPS"].Text = ""
                                            DebugMenu["FPS"].TextColor3 = Color3.new(1, 1, 1)
                                            DebugMenu["FPS"].TextSize = 15
                                            DebugMenu["FPS"].TextStrokeColor3 = Color3.new(0, 0, 0)
                                            DebugMenu["FPS"].TextStrokeTransparency = 0.3
                                            DebugMenu["FPS"].TextXAlignment = "Left"
                                            DebugMenu["PlayerSelected"] = Instance.new("TextLabel", DebugMenu["Main"])
                                            DebugMenu["PlayerSelected"].BackgroundTransparency = 1
                                            DebugMenu["PlayerSelected"].Position = UDim2.new(0, 0, 0, 35)
                                            DebugMenu["PlayerSelected"].Size = UDim2.new(1, 0, 0, 15)
                                            DebugMenu["PlayerSelected"].Font = "Arcade"
                                            DebugMenu["PlayerSelected"].Text = ""
                                            DebugMenu["PlayerSelected"].TextColor3 = Color3.new(1, 1, 1)
                                            DebugMenu["PlayerSelected"].TextSize = 15
                                            DebugMenu["PlayerSelected"].TextStrokeColor3 = Color3.new(0, 0, 0)
                                            DebugMenu["PlayerSelected"].TextStrokeTransparency = 0.3
                                            DebugMenu["PlayerSelected"].TextXAlignment = "Left"
                                            DebugMenu["PlayerTeam"] = Instance.new("TextLabel", DebugMenu["Main"])
                                            DebugMenu["PlayerTeam"].BackgroundTransparency = 1
                                            DebugMenu["PlayerTeam"].Position = UDim2.new(0, 0, 0, 50)
                                            DebugMenu["PlayerTeam"].Size = UDim2.new(1, 0, 0, 15)
                                            DebugMenu["PlayerTeam"].Font = "Arcade"
                                            DebugMenu["PlayerTeam"].Text = ""
                                            DebugMenu["PlayerTeam"].TextColor3 = Color3.new(1, 1, 1)
                                            DebugMenu["PlayerTeam"].TextSize = 15
                                            DebugMenu["PlayerTeam"].TextStrokeColor3 = Color3.new(0, 0, 0)
                                            DebugMenu["PlayerTeam"].TextStrokeTransparency = 0.3
                                            DebugMenu["PlayerTeam"].TextXAlignment = "Left"
                                            DebugMenu["PlayerHealth"] = Instance.new("TextLabel", DebugMenu["Main"])
                                            DebugMenu["PlayerHealth"].BackgroundTransparency = 1
                                            DebugMenu["PlayerHealth"].Position = UDim2.new(0, 0, 0, 65)
                                            DebugMenu["PlayerHealth"].Size = UDim2.new(1, 0, 0, 15)
                                            DebugMenu["PlayerHealth"].Font = "Arcade"
                                            DebugMenu["PlayerHealth"].Text = ""
                                            DebugMenu["PlayerHealth"].TextColor3 = Color3.new(1, 1, 1)
                                            DebugMenu["PlayerHealth"].TextSize = 15
                                            DebugMenu["PlayerHealth"].TextStrokeColor3 = Color3.new(0, 0, 0)
                                            DebugMenu["PlayerHealth"].TextStrokeTransparency = 0.3
                                            DebugMenu["PlayerHealth"].TextXAlignment = "Left"
                                            DebugMenu["PlayerPosition"] = Instance.new("TextLabel", DebugMenu["Main"])
                                            DebugMenu["PlayerPosition"].BackgroundTransparency = 1
                                            DebugMenu["PlayerPosition"].Position = UDim2.new(0, 0, 0, 80)
                                            DebugMenu["PlayerPosition"].Size = UDim2.new(1, 0, 0, 15)
                                            DebugMenu["PlayerPosition"].Font = "Arcade"
                                            DebugMenu["PlayerPosition"].Text = ""
                                            DebugMenu["PlayerPosition"].TextColor3 = Color3.new(1, 1, 1)
                                            DebugMenu["PlayerPosition"].TextSize = 15
                                            DebugMenu["PlayerPosition"].TextStrokeColor3 = Color3.new(0, 0, 0)
                                            DebugMenu["PlayerPosition"].TextStrokeTransparency = 0.3
                                            DebugMenu["PlayerPosition"].TextXAlignment = "Left"
                                            DebugMenu["BehindWall"] = Instance.new("TextLabel", DebugMenu["Main"])
                                            DebugMenu["BehindWall"].BackgroundTransparency = 1
                                            DebugMenu["BehindWall"].Position = UDim2.new(0, 0, 0, 95)
                                            DebugMenu["BehindWall"].Size = UDim2.new(1, 0, 0, 15)
                                            DebugMenu["BehindWall"].Font = "Arcade"
                                            DebugMenu["BehindWall"].Text = ""
                                            DebugMenu["BehindWall"].TextColor3 = Color3.new(1, 1, 1)
                                            DebugMenu["BehindWall"].TextSize = 15
                                            DebugMenu["BehindWall"].TextStrokeColor3 = Color3.new(0, 0, 0)
                                            DebugMenu["BehindWall"].TextStrokeTransparency = 0.3
                                            DebugMenu["BehindWall"].TextXAlignment = "Left"

                                            local LastTick = tick()
                                            local FPSTick = tick()

                                            if #Teams:GetChildren() <= 0 then
                                                Bullshit.FreeForAll = true
                                            end

                                            if Bullshit.TracersLength > 2048 then
                                                Bullshit.TracersLength = 2048
                                            end

                                            if Bullshit.CHAMSLength > 2048 then
                                                Bullshit.CHAMSLength = 2048
                                            end

                                            local wildrevolvertick = tick()
                                            local wildrevolverteamdata = nil
                                            function GetTeamColor(Plr)
                                                if Plr == nil then return nil end
                                                if not Plr:IsA("Player") then
                                                    return nil
                                                end
                                                local PickedColor = Bullshit.Colors.Enemy
                                                
                                                if Plr ~= nil then
                                                    if game.PlaceId == 606849621 then
                                                        if Bullshit.Colors.ColorOverride == nil then
                                                            if not Bullshit.FreeForAll then
                                                                if MyPlr.Team ~= nil and Plr.Team ~= nil then
                                                                    if Bullshit.FriendList[Plr.Name] == nil then
                                                                        if MyPlr.Team.Name == "Prisoner" then
                                                                            if Plr.Team == MyPlr.Team or Plr.Team.Name == "Criminal" then
                                                                                PickedColor = Bullshit.Colors.Ally
                                                                            else
                                                                                PickedColor = Bullshit.Colors.Enemy
                                                                            end
                                                                        elseif MyPlr.Team.Name == "Criminal" then
                                                                            if Plr.Team == MyPlr.Team or Plr.Team.Name == "Prisoner" then
                                                                                PickedColor = Bullshit.Colors.Ally
                                                                            else
                                                                                PickedColor = Bullshit.Colors.Enemy
                                                                            end
                                                                        elseif MyPlr.Team.Name == "Police" then
                                                                            if Plr.Team == MyPlr.Team then
                                                                                PickedColor = Bullshit.Colors.Ally
                                                                            else
                                                                                if Plr.Team.Name == "Criminal" then
                                                                                    PickedColor = Bullshit.Colors.Enemy
                                                                                elseif Plr.Team.Name == "Prisoner" then
                                                                                    PickedColor = Bullshit.Colors.Neutral
                                                                                end
                                                                            end
                                                                        end
                                                                    else
                                                                        PickedColor = Bullshit.Colors.Friend
                                                                    end
                                                                end
                                                            else
                                                                if Bullshit.FriendList[Plr.Name] ~= nil then
                                                                    PickedColor = Bullshit.Colors.Friend
                                                                else
                                                                    PickedColor = Bullshit.Colors.Enemy
                                                                end
                                                            end
                                                        else
                                                            PickedColor = Bullshit.Colors.ColorOverride
                                                        end
                                                    elseif game.PlaceId == 155615604 then
                                                        if Bullshit.Colors.ColorOverride == nil then
                                                            if MyPlr.Team ~= nil and Plr.Team ~= nil then
                                                                if Bullshit.FriendList[Plr.Name] == nil then
                                                                    if MyPlr.Team.Name == "Inmates" then
                                                                        if Plr.Team.Name == "Inmates" then
                                                                            PickedColor = Bullshit.Colors.Ally
                                                                        elseif Plr.Team.Name == "Guards" or Plr.Team.Name == "Criminals" then
                                                                            PickedColor = Bullshit.Colors.Enemy
                                                                        else
                                                                            PickedColor = Bullshit.Colors.Neutral
                                                                        end
                                                                    elseif MyPlr.Team.Name == "Guards" then
                                                                        if Plr.Team.Name == "Inmates" then
                                                                            PickedColor = Bullshit.Colors.Neutral
                                                                        elseif Plr.Team.Name == "Criminals" then
                                                                            PickedColor = Bullshit.Colors.Enemy
                                                                        elseif Plr.Team.Name == "Guards" then
                                                                            PickColor = Bullshit.Colors.Ally
                                                                        end
                                                                    elseif MyPlr.Team.Name == "Criminals" then
                                                                        if Plr.Team.Name == "Inmates" then
                                                                            PickedColor = Bullshit.Colors.Ally
                                                                        elseif Plr.Team.Name == "Guards" then
                                                                            PickedColor = Bullshit.Colors.Enemy
                                                                        else
                                                                            PickedColor = Bullshit.Colors.Neutral
                                                                        end
                                                                    end
                                                                else
                                                                    PickedColor = Bullshit.Colors.Friend
                                                                end
                                                            end
                                                        else
                                                            PickedColor = Bullshit.Colors.ColorOverride
                                                        end
                                                    elseif game.PlaceId == 746820961 then
                                                        if Bullshit.Colors.ColorOverride == nil then
                                                            if MyPlr:FindFirstChild("TeamC") and Plr:FindFirstChild("TeamC") then
                                                                if Plr.TeamC.Value == MyPlr.TeamC.Value then
                                                                    PickedColor = Bullshit.Colors.Ally
                                                                else
                                                                    PickedColor = Bullshit.Colors.Enemy
                                                                end
                                                            end
                                                        else
                                                            PickedColor = Bullshit.Colors.ColorOverride
                                                        end
                                                    elseif game.PlaceId == 1382113806 then
                                                        if Bullshit.Colors.ColorOverride == nil then
                                                            if MyPlr:FindFirstChild("role") and Plr:FindFirstChild("role") then
                                                                if MyPlr.role.Value == "assassin" then
                                                                    if Plr.role.Value == "target" then
                                                                        PickedColor = Bullshit.Colors.Enemy
                                                                    elseif Plr.role.Value == "guard" then
                                                                        PickedColor = Color3.new(1, 135 / 255, 0)
                                                                    else
                                                                        PickedColor = Bullshit.Colors.Neutral
                                                                    end
                                                                elseif MyPlr.role.Value == "target" then
                                                                    if Plr.role.Value == "guard" then
                                                                        PickedColor = Bullshit.Colors.Ally
                                                                    elseif Plr.role.Value == "assassin" then
                                                                        PickedColor = Bullshit.Colors.Enemy
                                                                    else
                                                                        PickedColor = Bullshit.Colors.Neutral
                                                                    end
                                                                elseif MyPlr.role.Value == "guard" then
                                                                    if Plr.role.Value == "target" then
                                                                        PickedColor = Bullshit.Colors.Friend
                                                                    elseif Plr.role.Value == "guard" then
                                                                        PickedColor = Bullshit.Colors.Ally
                                                                    elseif Plr.role.Value == "assassin" then
                                                                        PickedColor = Bullshit.Colors.Enemy
                                                                    else
                                                                        PickedColor = Bullshit.Colors.Neutral
                                                                    end
                                                                else
                                                                    if MyPlr.role.Value == "none" then
                                                                        PickedColor = Bullshit.Colors.Neutral
                                                                    end
                                                                end
                                                            end
                                                        else
                                                            PickedColor = Bullshit.Colors.ColorOverride
                                                        end
                                                    elseif game.PlaceId == 1072809192 then
                                                        if MyPlr:FindFirstChild("Backpack") and Plr:FindFirstChild("Backpack") then
                                                            if MyPlr.Backpack:FindFirstChild("Knife") or MyChar:FindFirstChild("Knife") then
                                                                if Plr.Backpack:FindFirstChild("Revolver") or Plr.Character:FindFirstChild("Revolver") then
                                                                    PickedColor = Bullshit.Colors.Enemy
                                                                else
                                                                    PickedColor = Color3.new(1, 135 / 255, 0)
                                                                end
                                                            elseif MyPlr.Backpack:FindFirstChild("Revolver") or MyChar:FindFirstChild("Revolver") then
                                                                if Plr.Backpack:FindFirstChild("Knife") or Plr.Character:FindFirstChild("Knife") then
                                                                    PickedColor = Bullshit.Colors.Enemy
                                                                elseif Plr.Backpack:FindFirstChild("Revolver") or Plr.Character:FindFirstChild("Revolver") then
                                                                    PickedColor = Bullshit.Colors.Enemy
                                                                else
                                                                    PickedColor = Bullshit.Colors.Ally
                                                                end
                                                            else
                                                                if Plr.Backpack:FindFirstChild("Knife") or Plr.Character:FindFirstChild("Knife") then
                                                                    PickedColor = Bullshit.Colors.Enemy
                                                                elseif Plr.Backpack:FindFirstChild("Revolver") or Plr.Character:FindFirstChild("Revolver") then
                                                                    PickedColor = Bullshit.Colors.Ally
                                                                else
                                                                    PickedColor = Bullshit.Colors.Neutral
                                                                end
                                                            end
                                                        end
                                                    elseif game.PlaceId == 142823291 or game.PlaceId == 1122507250 then
                                                        if MyPlr:FindFirstChild("Backpack") and Plr:FindFirstChild("Backpack") then
                                                            if MyPlr.Backpack:FindFirstChild("Knife") or MyChar:FindFirstChild("Knife") then
                                                                if (Plr.Backpack:FindFirstChild("Gun") or Plr.Backpack:FindFirstChild("Revolver")) or (Plr.Character:FindFirstChild("Gun") or Plr.Character:FindFirstChild("Revolver")) then
                                                                    PickedColor = Bullshit.Colors.Enemy
                                                                else
                                                                    PickedColor = Color3.new(1, 135 / 255, 0)
                                                                end
                                                            elseif (MyPlr.Backpack:FindFirstChild("Gun") or MyPlr.Backpack:FindFirstChild("Revolver")) or (MyChar:FindFirstChild("Gun") or MyChar:FindFirstChild("Revolver")) then
                                                                if Plr.Backpack:FindFirstChild("Knife") or Plr.Character:FindFirstChild("Knife") then
                                                                    PickedColor = Bullshit.Colors.Enemy
                                                                else
                                                                    PickedColor = Bullshit.Colors.Ally
                                                                end
                                                            else
                                                                if Plr.Backpack:FindFirstChild("Knife") or Plr.Character:FindFirstChild("Knife") then
                                                                    PickedColor = Bullshit.Colors.Enemy
                                                                elseif (Plr.Backpack:FindFirstChild("Gun") or Plr.Backpack:FindFirstChild("Revolver")) or (Plr.Character:FindFirstChild("Gun") or Plr.Character:FindFirstChild("Revolver")) then
                                                                    PickedColor = Bullshit.Colors.Ally
                                                                else
                                                                    PickedColor = Bullshit.Colors.Neutral
                                                                end
                                                            end
                                                        end
                                                    elseif game.PlaceId == 379614936 then
                                                        if Bullshit.Colors.ColorOverride == nil then
                                                            if not Bullshit.FriendList[Plr.Name] then
                                                                local targ = MyPlr:FindFirstChild("PlayerGui"):FindFirstChild("ScreenGui"):FindFirstChild("UI"):FindFirstChild("Target"):FindFirstChild("Img"):FindFirstChild("PlayerText")
                                                                if targ then
                                                                    if Plr.Name:lower() == targ.Text:lower() then
                                                                        PickedColor = Bullshit.Colors.Enemy
                                                                    else
                                                                        PickedColor = Bullshit.Colors.Neutral
                                                                    end
                                                                else
                                                                    PickedColor = Bullshit.Colors.Neutral
                                                                end
                                                            else
                                                                PickedColor = Bullshit.Colors.Friend
                                                            end
                                                        else
                                                            PickedColor = Bullshit.Colors.ColorOverride
                                                        end
                                                    elseif game.PlaceId == 983224898 then
                                                        if (tick() - wildrevolvertick) > 10 or wildrevolverteamdata == nil then
                                                            wildrevolverteamdata = RepStor.Functions.RequestGameData:InvokeServer()
                                                            wildrevolvertick = tick()
                                                            return Bullshit.Colors.Neutral
                                                        end
                                                        local succ = pcall(function()
                                                            if wildrevolverteamdata[Plr.Name] ~= nil then
                                                                if Bullshit.Colors.ColorOverride == nil then
                                                                    if not Bullshit.FriendList[Plr.Name] then
                                                                        if wildrevolverteamdata[Plr.Name]["TeamName"] == wildrevolverteamdata[MyPlr.Name]["TeamName"] then
                                                                            PickedColor = Bullshit.Colors.Ally
                                                                        else
                                                                            PickedColor = Bullshit.Colors.Enemy
                                                                        end
                                                                    else
                                                                        PickedColor = Bullshit.Colors.Friend
                                                                    end
                                                                else
                                                                    PickedColor = Bullshit.Colors.ColorOverride
                                                                end
                                                            else
                                                                PickedColor = Bullshit.Colors.Neutral
                                                            end
                                                        end)
                                                        if not succ then
                                                            wildrevolverteamdata = RepStor.Functions.RequestGameData:InvokeServer()
                                                            wildrevolvertick = tick()
                                                            return Bullshit.Colors.Neutral
                                                        end
                                                    else
                                                        if Bullshit.Colors.ColorOverride == nil then
                                                            if not Bullshit.FreeForAll then
                                                                if MyPlr.Team ~= Plr.Team and not Bullshit.FriendList[Plr.Name] then
                                                                    PickedColor = Bullshit.Colors.Enemy
                                                                elseif MyPlr.Team == Plr.Team and not Bullshit.FriendList[Plr.Name] then
                                                                    PickedColor = Bullshit.Colors.Ally
                                                                else
                                                                    PickedColor = Bullshit.Colors.Friend
                                                                end
                                                            else
                                                                if Bullshit.FriendList[Plr.Name] ~= nil then
                                                                    PickedColor = Bullshit.Colors.Friend
                                                                else
                                                                    PickedColor = Bullshit.Colors.Enemy
                                                                end
                                                            end
                                                        else
                                                            PickedColor = Bullshit.Colors.ColorOverride
                                                        end
                                                    end
                                                end
                                                
                                                return PickedColor
                                            end

                                            function FindCham(Obj)
                                                for i, v in next, ItemChams:GetChildren() do
                                                    if v.className == "ObjectValue" then
                                                        if v.Value == Obj then
                                                            return v.Parent
                                                        end
                                                    end
                                                end

                                                return nil
                                            end

                                            function FindESP(Obj)
                                                for i, v in next, ItemESP:GetChildren() do
                                                    if v.className == "ObjectValue" then
                                                        if v.Value == Obj then
                                                            return v.Parent
                                                        end
                                                    end
                                                end

                                                return nil
                                            end

                                            function GetFirstPart(Obj)
                                                for i, v in next, Obj:GetDescendants() do
                                                    if v:IsA("BasePart") then
                                                        return v
                                                    end
                                                end

                                                return nil
                                            end

                                            function GetSizeOfObject(Obj)
                                                if Obj:IsA("BasePart") then
                                                    return Obj.Size
                                                elseif Obj:IsA("Model") then
                                                    return Obj:GetExtentsSize()
                                                end
                                            end

                                            function GetClosestPlayerNotBehindWall()
                                                local Players = { }
                                                local CurrentClosePlayer = nil
                                                local SelectedPlr = nil

                                                for _, v in next, Plrs:GetPlayers() do
                                                    if v ~= MyPlr and not Bullshit.Blacklist[v.Name] then
                                                        local IsAlly = GetTeamColor(v)
                                                        if IsAlly ~= Bullshit.Colors.Ally and IsAlly ~= Bullshit.Colors.Friend and IsAlly ~= Bullshit.Colors.Neutral then
                                                            local GetChar = v.Character
                                                            if MyChar and GetChar then
                                                                local MyHead, MyTor = MyChar:FindFirstChild("Head"), MyChar:FindFirstChild("HumanoidRootPart")
                                                                local GetHead, GetTor, GetHum = GetChar:FindFirstChild("Head"), GetChar:FindFirstChild("HumanoidRootPart"), GetChar:FindFirstChild("Humanoid")

                                                                if MyHead and MyTor and GetHead and GetTor and GetHum then
                                                                    if game.PlaceId == 455366377 then
                                                                        if not GetChar:FindFirstChild("KO") and GetHum.Health > 1 then
                                                                            local Ray = Ray.new(MyCam.CFrame.p, (GetHead.Position - MyCam.CFrame.p).unit * 2048)
                                                                            local part = workspace:FindPartOnRayWithIgnoreList(Ray, {MyChar})
                                                                            if part ~= nil then
                                                                                if part:IsDescendantOf(GetChar) then
                                                                                    local Dist = (MyTor.Position - GetTor.Position).magnitude
                                                                                    Players[v] = Dist
                                                                                end
                                                                            end
                                                                        end
                                                                    elseif game.PlaceId == 746820961 then
                                                                        if GetHum.Health > 1 then
                                                                            local Ray = Ray.new(MyCam.CFrame.p, (GetHead.Position - MyCam.CFrame.p).unit * 2048)
                                                                            local part = workspace:FindPartOnRayWithIgnoreList(Ray, {MyChar, MyCam})
                                                                            if part ~= nil then
                                                                                if part:IsDescendantOf(GetChar) then
                                                                                    local Dist = (MyTor.Position - GetTor.Position).magnitude
                                                                                    Players[v] = Dist
                                                                                end
                                                                            end
                                                                        end
                                                                    else
                                                                        if GetHum.Health > 1 then
                                                                            local Ray = Ray.new(MyCam.CFrame.p, (GetHead.Position - MyCam.CFrame.p).unit * 2048)
                                                                            local part = workspace:FindPartOnRayWithIgnoreList(Ray, {MyChar})
                                                                            if part ~= nil then
                                                                                if part:IsDescendantOf(GetChar) then
                                                                                    local Dist = (MyTor.Position - GetTor.Position).magnitude
                                                                                    Players[v] = Dist
                                                                                end
                                                                            end
                                                                        end
                                                                    end
                                                                end
                                                            end
                                                        end
                                                    end
                                                end

                                                for i, v in next, Players do
                                                    if CurrentClosePlayer ~= nil then
                                                        if v <= CurrentClosePlayer then
                                                            CurrentClosePlayer = v
                                                            SelectedPlr = i
                                                        end
                                                    else
                                                        CurrentClosePlayer = v
                                                        SelectedPlr = i
                                                    end
                                                end
                                                
                                                return SelectedPlr
                                            end

                                            function GetClosestPlayer()
                                                local Players = { }
                                                local CurrentClosePlayer = nil
                                                local SelectedPlr = nil
                                                
                                                for _, v in next, Plrs:GetPlayers() do
                                                    if v ~= MyPlr then
                                                        local IsAlly = GetTeamColor(v)
                                                        if IsAlly ~= Bullshit.Colors.Ally and IsAlly ~= Bullshit.Colors.Friend and IsAlly ~= Bullshit.Colors.Neutral then
                                                            local GetChar = v.Character
                                                            if MyChar and GetChar then
                                                                local MyTor = MyChar:FindFirstChild("HumanoidRootPart")
                                                                local GetTor = GetChar:FindFirstChild("HumanoidRootPart")
                                                                local GetHum = GetChar:FindFirstChild("Humanoid")
                                                                if MyTor and GetTor and GetHum then
                                                                    if game.PlaceId == 455366377 then
                                                                        if not GetChar:FindFirstChild("KO") and GetHum.Health > 1 then
                                                                            local Dist = (MyTor.Position - GetTor.Position).magnitude
                                                                            Players[v] = Dist
                                                                        end
                                                                    else
                                                                        if GetHum.Health > 1 then
                                                                            local Dist = (MyTor.Position - GetTor.Position).magnitude
                                                                            Players[v] = Dist
                                                                        end
                                                                    end
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                                
                                                for i, v in next, Players do
                                                    if CurrentClosePlayer ~= nil then
                                                        if v <= CurrentClosePlayer then
                                                            CurrentClosePlayer = v
                                                            SelectedPlr = i
                                                        end
                                                    else
                                                        CurrentClosePlayer = v
                                                        SelectedPlr = i
                                                    end
                                                end
                                                
                                                return SelectedPlr
                                            end

                                            function FindPlayer(Txt)
                                                local ps = { }
                                                for _, v in next, Plrs:GetPlayers() do
                                                    if string.lower(string.sub(v.Name, 1, string.len(Txt))) == string.lower(Txt) then
                                                        table.insert(ps, v)
                                                    end
                                                end

                                                if #ps == 1 then
                                                    if ps[1] ~= MyPlr then
                                                        return ps[1]
                                                    else
                                                        return nil
                                                    end
                                                else
                                                    return nil
                                                end
                                            end

                                            function UpdateESP(Plr)
                                                if Plr ~= nil then
                                                    local Find = PlayerESP:FindFirstChild("ESP Crap_" .. Plr.Name)
                                                    if Find then
                                                        local PickColor = GetTeamColor(Plr)
                                                        Find.Frame.Names.TextColor3 = PickColor
                                                        Find.Frame.Dist.TextColor3 = PickColor
                                                        Find.Frame.Health.TextColor3 = PickColor
                                                        --Find.Frame.Pos.TextColor3 = PickColor
                                                        local GetChar = Plr.Character
                                                        if MyChar and GetChar then
                                                            local Find2 = MyChar:FindFirstChild("HumanoidRootPart")
                                                            local Find3 = GetChar:FindFirstChild("HumanoidRootPart")
                                                            local Find4 = GetChar:FindFirstChildOfClass("Humanoid")
                                                            if Find2 and Find3 then
                                                                local pos = Find3.Position
                                                                local Dist = (Find2.Position - pos).magnitude
                                                                if Dist > Bullshit.ESPLength or Bullshit.Blacklist[Plr.Name] then
                                                                    Find.Frame.Names.Visible = false
                                                                    Find.Frame.Dist.Visible = false
                                                                    Find.Frame.Health.Visible = false
                                                                    return
                                                                else
                                                                    Find.Frame.Names.Visible = true
                                                                    Find.Frame.Dist.Visible = true
                                                                    Find.Frame.Health.Visible = true
                                                                end
                                                                Find.Frame.Dist.Text = "Distance: " .. string.format("%.0f", Dist)
                                                                --Find.Frame.Pos.Text = "(X: " .. string.format("%.0f", pos.X) .. ", Y: " .. string.format("%.0f", pos.Y) .. ", Z: " .. string.format("%.0f", pos.Z) .. ")"
                                                                if Find4 then
                                                                    Find.Frame.Health.Text = "Health: " .. string.format("%.0f", Find4.Health)
                                                                else
                                                                    Find.Frame.Health.Text = ""
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end

                                            function RemoveESP(Obj)
                                                if Obj ~= nil then
                                                    local IsPlr = Obj:IsA("Player")
                                                    local UseFolder = ItemESP
                                                    if IsPlr then UseFolder = PlayerESP end

                                                    local FindESP = ((IsPlr) and UseFolder:FindFirstChild("ESP Crap_" .. Obj.Name)) or FindESP(Obj)
                                                    if FindESP then
                                                        FindESP:Destroy()
                                                    end
                                                end
                                            end

                                            function CreateESP(Obj)
                                                if Obj ~= nil then
                                                    local IsPlr = Obj:IsA("Player")
                                                    local UseFolder = ItemESP
                                                    local GetChar = ((IsPlr) and Obj.Character) or Obj
                                                    local Head = GetChar:FindFirstChild("Head")
                                                    local t = tick()
                                                    if IsPlr then UseFolder = PlayerESP end
                                                    if Head == nil then
                                                        repeat
                                                            Head = GetChar:FindFirstChild("Head")
                                                            wait()
                                                        until Head ~= nil or (tick() - t) >= 10
                                                    end
                                                    if Head == nil then return end
                                                    
                                                    local bb = Instance.new("BillboardGui")
                                                    bb.Adornee = Head
                                                    bb.ExtentsOffset = Vector3.new(0, 1, 0)
                                                    bb.AlwaysOnTop = true
                                                    bb.Size = UDim2.new(0, 5, 0, 5)
                                                    bb.StudsOffset = Vector3.new(0, 3, 0)
                                                    bb.Name = "ESP Crap_" .. Obj.Name
                                                    bb.Parent = UseFolder
                                                    
                                                    local frame = Instance.new("Frame", bb)
                                                    frame.ZIndex = 10
                                                    frame.BackgroundTransparency = 1
                                                    frame.Size = UDim2.new(1, 0, 1, 0)
                                                    
                                                    local TxtName = Instance.new("TextLabel", frame)
                                                    TxtName.Name = "Names"
                                                    TxtName.ZIndex = 10
                                                    TxtName.Text = Obj.Name
                                                    TxtName.BackgroundTransparency = 1
                                                    TxtName.Position = UDim2.new(0, 0, 0, -45)
                                                    TxtName.Size = UDim2.new(1, 0, 10, 0)
                                                    TxtName.Font = "SourceSansBold"
                                                    TxtName.TextSize = 13
                                                    TxtName.TextStrokeTransparency = 0.5

                                                    local TxtDist = nil
                                                    local TxtHealth = nil
                                                    if IsPlr then
                                                        TxtDist = Instance.new("TextLabel", frame)
                                                        TxtDist.Name = "Dist"
                                                        TxtDist.ZIndex = 10
                                                        TxtDist.Text = ""
                                                        TxtDist.BackgroundTransparency = 1
                                                        TxtDist.Position = UDim2.new(0, 0, 0, -35)
                                                        TxtDist.Size = UDim2.new(1, 0, 10, 0)
                                                        TxtDist.Font = "SourceSansBold"
                                                        TxtDist.TextSize = 13
                                                        TxtDist.TextStrokeTransparency = 0.5

                                                        TxtHealth = Instance.new("TextLabel", frame)
                                                        TxtHealth.Name = "Health"
                                                        TxtHealth.ZIndex = 10
                                                        TxtHealth.Text = ""
                                                        TxtHealth.BackgroundTransparency = 1
                                                        TxtHealth.Position = UDim2.new(0, 0, 0, -25)
                                                        TxtHealth.Size = UDim2.new(1, 0, 10, 0)
                                                        TxtHealth.Font = "SourceSansBold"
                                                        TxtHealth.TextSize = 13
                                                        TxtHealth.TextStrokeTransparency = 0.5
                                                    else
                                                        local ObjVal = Instance.new("ObjectValue", bb)
                                                        ObjVal.Value = Obj
                                                    end
                                                    
                                                    local PickColor = GetTeamColor(Obj) or Bullshit.Colors.Neutral
                                                    TxtName.TextColor3 = PickColor

                                                    if IsPlr then
                                                        TxtDist.TextColor3 = PickColor
                                                        TxtHealth.TextColor3 = PickColor
                                                    end
                                                end
                                            end

                                            function UpdateTracer(Plr)
                                                if Bullshit.TracersEnabled then
                                                    if MyChar then
                                                        local MyTor = MyChar:FindFirstChild("HumanoidRootPart")
                                                        local GetTor = TracerData[Plr.Name]
                                                        if MyTor and GetTor ~= nil and GetTor.Parent ~= nil then
                                                            local Dist = (MyTor.Position - GetTor.Position).magnitude
                                                            if (Dist < Bullshit.TracersLength and not Bullshit.Blacklist[Plr.Name]) and not (MyChar:FindFirstChild("InVehicle") or GetTor.Parent:FindFirstChild("InVehicle")) then
                                                                if not Bullshit.PlaceTracersUnderCharacter then
                                                                    local R = MyCam:ScreenPointToRay(MyCam.ViewportSize.X / 2, MyCam.ViewportSize.Y, 0)
                                                                    Dist = (R.Origin - (GetTor.Position - Vector3.new(0, 3, 0))).magnitude
                                                                    Tracers[Plr.Name].Transparency = 1
                                                                    Tracers[Plr.Name].Size = Vector3.new(0.05, 0.05, Dist)
                                                                    Tracers[Plr.Name].CFrame = CFrame.new(R.Origin, (GetTor.Position - Vector3.new(0, 4.5, 0))) * CFrame.new(0, 0, -Dist / 2)
                                                                    Tracers[Plr.Name].BrickColor = BrickColor.new(GetTeamColor(Plr))
                                                                    Tracers[Plr.Name].BoxHandleAdornment.Transparency = 0
                                                                    Tracers[Plr.Name].BoxHandleAdornment.Size = Vector3.new(0.001, 0.001, Dist)
                                                                    Tracers[Plr.Name].BoxHandleAdornment.Color3 = GetTeamColor(Plr)
                                                                else
                                                                    Dist = (MyTor.Position - (GetTor.Position - Vector3.new(0, 3, 0))).magnitude
                                                                    Tracers[Plr.Name].Transparency = 1
                                                                    Tracers[Plr.Name].Size = Vector3.new(0.3, 0.3, Dist)
                                                                    Tracers[Plr.Name].CFrame = CFrame.new(MyTor.Position - Vector3.new(0, 3, 0), (GetTor.Position - Vector3.new(0, 4.5, 0))) * CFrame.new(0, 0, -Dist / 2)
                                                                    Tracers[Plr.Name].BrickColor = BrickColor.new(GetTeamColor(Plr))
                                                                    Tracers[Plr.Name].BoxHandleAdornment.Transparency = 0
                                                                    Tracers[Plr.Name].BoxHandleAdornment.Size = Vector3.new(0.05, 0.05, Dist)
                                                                    Tracers[Plr.Name].BoxHandleAdornment.Color3 = GetTeamColor(Plr)
                                                                end
                                                            else
                                                                Tracers[Plr.Name].Transparency = 1
                                                                Tracers[Plr.Name].BoxHandleAdornment.Transparency = 1
                                                            end
                                                        end
                                                    end
                                                end
                                            end

                                            function RemoveTracers(Plr)
                                                local Find = Tracers:FindFirstChild(Plr.Name)
                                                if Find then
                                                    Find:Destroy()
                                                end
                                            end

                                            function CreateTracers(Plr)
                                                local Find = Tracers:FindFirstChild(Plr.Name)
                                                if not Find then
                                                    local P = Instance.new("Part")
                                                    P.Name = Plr.Name
                                                    P.Material = "Neon"
                                                    P.Transparency = 1
                                                    P.Anchored = true
                                                    P.Locked = true
                                                    P.CanCollide = false
                                                    local B = Instance.new("BoxHandleAdornment", P)
                                                    B.Adornee = P
                                                    B.Size = GetSizeOfObject(P)
                                                    B.AlwaysOnTop = true
                                                    B.ZIndex = 5
                                                    B.Transparency = 0
                                                    B.Color3 = GetTeamColor(Plr) or Bullshit.Colors.Neutral
                                                    P.Parent = Tracers

                                                    coroutine.resume(coroutine.create(function()
                                                        while Tracers:FindFirstChild(Plr.Name) do
                                                            UpdateTracer(Plr)
                                                            Run.RenderStepped:wait()
                                                        end
                                                    end))
                                                end
                                            end

                                            function UpdateChams(Obj)
                                                if Obj == nil then return end

                                                if Obj:IsA("Player") then
                                                    local Find = PlayerChams:FindFirstChild(Obj.Name)
                                                    local GetChar = Obj.Character

                                                    local Trans = 0
                                                    if GetChar and MyChar then
                                                        local GetHead = GetChar:FindFirstChild("Head")
                                                        local GetTor = GetChar:FindFirstChild("HumanoidRootPart")
                                                        local MyHead = MyChar:FindFirstChild("Head")
                                                        local MyTor = MyChar:FindFirstChild("HumanoidRootPart")
                                                        if GetHead and GetTor and MyHead and MyTor then
                                                            if (MyTor.Position - GetTor.Position).magnitude > Bullshit.CHAMSLength or Bullshit.Blacklist[Obj.Name] then
                                                                Trans = 1
                                                            else
                                                                --local MyCharStuff = MyChar:GetDescendants()
                                                                local Ray = Ray.new(MyCam.CFrame.p, (GetTor.Position - MyCam.CFrame.p).unit * 2048)
                                                                local part = workspace:FindPartOnRayWithIgnoreList(Ray, {MyChar})
                                                                if part ~= nil then
                                                                    if part:IsDescendantOf(GetChar) then
                                                                        Trans = 0.9
                                                                    else
                                                                        Trans = 0
                                                                    end
                                                                end
                                                            end
                                                        end
                                                    end

                                                    if Find then
                                                        for i, v in next, Find:GetChildren() do
                                                            if v.className ~= "ObjectValue" then
                                                                v.Color3 = GetTeamColor(Obj) or Bullshit.Colors.Neutral
                                                                v.Transparency = Trans
                                                            end
                                                        end
                                                    end
                                                end
                                            end

                                            function RemoveChams(Obj)
                                                if Obj ~= nil then
                                                    local IsPlr = Obj:IsA("Player")
                                                    local UseFolder = ItemChams
                                                    if IsPlr then UseFolder = PlayerChams end

                                                    local FindC = UseFolder:FindFirstChild(tostring(Obj)) or FindCham(Obj)
                                                    if FindC then
                                                        FindC:Destroy()
                                                    end
                                                end
                                            end

                                            function CreateChams(Obj)
                                                if Obj ~= nil then
                                                    local IsPlr = Obj:IsA("Player")
                                                    local UseFolder = ItemChams
                                                    local Crap = nil
                                                    local GetTor = nil
                                                    local t = tick()
                                                    if IsPlr then
                                                        Obj = Obj.Character
                                                        UseFolder = PlayerChams
                                                    end
                                                    if Obj == nil then return end
                                                    GetTor = Obj:FindFirstChild("HumanoidRootPart") or Obj:WaitForChild("HumanoidRootPart")
                                                    if IsPlr then Crap = Obj:GetChildren() else Crap = Obj:GetDescendants() end

                                                    local FindC = ((IsPlr) and UseFolder:FindFirstChild(Obj.Name)) or FindCham(Obj)
                                                    if not FindC then
                                                        FindC = Instance.new("Folder", UseFolder)
                                                        FindC.Name = Obj.Name
                                                        local ObjVal = Instance.new("ObjectValue", FindC)
                                                        ObjVal.Value = Obj
                                                    end

                                                    for _, P in next, Crap do
                                                        if P:IsA("PVInstance") and P.Name ~= "HumanoidRootPart" then
                                                            local Box = Instance.new("BoxHandleAdornment")
                                                            Box.Size = GetSizeOfObject(P)
                                                            Box.Name = "Cham"
                                                            Box.Adornee = P
                                                            Box.AlwaysOnTop = true
                                                            Box.ZIndex = 5
                                                            Box.Transparency = 0
                                                            Box.Color3 = ((IsPlr) and GetTeamColor(Plrs:GetPlayerFromCharacter(Obj))) or Bullshit.Colors.Neutral
                                                            Box.Parent = FindC
                                                        end
                                                    end
                                                end
                                            end

                                            function CreateMobESPChams()
                                                local mobspawn = { }

                                                for i, v in next, workspace:GetDescendants() do
                                                    local hum = v:FindFirstChildOfClass("Humanoid")
                                                    if hum and not Plrs:GetPlayerFromCharacter(hum.Parent) and FindCham(v) == nil and FindESP(v) == nil then
                                                        mobspawn[tostring(v.Parent)] = v.Parent
                                                        if Bullshit.CHAMSEnabled and Bullshit.MobChams then
                                                            CreateChams(v)
                                                        end
                                                        if Bullshit.ESPEnabled and Bullshit.MobESP then
                                                            CreateESP(v)
                                                        end
                                                    end
                                                end

                                                if Bullshit.Mob_ESP_CHAMS_Ran_Once == false then
                                                    for i, v in next, mobspawn do
                                                        v.ChildAdded:connect(function(Obj)
                                                            if Bullshit.MobChams then
                                                                local t = tick()
                                                                local GetHum = Obj:FindFirstChildOfClass("Humanoid")
                                                                if GetHum == nil then
                                                                    repeat
                                                                        GetHum = Obj:FindFirstChildOfClass("Humanoid")
                                                                        wait()
                                                                    until GetHum ~= nil or (tick() - t) >= 10
                                                                end
                                                                if GetHum == nil then return end

                                                                CreateChams(Obj)
                                                            end

                                                            if Bullshit.MobESP then
                                                                local t = tick()
                                                                local GetHum = Obj:FindFirstChildOfClass("Humanoid")
                                                                if GetHum == nil then
                                                                    repeat
                                                                        GetHum = Obj:FindFirstChildOfClass("Humanoid")
                                                                        wait()
                                                                    until GetHum ~= nil or (tick() - t) >= 10
                                                                end
                                                                if GetHum == nil then return end

                                                                CreateESP(Obj)
                                                            end
                                                        end)
                                                    end

                                                    Bullshit.Mob_ESP_CHAMS_Ran_Once = true
                                                end
                                            end

                                            function CreateChildAddedEventFor(Obj)
                                                Obj.ChildAdded:connect(function(Obj2)
                                                    if Bullshit.OutlinesEnabled then
                                                        if Obj2:IsA("BasePart") and not Plrs:GetPlayerFromCharacter(Obj2.Parent) and not Obj2.Parent:IsA("Hat") and not Obj2.Parent:IsA("Accessory") and Obj2.Parent.Name ~= "Tracers" then
                                                            local Data = { }
                                                            Data[2] = Obj2.Transparency
                                                            Obj2.Transparency = 1
                                                            local outline = Instance.new("SelectionBox")
                                                            outline.Name = "Outline"
                                                            outline.Color3 = Color3.new(0, 0, 0)
                                                            outline.SurfaceColor3 = Color3.new(0, 1, 0)
                                                            --outline.SurfaceTransparency = 0.9
                                                            outline.LineThickness = 0.01
                                                            outline.Transparency = 0.5
                                                            outline.Transparency = 0.5
                                                            outline.Adornee = Obj2
                                                            outline.Parent = Obj2
                                                            Data[1] = outline
                                                            rawset(Bullshit.OutlinedParts, Obj2, Data)
                                                        end

                                                        for i, v in next, Obj2:GetDescendants() do
                                                            if v:IsA("BasePart") and not Plrs:GetPlayerFromCharacter(v.Parent) and not v.Parent:IsA("Hat") and not v.Parent:IsA("Accessory") and v.Parent.Name ~= "Tracers" then
                                                                local Data = { }
                                                                Data[2] = v.Transparency
                                                                v.Transparency = 1
                                                                local outline = Instance.new("SelectionBox")
                                                                outline.Name = "Outline"
                                                                outline.Color3 = Color3.new(0, 0, 0)
                                                                outline.SurfaceColor3 = Color3.new(0, 1, 0)
                                                                --outline.SurfaceTransparency = 0.9
                                                                outline.LineThickness = 0.01
                                                                outline.Transparency = 0.5
                                                                outline.Adornee = v
                                                                outline.Parent = v
                                                                Data[1] = outline
                                                                rawset(Bullshit.OutlinedParts, v, Data)
                                                            end
                                                            CreateChildAddedEventFor(v)
                                                        end
                                                    end
                                                    CreateChildAddedEventFor(Obj2)
                                                end)
                                            end

                                            function LightingHax()
                                                if Bullshit.OutlinesEnabled then
                                                    Light.TimeOfDay = "00:00:00"
                                                end

                                                if Bullshit.FullbrightEnabled then
                                                    Light.Ambient = Color3.new(1, 1, 1)
                                                    Light.ColorShift_Bottom = Color3.new(1, 1, 1)
                                                    Light.ColorShift_Top = Color3.new(1, 1, 1)
                                                end
                                            end

                                            Plrs.PlayerAdded:connect(function(Plr)
                                                if Bullshit.CharAddedEvent[Plr.Name] == nil then
                                                    Bullshit.CharAddedEvent[Plr.Name] = Plr.CharacterAdded:connect(function(Char)
                                                        if Bullshit.ESPEnabled then
                                                            RemoveESP(Plr)
                                                            CreateESP(Plr)
                                                        end
                                                        if Bullshit.CHAMSEnabled then
                                                            RemoveChams(Plr)
                                                            CreateChams(Plr)
                                                        end
                                                        if Bullshit.TracersEnabled then
                                                            CreateTracers(Plr)
                                                        end
                                                        repeat wait() until Char:FindFirstChild("HumanoidRootPart")
                                                        TracerMT[Plr.Name] = Char.HumanoidRootPart
                                                    end)
                                                end
                                            end)

                                            Plrs.PlayerRemoving:connect(function(Plr)
                                                if Bullshit.CharAddedEvent[Plr.Name] ~= nil then
                                                    Bullshit.CharAddedEvent[Plr.Name]:Disconnect()
                                                    Bullshit.CharAddedEvent[Plr.Name] = nil
                                                end
                                                RemoveESP(Plr)
                                                RemoveChams(Plr)
                                                RemoveTracers(Plr)
                                                TracerMT[Plr.Name] = nil
                                            end)

                                            function InitMain()
                                                -- Objects
                                                
                                                local Bullshit20 = Instance.new("ScreenGui")
                                                local MainFrame = Instance.new("Frame")
                                                local Title = Instance.new("TextLabel")
                                                local design = Instance.new("Frame")
                                                local buttons = Instance.new("Frame")
                                                local ESPToggle = Instance.new("TextButton")
                                                local ChamsToggle = Instance.new("TextButton")
                                                local TracersToggle = Instance.new("TextButton")
                                                local OutlineToggle = Instance.new("TextButton")
                                                local DebugToggle = Instance.new("TextButton")
                                                local FullbrightToggle = Instance.new("TextButton")
                                                local BlacklistToggle = Instance.new("TextButton")
                                                local WhitelistToggle = Instance.new("TextButton")
                                                local Crosshair = Instance.new("TextButton")
                                                local AimbotToggle = Instance.new("TextButton")
                                                local Settings = Instance.new("TextButton")
                                                local Information = Instance.new("TextButton")
                                                local Information_2 = Instance.new("Frame")
                                                local Title_2 = Instance.new("TextLabel")
                                                local design_2 = Instance.new("Frame")
                                                local buttons_2 = Instance.new("ScrollingFrame")
                                                local TextLabel = Instance.new("TextLabel")
                                                local Settings_2 = Instance.new("Frame")
                                                local Title_3 = Instance.new("TextLabel")
                                                local design_3 = Instance.new("Frame")
                                                local buttons_3 = Instance.new("ScrollingFrame")
                                                local AllyColor = Instance.new("TextBox")
                                                local CHAMSLength = Instance.new("TextBox")
                                                local CrosshairColor = Instance.new("TextBox")
                                                local ESPLength = Instance.new("TextBox")
                                                local EnemyColor = Instance.new("TextBox")
                                                local FreeForAll = Instance.new("TextButton")
                                                local FriendColor = Instance.new("TextBox")
                                                local NeutralColor = Instance.new("TextBox")
                                                local TracersLength = Instance.new("TextBox")
                                                local TracersUnderChars = Instance.new("TextButton")
                                                local AutoFireToggle = Instance.new("TextButton")
                                                local AimbotKey = Instance.new("TextButton")
                                                local MobESPButton = Instance.new("TextButton")
                                                local MobChamsButton = Instance.new("TextButton")
                                                local TextLabel_2 = Instance.new("TextLabel")
                                                local TextLabel_3 = Instance.new("TextLabel")
                                                local TextLabel_4 = Instance.new("TextLabel")
                                                local TextLabel_5 = Instance.new("TextLabel")
                                                local TextLabel_6 = Instance.new("TextLabel")
                                                local TextLabel_7 = Instance.new("TextLabel")
                                                local TextLabel_8 = Instance.new("TextLabel")
                                                local TextLabel_9 = Instance.new("TextLabel")
                                                local TextLabel_10 = Instance.new("TextLabel")
                                                local TextLabel_11 = Instance.new("TextLabel")
                                                local TextLabel_12 = Instance.new("TextLabel")
                                                local TextLabel_13 = Instance.new("TextLabel")
                                                local TextLabel_14 = Instance.new("TextLabel")
                                                local TextLabel_15 = Instance.new("TextLabel")
                                                local SaveSettings = Instance.new("TextButton")
                                                local Blacklist = Instance.new("Frame")
                                                local nigga = Instance.new("TextLabel")
                                                local niggerfaggot = Instance.new("Frame")
                                                local players = Instance.new("ScrollingFrame")
                                                local buttonsex = Instance.new("Frame")
                                                local Playername = Instance.new("TextBox")
                                                local AddToBlacklist = Instance.new("TextButton")
                                                local RemoveToBlacklist = Instance.new("TextButton")
                                                local SaveBlacklist = Instance.new("TextButton")
                                                local Whitelist = Instance.new("Frame")
                                                local nigga2 = Instance.new("TextLabel")
                                                local niggerfaggot2 = Instance.new("Frame")
                                                local players2 = Instance.new("ScrollingFrame")
                                                local buttonsex2 = Instance.new("Frame")
                                                local Playername2 = Instance.new("TextBox")
                                                local AddToWhitelist = Instance.new("TextButton")
                                                local RemoveToWhitelist = Instance.new("TextButton")
                                                local SaveWhitelist = Instance.new("TextButton")
                                                
                                                -- Properties
                                                
                                                Bullshit20.Name = "Bullshit 3.0"
                                                Bullshit20.Parent = CoreGui
                                                Bullshit20.ResetOnSpawn = false
                                                
                                                MainFrame.Name = "MainFrame"
                                                MainFrame.Parent = Bullshit20
                                                MainFrame.Active = true
                                                MainFrame.BackgroundColor3 = Color3.new(0.176471, 0.176471, 0.176471)
                                                MainFrame.BorderSizePixel = 0
                                                MainFrame.Draggable = true
                                                MainFrame.Position = UDim2.new(0.200000003, -175, 0.5, -100)
                                                MainFrame.Size = UDim2.new(0, 350, 0, 315)
                                                
                                                Title.Name = "Title"
                                                Title.Parent = MainFrame
                                                Title.BackgroundColor3 = Color3.new(1, 1, 1)
                                                Title.BackgroundTransparency = 1
                                                Title.Size = UDim2.new(1, 0, 0, 50)
                                                Title.Font = Enum.Font.SourceSansBold
                                                Title.Text = "Project: Bullshit\nMade by: Racist Dolphin#5199\nVersion 3.5.5 (RE-WORK IN THE WORKS)"
                                                Title.TextColor3 = Color3.new(1, 1, 1)
                                                Title.TextSize = 18
                                                Title.TextTransparency = 0.5
                                                
                                                design.Name = "design"
                                                design.Parent = MainFrame
                                                design.BackgroundColor3 = Color3.new(1, 1, 1)
                                                design.BackgroundTransparency = 0.5
                                                design.BorderSizePixel = 0
                                                design.Position = UDim2.new(0.0500000007, 0, 0, 50)
                                                design.Size = UDim2.new(0.899999976, 0, 0, 2)
                                                
                                                buttons.Name = "buttons"
                                                buttons.Parent = MainFrame
                                                buttons.BackgroundColor3 = Color3.new(1, 1, 1)
                                                buttons.BackgroundTransparency = 1
                                                buttons.Position = UDim2.new(0, 20, 0, 70)
                                                buttons.Size = UDim2.new(1, -40, 1, -80)

                                                Blacklist.Name = "Blacklist"
                                                Blacklist.Parent = MainFrame
                                                Blacklist.Active = true
                                                Blacklist.BackgroundColor3 = Color3.new(0.176471, 0.176471, 0.176471)
                                                Blacklist.BorderSizePixel = 0
                                                Blacklist.Position = UDim2.new(1, 3, 0.5, -138)
                                                Blacklist.Size = UDim2.new(0, 350, 0, 375)
                                                Blacklist.Visible = false
                                                
                                                nigga.Name = "nigga"
                                                nigga.Parent = Blacklist
                                                nigga.BackgroundColor3 = Color3.new(1, 1, 1)
                                                nigga.BackgroundTransparency = 1
                                                nigga.Size = UDim2.new(1, 0, 0, 50)
                                                nigga.Font = Enum.Font.SourceSansBold
                                                nigga.Text = "Blacklist Menu"
                                                nigga.TextColor3 = Color3.new(1, 1, 1)
                                                nigga.TextSize = 18
                                                nigga.TextTransparency = 0.5
                                                
                                                niggerfaggot.Name = "niggerfaggot"
                                                niggerfaggot.Parent = Blacklist
                                                niggerfaggot.BackgroundColor3 = Color3.new(1, 1, 1)
                                                niggerfaggot.BackgroundTransparency = 0.5
                                                niggerfaggot.BorderSizePixel = 0
                                                niggerfaggot.Position = UDim2.new(0.0500000007, 0, 0, 50)
                                                niggerfaggot.Size = UDim2.new(0.899999976, 0, 0, 2)
                                                
                                                players.Name = "players"
                                                players.Parent = Blacklist
                                                players.BackgroundColor3 = Color3.new(1, 1, 1)
                                                players.BackgroundTransparency = 1
                                                players.BorderSizePixel = 0
                                                players.Position = UDim2.new(0, 20, 0, 60)
                                                players.Size = UDim2.new(1, -40, 1, -175)
                                                players.CanvasSize = UDim2.new(0, 0, 5, 0)
                                                players.ScrollBarThickness = 8
                                                
                                                buttonsex.Name = "buttonsex"
                                                buttonsex.Parent = Blacklist
                                                buttonsex.BackgroundColor3 = Color3.new(1, 1, 1)
                                                buttonsex.BackgroundTransparency = 1
                                                buttonsex.Position = UDim2.new(0, 20, 0, 250)
                                                buttonsex.Size = UDim2.new(1, -40, 0, 100)
                                                
                                                Playername.Name = "Playername"
                                                Playername.Parent = buttonsex
                                                Playername.BackgroundColor3 = Color3.new(0.972549, 0.972549, 0.972549)
                                                Playername.BackgroundTransparency = 0.5
                                                Playername.BorderSizePixel = 0
                                                Playername.Size = UDim2.new(1, 0, 0, 20)
                                                Playername.Font = Enum.Font.SourceSansBold
                                                Playername.Text = "Enter Player Name"
                                                Playername.TextSize = 14
                                                Playername.TextWrapped = true
                                                
                                                AddToBlacklist.Name = "AddToBlacklist"
                                                AddToBlacklist.Parent = buttonsex
                                                AddToBlacklist.BackgroundColor3 = Color3.new(0.972549, 0.972549, 0.972549)
                                                AddToBlacklist.BackgroundTransparency = 0.5
                                                AddToBlacklist.BorderSizePixel = 0
                                                AddToBlacklist.Position = UDim2.new(0, 0, 0, 30)
                                                AddToBlacklist.Size = UDim2.new(1, 0, 0, 20)
                                                AddToBlacklist.Font = Enum.Font.SourceSansBold
                                                AddToBlacklist.Text = "Add to Blacklist"
                                                AddToBlacklist.TextSize = 14
                                                AddToBlacklist.TextWrapped = true
                                                
                                                RemoveToBlacklist.Name = "RemoveToBlacklist"
                                                RemoveToBlacklist.Parent = buttonsex
                                                RemoveToBlacklist.BackgroundColor3 = Color3.new(0.972549, 0.972549, 0.972549)
                                                RemoveToBlacklist.BackgroundTransparency = 0.5
                                                RemoveToBlacklist.BorderSizePixel = 0
                                                RemoveToBlacklist.Position = UDim2.new(0, 0, 0, 60)
                                                RemoveToBlacklist.Size = UDim2.new(1, 0, 0, 20)
                                                RemoveToBlacklist.Font = Enum.Font.SourceSansBold
                                                RemoveToBlacklist.Text = "Remove from Blacklist"
                                                RemoveToBlacklist.TextSize = 14
                                                RemoveToBlacklist.TextWrapped = true

                                                SaveBlacklist.Name = "SaveBlacklist"
                                                SaveBlacklist.Parent = buttonsex
                                                SaveBlacklist.BackgroundColor3 = Color3.new(0.972549, 0.972549, 0.972549)
                                                SaveBlacklist.BackgroundTransparency = 0.5
                                                SaveBlacklist.BorderSizePixel = 0
                                                SaveBlacklist.Position = UDim2.new(0, 0, 0, 90)
                                                SaveBlacklist.Size = UDim2.new(1, 0, 0, 20)
                                                SaveBlacklist.Font = Enum.Font.SourceSansBold
                                                SaveBlacklist.Text = "Save Blacklist"
                                                SaveBlacklist.TextSize = 14
                                                SaveBlacklist.TextWrapped = true

                                                Whitelist.Name = "Whitelist"
                                                Whitelist.Parent = MainFrame
                                                Whitelist.Active = true
                                                Whitelist.BackgroundColor3 = Color3.new(0.176471, 0.176471, 0.176471)
                                                Whitelist.BorderSizePixel = 0
                                                Whitelist.Position = UDim2.new(1, 3, 0.5, -138)
                                                Whitelist.Size = UDim2.new(0, 350, 0, 375)
                                                Whitelist.Visible = false
                                                
                                                nigga2.Name = "nigga2"
                                                nigga2.Parent = Whitelist
                                                nigga2.BackgroundColor3 = Color3.new(1, 1, 1)
                                                nigga2.BackgroundTransparency = 1
                                                nigga2.Size = UDim2.new(1, 0, 0, 50)
                                                nigga2.Font = Enum.Font.SourceSansBold
                                                nigga2.Text = "Friends List Menu"
                                                nigga2.TextColor3 = Color3.new(1, 1, 1)
                                                nigga2.TextSize = 18
                                                nigga2.TextTransparency = 0.5
                                                
                                                niggerfaggot2.Name = "niggerfaggot2"
                                                niggerfaggot2.Parent = Whitelist
                                                niggerfaggot2.BackgroundColor3 = Color3.new(1, 1, 1)
                                                niggerfaggot2.BackgroundTransparency = 0.5
                                                niggerfaggot2.BorderSizePixel = 0
                                                niggerfaggot2.Position = UDim2.new(0.0500000007, 0, 0, 50)
                                                niggerfaggot2.Size = UDim2.new(0.899999976, 0, 0, 2)
                                                
                                                players2.Name = "players2"
                                                players2.Parent = Whitelist
                                                players2.BackgroundColor3 = Color3.new(1, 1, 1)
                                                players2.BackgroundTransparency = 1
                                                players2.BorderSizePixel = 0
                                                players2.Position = UDim2.new(0, 20, 0, 60)
                                                players2.Size = UDim2.new(1, -40, 1, -175)
                                                players2.CanvasSize = UDim2.new(0, 0, 5, 0)
                                                players2.ScrollBarThickness = 8
                                                
                                                buttonsex2.Name = "buttonsex2"
                                                buttonsex2.Parent = Whitelist
                                                buttonsex2.BackgroundColor3 = Color3.new(1, 1, 1)
                                                buttonsex2.BackgroundTransparency = 1
                                                buttonsex2.Position = UDim2.new(0, 20, 0, 250)
                                                buttonsex2.Size = UDim2.new(1, -40, 0, 100)
                                                
                                                Playername2.Name = "Playername2"
                                                Playername2.Parent = buttonsex2
                                                Playername2.BackgroundColor3 = Color3.new(0.972549, 0.972549, 0.972549)
                                                Playername2.BackgroundTransparency = 0.5
                                                Playername2.BorderSizePixel = 0
                                                Playername2.Size = UDim2.new(1, 0, 0, 20)
                                                Playername2.Font = Enum.Font.SourceSansBold
                                                Playername2.Text = "Enter Player Name"
                                                Playername2.TextSize = 14
                                                Playername2.TextWrapped = true
                                                
                                                AddToWhitelist.Name = "AddToWhitelist"
                                                AddToWhitelist.Parent = buttonsex2
                                                AddToWhitelist.BackgroundColor3 = Color3.new(0.972549, 0.972549, 0.972549)
                                                AddToWhitelist.BackgroundTransparency = 0.5
                                                AddToWhitelist.BorderSizePixel = 0
                                                AddToWhitelist.Position = UDim2.new(0, 0, 0, 30)
                                                AddToWhitelist.Size = UDim2.new(1, 0, 0, 20)
                                                AddToWhitelist.Font = Enum.Font.SourceSansBold
                                                AddToWhitelist.Text = "Add to Friends List"
                                                AddToWhitelist.TextSize = 14
                                                AddToWhitelist.TextWrapped = true
                                                
                                                RemoveToWhitelist.Name = "RemoveToWhitelist"
                                                RemoveToWhitelist.Parent = buttonsex2
                                                RemoveToWhitelist.BackgroundColor3 = Color3.new(0.972549, 0.972549, 0.972549)
                                                RemoveToWhitelist.BackgroundTransparency = 0.5
                                                RemoveToWhitelist.BorderSizePixel = 0
                                                RemoveToWhitelist.Position = UDim2.new(0, 0, 0, 60)
                                                RemoveToWhitelist.Size = UDim2.new(1, 0, 0, 20)
                                                RemoveToWhitelist.Font = Enum.Font.SourceSansBold
                                                RemoveToWhitelist.Text = "Remove from Friends List"
                                                RemoveToWhitelist.TextSize = 14
                                                RemoveToWhitelist.TextWrapped = true

                                                SaveWhitelist.Name = "SaveWhitelist"
                                                SaveWhitelist.Parent = buttonsex2
                                                SaveWhitelist.BackgroundColor3 = Color3.new(0.972549, 0.972549, 0.972549)
                                                SaveWhitelist.BackgroundTransparency = 0.5
                                                SaveWhitelist.BorderSizePixel = 0
                                                SaveWhitelist.Position = UDim2.new(0, 0, 0, 90)
                                                SaveWhitelist.Size = UDim2.new(1, 0, 0, 20)
                                                SaveWhitelist.Font = Enum.Font.SourceSansBold
                                                SaveWhitelist.Text = "Save Friends List"
                                                SaveWhitelist.TextSize = 14
                                                SaveWhitelist.TextWrapped = true

                                                BlacklistToggle.Name = "BlacklistToggle"
                                                BlacklistToggle.Parent = buttons
                                                BlacklistToggle.BackgroundColor3 = Color3.new(1, 1, 1)
                                                BlacklistToggle.BackgroundTransparency = 0.5
                                                BlacklistToggle.BorderSizePixel = 0
                                                BlacklistToggle.Position = UDim2.new(0, 0, 0, 200)
                                                BlacklistToggle.Size = UDim2.new(0, 150, 0, 30)
                                                BlacklistToggle.Font = Enum.Font.SourceSansBold
                                                BlacklistToggle.Text = "Blacklist"
                                                BlacklistToggle.TextColor3 = Color3.new(0.176471, 0.176471, 0.176471)
                                                BlacklistToggle.TextSize = 14
                                                BlacklistToggle.TextWrapped = true

                                                WhitelistToggle.Name = "WhitelistToggle"
                                                WhitelistToggle.Parent = buttons
                                                WhitelistToggle.BackgroundColor3 = Color3.new(1, 1, 1)
                                                WhitelistToggle.BackgroundTransparency = 0.5
                                                WhitelistToggle.BorderSizePixel = 0
                                                WhitelistToggle.Position = UDim2.new(1, -150, 0, 200)
                                                WhitelistToggle.Size = UDim2.new(0, 150, 0, 30)
                                                WhitelistToggle.Font = Enum.Font.SourceSansBold
                                                WhitelistToggle.Text = "Friends List"
                                                WhitelistToggle.TextColor3 = Color3.new(0.176471, 0.176471, 0.176471)
                                                WhitelistToggle.TextSize = 14
                                                WhitelistToggle.TextWrapped = true
                                                
                                                ESPToggle.Name = "ESPToggle"
                                                ESPToggle.Parent = buttons
                                                ESPToggle.BackgroundColor3 = Color3.new(1, 1, 1)
                                                ESPToggle.BackgroundTransparency = 0.5
                                                ESPToggle.BorderSizePixel = 0
                                                ESPToggle.Size = UDim2.new(0, 150, 0, 30)
                                                ESPToggle.Font = Enum.Font.SourceSansBold
                                                ESPToggle.Text = "ESP"
                                                ESPToggle.TextColor3 = Color3.new(0.176471, 0.176471, 0.176471)
                                                ESPToggle.TextSize = 14
                                                ESPToggle.TextWrapped = true
                                                
                                                ChamsToggle.Name = "ChamsToggle"
                                                ChamsToggle.Parent = buttons
                                                ChamsToggle.BackgroundColor3 = Color3.new(1, 1, 1)
                                                ChamsToggle.BackgroundTransparency = 0.5
                                                ChamsToggle.BorderSizePixel = 0
                                                ChamsToggle.Position = UDim2.new(1, -150, 0, 0)
                                                ChamsToggle.Size = UDim2.new(0, 150, 0, 30)
                                                ChamsToggle.Font = Enum.Font.SourceSansBold
                                                ChamsToggle.Text = "Chams"
                                                ChamsToggle.TextColor3 = Color3.new(0.176471, 0.176471, 0.176471)
                                                ChamsToggle.TextSize = 14
                                                ChamsToggle.TextWrapped = true
                                                
                                                TracersToggle.Name = "TracersToggle"
                                                TracersToggle.Parent = buttons
                                                TracersToggle.BackgroundColor3 = Color3.new(1, 1, 1)
                                                TracersToggle.BackgroundTransparency = 0.5
                                                TracersToggle.BorderSizePixel = 0
                                                TracersToggle.Position = UDim2.new(0, 0, 0, 40)
                                                TracersToggle.Size = UDim2.new(0, 150, 0, 30)
                                                TracersToggle.Font = Enum.Font.SourceSansBold
                                                TracersToggle.Text = "Tracers"
                                                TracersToggle.TextColor3 = Color3.new(0.176471, 0.176471, 0.176471)
                                                TracersToggle.TextSize = 14
                                                TracersToggle.TextWrapped = true
                                                
                                                OutlineToggle.Name = "OutlineToggle"
                                                OutlineToggle.Parent = buttons
                                                OutlineToggle.BackgroundColor3 = Color3.new(1, 1, 1)
                                                OutlineToggle.BackgroundTransparency = 0.5
                                                OutlineToggle.BorderSizePixel = 0
                                                OutlineToggle.Position = UDim2.new(1, -150, 0, 40)
                                                OutlineToggle.Size = UDim2.new(0, 150, 0, 30)
                                                OutlineToggle.Font = Enum.Font.SourceSansBold
                                                OutlineToggle.Text = "Outlines"
                                                OutlineToggle.TextColor3 = Color3.new(0.176471, 0.176471, 0.176471)
                                                OutlineToggle.TextSize = 14
                                                OutlineToggle.TextWrapped = true
                                                
                                                DebugToggle.Name = "DebugToggle"
                                                DebugToggle.Parent = buttons
                                                DebugToggle.BackgroundColor3 = Color3.new(1, 1, 1)
                                                DebugToggle.BackgroundTransparency = 0.5
                                                DebugToggle.BorderSizePixel = 0
                                                DebugToggle.Position = UDim2.new(1, -150, 0, 80)
                                                DebugToggle.Size = UDim2.new(0, 150, 0, 30)
                                                DebugToggle.Font = Enum.Font.SourceSansBold
                                                DebugToggle.Text = "Debug Info"
                                                DebugToggle.TextColor3 = Color3.new(0.176471, 0.176471, 0.176471)
                                                DebugToggle.TextSize = 14
                                                DebugToggle.TextWrapped = true
                                                
                                                FullbrightToggle.Name = "FullbrightToggle"
                                                FullbrightToggle.Parent = buttons
                                                FullbrightToggle.BackgroundColor3 = Color3.new(1, 1, 1)
                                                FullbrightToggle.BackgroundTransparency = 0.5
                                                FullbrightToggle.BorderSizePixel = 0
                                                FullbrightToggle.Position = UDim2.new(0, 0, 0, 80)
                                                FullbrightToggle.Size = UDim2.new(0, 150, 0, 30)
                                                FullbrightToggle.Font = Enum.Font.SourceSansBold
                                                FullbrightToggle.Text = "Fullbright"
                                                FullbrightToggle.TextColor3 = Color3.new(0.176471, 0.176471, 0.176471)
                                                FullbrightToggle.TextSize = 14
                                                FullbrightToggle.TextWrapped = true
                                                
                                                Crosshair.Name = "Crosshair"
                                                Crosshair.Parent = buttons
                                                Crosshair.BackgroundColor3 = Color3.new(1, 1, 1)
                                                Crosshair.BackgroundTransparency = 0.5
                                                Crosshair.BorderSizePixel = 0
                                                Crosshair.Position = UDim2.new(0, 0, 0, 120)
                                                Crosshair.Size = UDim2.new(0, 150, 0, 30)
                                                Crosshair.Font = Enum.Font.SourceSansBold
                                                Crosshair.Text = "Crosshair"
                                                Crosshair.TextColor3 = Color3.new(0.176471, 0.176471, 0.176471)
                                                Crosshair.TextSize = 14
                                                Crosshair.TextWrapped = true
                                                
                                                AimbotToggle.Name = "AimbotToggle"
                                                AimbotToggle.Parent = buttons
                                                AimbotToggle.BackgroundColor3 = Color3.new(1, 1, 1)
                                                AimbotToggle.BackgroundTransparency = 0.5
                                                AimbotToggle.BorderSizePixel = 0
                                                AimbotToggle.Position = UDim2.new(1, -150, 0, 120)
                                                AimbotToggle.Size = UDim2.new(0, 150, 0, 30)
                                                AimbotToggle.Font = Enum.Font.SourceSansBold
                                                AimbotToggle.Text = "Aimlock"
                                                AimbotToggle.TextColor3 = Color3.new(0.176471, 0.176471, 0.176471)
                                                AimbotToggle.TextSize = 14
                                                AimbotToggle.TextWrapped = true
                                                
                                                Settings.Name = "Settings"
                                                Settings.Parent = buttons
                                                Settings.BackgroundColor3 = Color3.new(1, 1, 1)
                                                Settings.BackgroundTransparency = 0.5
                                                Settings.BorderSizePixel = 0
                                                Settings.Position = UDim2.new(1, -150, 0, 160)
                                                Settings.Size = UDim2.new(0, 150, 0, 30)
                                                Settings.Font = Enum.Font.SourceSansBold
                                                Settings.Text = "Settings"
                                                Settings.TextColor3 = Color3.new(0.176471, 0.176471, 0.176471)
                                                Settings.TextSize = 14
                                                Settings.TextWrapped = true
                                                
                                                Information.Name = "Information"
                                                Information.Parent = buttons
                                                Information.BackgroundColor3 = Color3.new(1, 1, 1)
                                                Information.BackgroundTransparency = 0.5
                                                Information.BorderSizePixel = 0
                                                Information.Position = UDim2.new(0, 0, 0, 160)
                                                Information.Size = UDim2.new(0, 150, 0, 30)
                                                Information.Font = Enum.Font.SourceSansBold
                                                Information.Text = "Information"
                                                Information.TextColor3 = Color3.new(0.176471, 0.176471, 0.176471)
                                                Information.TextSize = 14
                                                Information.TextWrapped = true
                                                
                                                Information_2.Name = "Information"
                                                Information_2.Parent = MainFrame
                                                Information_2.Active = true
                                                Information_2.BackgroundColor3 = Color3.new(0.176471, 0.176471, 0.176471)
                                                Information_2.BorderSizePixel = 0
                                                Information_2.Position = UDim2.new(1, 3, 0.5, -138)
                                                Information_2.Size = UDim2.new(0, 350, 0, 365)
                                                Information_2.Visible = false
                                                
                                                Title_2.Name = "Title"
                                                Title_2.Parent = Information_2
                                                Title_2.BackgroundColor3 = Color3.new(1, 1, 1)
                                                Title_2.BackgroundTransparency = 1
                                                Title_2.Size = UDim2.new(1, 0, 0, 50)
                                                Title_2.Font = Enum.Font.SourceSansBold
                                                Title_2.Text = "Information"
                                                Title_2.TextColor3 = Color3.new(1, 1, 1)
                                                Title_2.TextSize = 18
                                                Title_2.TextTransparency = 0.5
                                                
                                                design_2.Name = "design"
                                                design_2.Parent = Information_2
                                                design_2.BackgroundColor3 = Color3.new(1, 1, 1)
                                                design_2.BackgroundTransparency = 0.5
                                                design_2.BorderSizePixel = 0
                                                design_2.Position = UDim2.new(0.0500000007, 0, 0, 50)
                                                design_2.Size = UDim2.new(0.899999976, 0, 0, 2)
                                                
                                                buttons_2.Name = "buttons"
                                                buttons_2.Parent = Information_2
                                                buttons_2.BackgroundColor3 = Color3.new(1, 1, 1)
                                                buttons_2.BackgroundTransparency = 1
                                                buttons_2.BorderSizePixel = 0
                                                buttons_2.Position = UDim2.new(0, 20, 0, 60)
                                                buttons_2.Size = UDim2.new(1, -40, 1, -70)
                                                buttons_2.CanvasSize = UDim2.new(5, 0, 5, 0)
                                                buttons_2.ScrollBarThickness = 5
                                                
                                                TextLabel.Parent = buttons_2
                                                TextLabel.BackgroundColor3 = Color3.new(1, 1, 1)
                                                TextLabel.BackgroundTransparency = 1
                                                TextLabel.Size = UDim2.new(1, -20, 1, 0)
                                                TextLabel.Font = Enum.Font.SourceSansBold
                                                TextLabel.Text = [[
                                            Scripting by: Racist Dolphin#5199
                                            GUI by: SOMEONE WHO WANTS HIS NAME HIDDEN.

                                            To hide/show the GUI press the "P" key on your keyboard.

                                            NOTICE: Since my string manipulation skills aren't the greatest, changing esp/cham colors might be quite buggy.
                                            NOTICE #2: The blacklist feature will return! I just didn't have enough time to make the gui.
                                            NOTICE #3: Save Settings might still be bugged. Message me if it's fucked up still.

                                            This works on every game, though the Aimbot does NOT! (Doesn't work on: Jailbreak, and Phantom Forces)

                                            FAQ:
                                            1) How do I use the aimbot?
                                            A: Activate it, and hold right-click in-game. The aimbot will lock on to the closest enemy NOT behind a wall. (If said player is behind a wall, it will find the next closest player not behind a wall.)

                                            2) ESP/Chams don't work on the game I play?
                                            A: Some games require me to make patches (ex: Murder Mystery, Murder Mystery X) to request a patch or a game message me on discord.

                                            3) How did I detect when a player is behind a wall?
                                            A: Raycasting the camera to another player.

                                            4) My bullets still miss when using aimbot?!
                                            A: Blame bullet spread, try and control how often you fire. (Murder Mystery 2 = trash) (Why the fuck does a single shot pistol have bullet spread? lol wtf?)

                                            Change Log:
                                            3/10/2018:
                                            + Fixed more bugs with chams

                                            3/10/2018:
                                            + Fixed how chams broke when a player respawned.

                                            3/10/2018:
                                            + Fixed ESP not updating correctly.
                                            + Fixed Chams not updating correctly. (MAYBE? IDK WHAT IS BREAKING THIS)

                                            3/9/2018:
                                            + Mob ESP/Chams! (BETA!)

                                            3/8/2018:
                                            + Fixed the error you get when not entering a valid number for esp/chams/tracer lengths.
                                            + Fixed lag issues with aimlock.
                                            + Fixed lag issues with chams.

                                            3/8/2018:
                                            + Patch for Murder 15
                                            - Temporarily removed auto fire since mouse1click is broken on Synapse :(

                                            3/7/2018:
                                            + Updated save settings.
                                            + Can now customize aimlock key.

                                            3/7/2018:
                                            + Patch for Wild Revolver.
                                            + Fix for autofire. (Hopefully)

                                            3/6/2018:
                                            - Removed :IsFriendsWith check. (Use Friends List GUI instead)

                                            3/4/2018:
                                            + Added Friend List Menu
                                            + Patch for Assassin!

                                            3/4/2018:
                                            + Fixed crosshair toggle.
                                            + Aimlock patch for Island Royal.
                                            + Finally fixed save settings.

                                            3/4/2018:
                                            + Aimlock fixed for Unit 1968: Vietnam
                                            + Autofire setting for aimlock
                                            + Fixed how you sometimes had to double click buttons to activate a option

                                            3/4/2018:
                                            + Fixed FreeForAll setting bug.
                                            + Using aimlock on Phantom Forces / Jailbreak will now tell you it will not work.
                                            * Renamed Aimbot back to Aimlock

                                            3/3/2018:
                                            + Blacklist feature re-added.
                                            + Aimbot will no longer focus people in the blacklist.
                                            + Compatible on exploits that have readfile and writefile.

                                            3/3/2018:
                                            + GUI Overhaul
                                            + Aimbot now only targets people NOT behind walls
                                            + Chams now dim when x player is visible on your screen.
                                            + Chams no longer have the humanoid root part. (Your welcome)
                                            + Patch for Silent Assassin
                                            + My discord was deleted, so I'm using pastebin now. (Auto updates :)
                                            ]]
                                                TextLabel.TextColor3 = Color3.new(1, 1, 1)
                                                TextLabel.TextSize = 16
                                                TextLabel.TextTransparency = 0.5
                                                TextLabel.TextXAlignment = Enum.TextXAlignment.Left
                                                TextLabel.TextYAlignment = Enum.TextYAlignment.Top
                                                
                                                Settings_2.Name = "Settings"
                                                Settings_2.Parent = MainFrame
                                                Settings_2.Active = true
                                                Settings_2.BackgroundColor3 = Color3.new(0.176471, 0.176471, 0.176471)
                                                Settings_2.BorderSizePixel = 0
                                                Settings_2.Position = UDim2.new(1, 3, 0.5, -138)
                                                Settings_2.Size = UDim2.new(0, 350, 0, 365)
                                                Settings_2.Visible = false
                                                
                                                Title_3.Name = "Title"
                                                Title_3.Parent = Settings_2
                                                Title_3.BackgroundColor3 = Color3.new(1, 1, 1)
                                                Title_3.BackgroundTransparency = 1
                                                Title_3.Size = UDim2.new(1, 0, 0, 50)
                                                Title_3.Font = Enum.Font.SourceSansBold
                                                Title_3.Text = "Settings Menu"
                                                Title_3.TextColor3 = Color3.new(1, 1, 1)
                                                Title_3.TextSize = 18
                                                Title_3.TextTransparency = 0.5
                                                
                                                design_3.Name = "design"
                                                design_3.Parent = Settings_2
                                                design_3.BackgroundColor3 = Color3.new(1, 1, 1)
                                                design_3.BackgroundTransparency = 0.5
                                                design_3.BorderSizePixel = 0
                                                design_3.Position = UDim2.new(0.0500000007, 0, 0, 50)
                                                design_3.Size = UDim2.new(0.899999976, 0, 0, 2)
                                                
                                                buttons_3.Name = "buttons"
                                                buttons_3.Parent = Settings_2
                                                buttons_3.BackgroundColor3 = Color3.new(1, 1, 1)
                                                buttons_3.BackgroundTransparency = 1
                                                buttons_3.BorderSizePixel = 0
                                                buttons_3.Position = UDim2.new(0, 20, 0, 60)
                                                buttons_3.Size = UDim2.new(1, -40, 1, -70)
                                                buttons_3.ScrollBarThickness = 8
                                                
                                                AllyColor.Name = "AllyColor"
                                                AllyColor.Parent = buttons_3
                                                AllyColor.BackgroundColor3 = Color3.new(0.972549, 0.972549, 0.972549)
                                                AllyColor.BackgroundTransparency = 0.5
                                                AllyColor.BorderSizePixel = 0
                                                AllyColor.Position = UDim2.new(1, -150, 0, 180)
                                                AllyColor.Size = UDim2.new(0, 135, 0, 20)
                                                AllyColor.Font = Enum.Font.SourceSansBold
                                                AllyColor.Text = tostring(Bullshit.Colors.Ally)
                                                AllyColor.TextSize = 14
                                                AllyColor.TextWrapped = true
                                                
                                                CHAMSLength.Name = "CHAMSLength"
                                                CHAMSLength.Parent = buttons_3
                                                CHAMSLength.BackgroundColor3 = Color3.new(0.972549, 0.972549, 0.972549)
                                                CHAMSLength.BackgroundTransparency = 0.5
                                                CHAMSLength.BorderSizePixel = 0
                                                CHAMSLength.Position = UDim2.new(1, -150, 0, 60)
                                                CHAMSLength.Size = UDim2.new(0, 135, 0, 20)
                                                CHAMSLength.Font = Enum.Font.SourceSansBold
                                                CHAMSLength.Text = tostring(Bullshit.CHAMSLength)
                                                CHAMSLength.TextSize = 14
                                                CHAMSLength.TextWrapped = true
                                                
                                                CrosshairColor.Name = "CrosshairColor"
                                                CrosshairColor.Parent = buttons_3
                                                CrosshairColor.BackgroundColor3 = Color3.new(0.972549, 0.972549, 0.972549)
                                                CrosshairColor.BackgroundTransparency = 0.5
                                                CrosshairColor.BorderSizePixel = 0
                                                CrosshairColor.Position = UDim2.new(1, -150, 0, 270)
                                                CrosshairColor.Size = UDim2.new(0, 135, 0, 20)
                                                CrosshairColor.Font = Enum.Font.SourceSansBold
                                                CrosshairColor.Text = tostring(Bullshit.Colors.Crosshair)
                                                CrosshairColor.TextSize = 14
                                                CrosshairColor.TextWrapped = true
                                                
                                                ESPLength.Name = "ESPLength"
                                                ESPLength.Parent = buttons_3
                                                ESPLength.BackgroundColor3 = Color3.new(0.972549, 0.972549, 0.972549)
                                                ESPLength.BackgroundTransparency = 0.5
                                                ESPLength.BorderSizePixel = 0
                                                ESPLength.Position = UDim2.new(1, -150, 0, 30)
                                                ESPLength.Size = UDim2.new(0, 135, 0, 20)
                                                ESPLength.Font = Enum.Font.SourceSansBold
                                                ESPLength.Text = tostring(Bullshit.ESPLength)
                                                ESPLength.TextSize = 14
                                                ESPLength.TextWrapped = true
                                                
                                                EnemyColor.Name = "EnemyColor"
                                                EnemyColor.Parent = buttons_3
                                                EnemyColor.BackgroundColor3 = Color3.new(0.972549, 0.972549, 0.972549)
                                                EnemyColor.BackgroundTransparency = 0.5
                                                EnemyColor.BorderSizePixel = 0
                                                EnemyColor.Position = UDim2.new(1, -150, 0, 150)
                                                EnemyColor.Size = UDim2.new(0, 135, 0, 20)
                                                EnemyColor.Font = Enum.Font.SourceSansBold
                                                EnemyColor.Text = tostring(Bullshit.Colors.Enemy)
                                                EnemyColor.TextSize = 14
                                                EnemyColor.TextWrapped = true
                                                
                                                FreeForAll.Name = "FreeForAll"
                                                FreeForAll.Parent = buttons_3
                                                FreeForAll.BackgroundColor3 = Color3.new(0.972549, 0.972549, 0.972549)
                                                FreeForAll.BackgroundTransparency = 0.5
                                                FreeForAll.BorderSizePixel = 0
                                                FreeForAll.Position = UDim2.new(1, -150, 0, 120)
                                                FreeForAll.Size = UDim2.new(0, 135, 0, 20)
                                                FreeForAll.Font = Enum.Font.SourceSansBold
                                                FreeForAll.Text = tostring(Bullshit.FreeForAll)
                                                FreeForAll.TextSize = 14
                                                FreeForAll.TextWrapped = true
                                                
                                                FriendColor.Name = "FriendColor"
                                                FriendColor.Parent = buttons_3
                                                FriendColor.BackgroundColor3 = Color3.new(0.972549, 0.972549, 0.972549)
                                                FriendColor.BackgroundTransparency = 0.5
                                                FriendColor.BorderSizePixel = 0
                                                FriendColor.Position = UDim2.new(1, -150, 0, 210)
                                                FriendColor.Size = UDim2.new(0, 135, 0, 20)
                                                FriendColor.Font = Enum.Font.SourceSansBold
                                                FriendColor.Text = tostring(Bullshit.Colors.Friend)
                                                FriendColor.TextSize = 14
                                                FriendColor.TextWrapped = true
                                                
                                                NeutralColor.Name = "NeutralColor"
                                                NeutralColor.Parent = buttons_3
                                                NeutralColor.BackgroundColor3 = Color3.new(0.972549, 0.972549, 0.972549)
                                                NeutralColor.BackgroundTransparency = 0.5
                                                NeutralColor.BorderSizePixel = 0
                                                NeutralColor.Position = UDim2.new(1, -150, 0, 240)
                                                NeutralColor.Size = UDim2.new(0, 135, 0, 20)
                                                NeutralColor.Font = Enum.Font.SourceSansBold
                                                NeutralColor.Text = tostring(Bullshit.Colors.Neutral)
                                                NeutralColor.TextSize = 14
                                                NeutralColor.TextWrapped = true
                                                
                                                TracersLength.Name = "TracersLength"
                                                TracersLength.Parent = buttons_3
                                                TracersLength.BackgroundColor3 = Color3.new(0.972549, 0.972549, 0.972549)
                                                TracersLength.BackgroundTransparency = 0.5
                                                TracersLength.BorderSizePixel = 0
                                                TracersLength.Position = UDim2.new(1, -150, 0, 0)
                                                TracersLength.Size = UDim2.new(0, 135, 0, 20)
                                                TracersLength.Font = Enum.Font.SourceSansBold
                                                TracersLength.Text = tostring(Bullshit.TracersLength)
                                                TracersLength.TextSize = 14
                                                TracersLength.TextWrapped = true
                                                
                                                TracersUnderChars.Name = "TracersUnderChars"
                                                TracersUnderChars.Parent = buttons_3
                                                TracersUnderChars.BackgroundColor3 = Color3.new(0.972549, 0.972549, 0.972549)
                                                TracersUnderChars.BackgroundTransparency = 0.5
                                                TracersUnderChars.BorderSizePixel = 0
                                                TracersUnderChars.Position = UDim2.new(1, -150, 0, 90)
                                                TracersUnderChars.Size = UDim2.new(0, 135, 0, 20)
                                                TracersUnderChars.Font = Enum.Font.SourceSansBold
                                                TracersUnderChars.Text = tostring(Bullshit.PlaceTracersUnderCharacter)
                                                TracersUnderChars.TextSize = 14
                                                TracersUnderChars.TextWrapped = true

                                                AutoFireToggle.Name = "AutoFireToggle"
                                                AutoFireToggle.Parent = buttons_3
                                                AutoFireToggle.BackgroundColor3 = Color3.new(0.972549, 0.972549, 0.972549)
                                                AutoFireToggle.BackgroundTransparency = 0.5
                                                AutoFireToggle.BorderSizePixel = 0
                                                AutoFireToggle.Position = UDim2.new(1, -150, 0, 300)
                                                AutoFireToggle.Size = UDim2.new(0, 135, 0, 20)
                                                AutoFireToggle.Font = Enum.Font.SourceSansBold
                                                AutoFireToggle.Text = tostring(Bullshit.AutoFire)
                                                AutoFireToggle.TextSize = 14
                                                AutoFireToggle.TextWrapped = true

                                                AimbotKey.Name = "AimbotKey"
                                                AimbotKey.Parent = buttons_3
                                                AimbotKey.BackgroundColor3 = Color3.new(0.972549, 0.972549, 0.972549)
                                                AimbotKey.BackgroundTransparency = 0.5
                                                AimbotKey.BorderSizePixel = 0
                                                AimbotKey.Position = UDim2.new(1, -150, 0, 330)
                                                AimbotKey.Size = UDim2.new(0, 135, 0, 20)
                                                AimbotKey.Font = Enum.Font.SourceSansBold
                                                AimbotKey.Text = tostring(Bullshit.AimbotKey)
                                                AimbotKey.TextSize = 14
                                                AimbotKey.TextWrapped = true

                                                MobESPButton.Name = "MobESPButton"
                                                MobESPButton.Parent = buttons_3
                                                MobESPButton.BackgroundColor3 = Color3.new(0.972549, 0.972549, 0.972549)
                                                MobESPButton.BackgroundTransparency = 0.5
                                                MobESPButton.BorderSizePixel = 0
                                                MobESPButton.Position = UDim2.new(1, -150, 0, 360)
                                                MobESPButton.Size = UDim2.new(0, 135, 0, 20)
                                                MobESPButton.Font = Enum.Font.SourceSansBold
                                                MobESPButton.Text = tostring(Bullshit.MobESP)
                                                MobESPButton.TextSize = 14
                                                MobESPButton.TextWrapped = true

                                                MobChamsButton.Name = "MobChamsButton"
                                                MobChamsButton.Parent = buttons_3
                                                MobChamsButton.BackgroundColor3 = Color3.new(0.972549, 0.972549, 0.972549)
                                                MobChamsButton.BackgroundTransparency = 0.5
                                                MobChamsButton.BorderSizePixel = 0
                                                MobChamsButton.Position = UDim2.new(1, -150, 0, 390)
                                                MobChamsButton.Size = UDim2.new(0, 135, 0, 20)
                                                MobChamsButton.Font = Enum.Font.SourceSansBold
                                                MobChamsButton.Text = tostring(Bullshit.MobChams)
                                                MobChamsButton.TextSize = 14
                                                MobChamsButton.TextWrapped = true
                                                
                                                TextLabel_2.Parent = buttons_3
                                                TextLabel_2.BackgroundColor3 = Color3.new(1, 1, 1)
                                                TextLabel_2.BackgroundTransparency = 1
                                                TextLabel_2.Size = UDim2.new(0.5, 0, 0, 20)
                                                TextLabel_2.Font = Enum.Font.SourceSansBold
                                                TextLabel_2.Text = "Tracers Length"
                                                TextLabel_2.TextColor3 = Color3.new(1, 1, 1)
                                                TextLabel_2.TextSize = 16
                                                TextLabel_2.TextTransparency = 0.5
                                                
                                                TextLabel_3.Parent = buttons_3
                                                TextLabel_3.BackgroundColor3 = Color3.new(1, 1, 1)
                                                TextLabel_3.BackgroundTransparency = 1
                                                TextLabel_3.Position = UDim2.new(0, 0, 0, 30)
                                                TextLabel_3.Size = UDim2.new(0.5, 0, 0, 20)
                                                TextLabel_3.Font = Enum.Font.SourceSansBold
                                                TextLabel_3.Text = "ESP Length"
                                                TextLabel_3.TextColor3 = Color3.new(1, 1, 1)
                                                TextLabel_3.TextSize = 16
                                                TextLabel_3.TextTransparency = 0.5
                                                
                                                TextLabel_4.Parent = buttons_3
                                                TextLabel_4.BackgroundColor3 = Color3.new(1, 1, 1)
                                                TextLabel_4.BackgroundTransparency = 1
                                                TextLabel_4.Position = UDim2.new(0, 0, 0, 60)
                                                TextLabel_4.Size = UDim2.new(0.5, 0, 0, 20)
                                                TextLabel_4.Font = Enum.Font.SourceSansBold
                                                TextLabel_4.Text = "Chams Length"
                                                TextLabel_4.TextColor3 = Color3.new(1, 1, 1)
                                                TextLabel_4.TextSize = 16
                                                TextLabel_4.TextTransparency = 0.5
                                                
                                                TextLabel_5.Parent = buttons_3
                                                TextLabel_5.BackgroundColor3 = Color3.new(1, 1, 1)
                                                TextLabel_5.BackgroundTransparency = 1
                                                TextLabel_5.Position = UDim2.new(0, 0, 0, 90)
                                                TextLabel_5.Size = UDim2.new(0.5, 0, 0, 20)
                                                TextLabel_5.Font = Enum.Font.SourceSansBold
                                                TextLabel_5.Text = "Tracers Under Chars"
                                                TextLabel_5.TextColor3 = Color3.new(1, 1, 1)
                                                TextLabel_5.TextSize = 16
                                                TextLabel_5.TextTransparency = 0.5
                                                
                                                TextLabel_6.Parent = buttons_3
                                                TextLabel_6.BackgroundColor3 = Color3.new(1, 1, 1)
                                                TextLabel_6.BackgroundTransparency = 1
                                                TextLabel_6.Position = UDim2.new(0, 0, 0, 270)
                                                TextLabel_6.Size = UDim2.new(0.5, 0, 0, 20)
                                                TextLabel_6.Font = Enum.Font.SourceSansBold
                                                TextLabel_6.Text = "Crosshair Color"
                                                TextLabel_6.TextColor3 = Color3.new(1, 1, 1)
                                                TextLabel_6.TextSize = 16
                                                TextLabel_6.TextTransparency = 0.5
                                                
                                                TextLabel_7.Parent = buttons_3
                                                TextLabel_7.BackgroundColor3 = Color3.new(1, 1, 1)
                                                TextLabel_7.BackgroundTransparency = 1
                                                TextLabel_7.Position = UDim2.new(0, 0, 0, 120)
                                                TextLabel_7.Size = UDim2.new(0.5, 0, 0, 20)
                                                TextLabel_7.Font = Enum.Font.SourceSansBold
                                                TextLabel_7.Text = "Free For All"
                                                TextLabel_7.TextColor3 = Color3.new(1, 1, 1)
                                                TextLabel_7.TextSize = 16
                                                TextLabel_7.TextTransparency = 0.5
                                                
                                                TextLabel_8.Parent = buttons_3
                                                TextLabel_8.BackgroundColor3 = Color3.new(1, 1, 1)
                                                TextLabel_8.BackgroundTransparency = 1
                                                TextLabel_8.Position = UDim2.new(0, 0, 0, 240)
                                                TextLabel_8.Size = UDim2.new(0.5, 0, 0, 20)
                                                TextLabel_8.Font = Enum.Font.SourceSansBold
                                                TextLabel_8.Text = "Neutral Color"
                                                TextLabel_8.TextColor3 = Color3.new(1, 1, 1)
                                                TextLabel_8.TextSize = 16
                                                TextLabel_8.TextTransparency = 0.5
                                                
                                                TextLabel_9.Parent = buttons_3
                                                TextLabel_9.BackgroundColor3 = Color3.new(1, 1, 1)
                                                TextLabel_9.BackgroundTransparency = 1
                                                TextLabel_9.Position = UDim2.new(0, 0, 0, 150)
                                                TextLabel_9.Size = UDim2.new(0.5, 0, 0, 20)
                                                TextLabel_9.Font = Enum.Font.SourceSansBold
                                                TextLabel_9.Text = "Enemy Color"
                                                TextLabel_9.TextColor3 = Color3.new(1, 1, 1)
                                                TextLabel_9.TextSize = 16
                                                TextLabel_9.TextTransparency = 0.5
                                                
                                                TextLabel_10.Parent = buttons_3
                                                TextLabel_10.BackgroundColor3 = Color3.new(1, 1, 1)
                                                TextLabel_10.BackgroundTransparency = 1
                                                TextLabel_10.Position = UDim2.new(0, 0, 0, 180)
                                                TextLabel_10.Size = UDim2.new(0.5, 0, 0, 20)
                                                TextLabel_10.Font = Enum.Font.SourceSansBold
                                                TextLabel_10.Text = "Ally Color"
                                                TextLabel_10.TextColor3 = Color3.new(1, 1, 1)
                                                TextLabel_10.TextSize = 16
                                                TextLabel_10.TextTransparency = 0.5
                                                
                                                TextLabel_11.Parent = buttons_3
                                                TextLabel_11.BackgroundColor3 = Color3.new(1, 1, 1)
                                                TextLabel_11.BackgroundTransparency = 1
                                                TextLabel_11.Position = UDim2.new(0, 0, 0, 210)
                                                TextLabel_11.Size = UDim2.new(0.5, 0, 0, 20)
                                                TextLabel_11.Font = Enum.Font.SourceSansBold
                                                TextLabel_11.Text = "Friend Color"
                                                TextLabel_11.TextColor3 = Color3.new(1, 1, 1)
                                                TextLabel_11.TextSize = 16
                                                TextLabel_11.TextTransparency = 0.5

                                                TextLabel_12.Parent = buttons_3
                                                TextLabel_12.BackgroundColor3 = Color3.new(1, 1, 1)
                                                TextLabel_12.BackgroundTransparency = 1
                                                TextLabel_12.Position = UDim2.new(0, 0, 0, 300)
                                                TextLabel_12.Size = UDim2.new(0.5, 0, 0, 20)
                                                TextLabel_12.Font = Enum.Font.SourceSansBold
                                                TextLabel_12.Text = "Aimlock Auto Fire"
                                                TextLabel_12.TextColor3 = Color3.new(1, 1, 1)
                                                TextLabel_12.TextSize = 16
                                                TextLabel_12.TextTransparency = 0.5

                                                TextLabel_13.Parent = buttons_3
                                                TextLabel_13.BackgroundColor3 = Color3.new(1, 1, 1)
                                                TextLabel_13.BackgroundTransparency = 1
                                                TextLabel_13.Position = UDim2.new(0, 0, 0, 330)
                                                TextLabel_13.Size = UDim2.new(0.5, 0, 0, 20)
                                                TextLabel_13.Font = Enum.Font.SourceSansBold
                                                TextLabel_13.Text = "Aimbot Key"
                                                TextLabel_13.TextColor3 = Color3.new(1, 1, 1)
                                                TextLabel_13.TextSize = 16
                                                TextLabel_13.TextTransparency = 0.5

                                                TextLabel_14.Parent = buttons_3
                                                TextLabel_14.BackgroundColor3 = Color3.new(1, 1, 1)
                                                TextLabel_14.BackgroundTransparency = 1
                                                TextLabel_14.Position = UDim2.new(0, 0, 0, 360)
                                                TextLabel_14.Size = UDim2.new(0.5, 0, 0, 20)
                                                TextLabel_14.Font = Enum.Font.SourceSansBold
                                                TextLabel_14.Text = "Mob ESP"
                                                TextLabel_14.TextColor3 = Color3.new(1, 1, 1)
                                                TextLabel_14.TextSize = 16
                                                TextLabel_14.TextTransparency = 0.5

                                                TextLabel_15.Parent = buttons_3
                                                TextLabel_15.BackgroundColor3 = Color3.new(1, 1, 1)
                                                TextLabel_15.BackgroundTransparency = 1
                                                TextLabel_15.Position = UDim2.new(0, 0, 0, 390)
                                                TextLabel_15.Size = UDim2.new(0.5, 0, 0, 20)
                                                TextLabel_15.Font = Enum.Font.SourceSansBold
                                                TextLabel_15.Text = "Mob CHAMS"
                                                TextLabel_15.TextColor3 = Color3.new(1, 1, 1)
                                                TextLabel_15.TextSize = 16
                                                TextLabel_15.TextTransparency = 0.5
                                                
                                                SaveSettings.Name = "SaveSettings"
                                                SaveSettings.Parent = buttons_3
                                                SaveSettings.BackgroundColor3 = Color3.new(0.972549, 0.972549, 0.972549)
                                                SaveSettings.BackgroundTransparency = 0.5
                                                SaveSettings.BorderSizePixel = 0
                                                SaveSettings.Position = UDim2.new(0, 0, 0, 420)
                                                SaveSettings.Size = UDim2.new(1, -15, 0, 20)
                                                SaveSettings.Font = Enum.Font.SourceSansBold
                                                SaveSettings.Text = "Save Settings"
                                                SaveSettings.TextSize = 14
                                                SaveSettings.TextWrapped = true

                                                function CreatePlayerLabel(Str, frame)
                                                    local n = #frame:GetChildren()
                                                    local playername = Instance.new("TextLabel")
                                                    playername.Name = Str
                                                    playername.Parent = frame
                                                    playername.BackgroundColor3 = Color3.new(1, 1, 1)
                                                    playername.BackgroundTransparency = 1
                                                    playername.BorderSizePixel = 0
                                                    playername.Position = UDim2.new(0, 5, 0, (n * 15))
                                                    playername.Size = UDim2.new(1, -25, 0, 15)
                                                    playername.Font = Enum.Font.SourceSans
                                                    playername.Text = Str
                                                    playername.TextColor3 = Color3.new(1, 1, 1)
                                                    playername.TextSize = 16
                                                    playername.TextXAlignment = Enum.TextXAlignment.Left
                                                end

                                                function RefreshPlayerLabels(frame, t)
                                                    frame:ClearAllChildren()
                                                    for i, v in next, t do
                                                        CreatePlayerLabel(i, frame)
                                                    end
                                                end

                                                RefreshPlayerLabels(players, Bullshit.Blacklist)
                                                RefreshPlayerLabels(players2, Bullshit.FriendList)
                                                
                                                ESPToggle.MouseButton1Click:connect(function()
                                                    Bullshit.ESPEnabled = not Bullshit.ESPEnabled
                                                    if Bullshit.ESPEnabled then
                                                        ESPToggle.BackgroundColor3 = Color3.new(0/255,171/255,11/255)
                                                        for _, v in next, Plrs:GetPlayers() do
                                                            if v ~= MyPlr then
                                                                if Bullshit.CharAddedEvent[v.Name] == nil then
                                                                    Bullshit.CharAddedEvent[v.Name] = v.CharacterAdded:connect(function(Char)
                                                                        if Bullshit.ESPEnabled then
                                                                            RemoveESP(v)
                                                                            CreateESP(v)
                                                                        end
                                                                        if Bullshit.CHAMSEnabled then
                                                                            RemoveChams(v)
                                                                            CreateChams(v)
                                                                        end
                                                                        if Bullshit.TracersEnabled then
                                                                            RemoveTracers(v)
                                                                            CreateTracers(v)
                                                                        end
                                                                        repeat wait() until Char:FindFirstChild("HumanoidRootPart")
                                                                        TracerMT[v.Name] = Char.HumanoidRootPart
                                                                    end)
                                                                end
                                                                RemoveESP(v)
                                                                CreateESP(v)
                                                            end
                                                        end
                                                        CreateMobESPChams()
                                                    else
                                                        ESPToggle.BackgroundColor3 = Color3.new(1, 1, 1)
                                                        PlayerESP:ClearAllChildren()
                                                        ItemESP:ClearAllChildren()
                                                    end
                                                end)
                                                
                                                ChamsToggle.MouseButton1Click:connect(function()
                                                    Bullshit.CHAMSEnabled = not Bullshit.CHAMSEnabled
                                                    if Bullshit.CHAMSEnabled then
                                                        ChamsToggle.BackgroundColor3 = Color3.new(0/255,171/255,11/255)
                                                        for _, v in next, Plrs:GetPlayers() do
                                                            if v ~= MyPlr then
                                                                if Bullshit.CharAddedEvent[v.Name] == nil then
                                                                    Bullshit.CharAddedEvent[v.Name] = v.CharacterAdded:connect(function(Char)
                                                                        if Bullshit.ESPEnabled then
                                                                            RemoveESP(v)
                                                                            CreateESP(v)
                                                                        end
                                                                        if Bullshit.CHAMSEnabled then
                                                                            RemoveChams(v)
                                                                            CreateChams(v)
                                                                        end
                                                                        if Bullshit.TracersEnabled then
                                                                            RemoveTracers(v)
                                                                            CreateTracers(v)
                                                                        end
                                                                        repeat wait() until Char:FindFirstChild("HumanoidRootPart")
                                                                        TracerMT[v.Name] = Char.HumanoidRootPart
                                                                    end)
                                                                end
                                                                RemoveChams(v)
                                                                CreateChams(v)
                                                            end
                                                        end
                                                        CreateMobESPChams()
                                                    else
                                                        ChamsToggle.BackgroundColor3 = Color3.new(1, 1, 1)
                                                        PlayerChams:ClearAllChildren()
                                                        ItemChams:ClearAllChildren()
                                                    end
                                                end)
                                                
                                                TracersToggle.MouseButton1Click:connect(function()
                                                    Bullshit.TracersEnabled = not Bullshit.TracersEnabled
                                                    if Bullshit.TracersEnabled then
                                                        TracersToggle.BackgroundColor3 = Color3.new(0/255,171/255,11/255)
                                                        for _, v in next, Plrs:GetPlayers() do
                                                            if v ~= MyPlr then
                                                                if Bullshit.CharAddedEvent[v.Name] == nil then
                                                                    Bullshit.CharAddedEvent[v.Name] = v.CharacterAdded:connect(function(Char)
                                                                        if Bullshit.ESPEnabled then
                                                                            RemoveESP(v)
                                                                            CreateESP(v)
                                                                        end
                                                                        if Bullshit.CHAMSEnabled then
                                                                            RemoveChams(v)
                                                                            CreateChams(v)
                                                                        end
                                                                        if Bullshit.TracersEnabled then
                                                                            RemoveTracers(v)
                                                                            CreateTracers(v)
                                                                        end
                                                                    end)
                                                                end
                                                                if v.Character ~= nil then
                                                                    local Tor = v.Character:FindFirstChild("HumanoidRootPart")
                                                                    if Tor then
                                                                        TracerMT[v.Name] = Tor
                                                                    end
                                                                end
                                                                RemoveTracers(v)
                                                                CreateTracers(v)
                                                            end
                                                        end
                                                    else
                                                        TracersToggle.BackgroundColor3 = Color3.new(1, 1, 1)
                                                        for _, v in next, Plrs:GetPlayers() do
                                                            RemoveTracers(v)
                                                        end
                                                    end
                                                end)

                                                DebugToggle.MouseButton1Click:connect(function()
                                                    Bullshit.DebugInfo = not Bullshit.DebugInfo
                                                    DebugMenu["Main"].Visible = Bullshit.DebugInfo
                                                    if Bullshit.DebugInfo then
                                                        DebugToggle.BackgroundColor3 = Color3.new(0/255,171/255,11/255)
                                                    else
                                                        DebugToggle.BackgroundColor3 = Color3.new(1, 1, 1)
                                                    end
                                                end)

                                                OutlineToggle.MouseButton1Click:connect(function()
                                                    Bullshit.OutlinesEnabled = not Bullshit.OutlinesEnabled
                                                    if Bullshit.OutlinesEnabled then
                                                        OutlineToggle.BackgroundColor3 = Color3.new(0/255,171/255,11/255)
                                                        for _, v in next, workspace:GetDescendants() do
                                                            if v:IsA("BasePart") and not Plrs:GetPlayerFromCharacter(v.Parent) and not v.Parent:IsA("Hat") and not v.Parent:IsA("Accessory") and v.Parent.Name ~= "Tracers" then
                                                                local Data = { }
                                                                Data[2] = v.Transparency
                                                                v.Transparency = 1
                                                                local outline = Instance.new("SelectionBox")
                                                                outline.Name = "Outline"
                                                                outline.Color3 = Color3.new(0, 0, 0)
                                                                outline.SurfaceColor3 = Color3.new(0, 1, 0)
                                                                --outline.SurfaceTransparency = 0.9
                                                                outline.LineThickness = 0.01
                                                                outline.Transparency = 0.3
                                                                outline.Adornee = v
                                                                outline.Parent = v
                                                                Data[1] = outline
                                                                rawset(Bullshit.OutlinedParts, v, Data)
                                                            end
                                                            CreateChildAddedEventFor(v)
                                                        end
                                                        CreateChildAddedEventFor(workspace)
                                                        if Bullshit.LightingEvent == nil then
                                                            Bullshit.LightingEvent = game:GetService("Lighting").Changed:connect(LightingHax)
                                                        end
                                                    else
                                                        OutlineToggle.BackgroundColor3 = Color3.new(1, 1, 1)
                                                        for i, v in next, Bullshit.OutlinedParts do
                                                            i.Transparency = v[2]
                                                            v[1]:Destroy()
                                                        end
                                                    end
                                                end)

                                                FullbrightToggle.MouseButton1Click:connect(function()
                                                    Bullshit.FullbrightEnabled = not Bullshit.FullbrightEnabled
                                                    if Bullshit.FullbrightEnabled then
                                                        FullbrightToggle.BackgroundColor3 = Color3.new(0/255,171/255,11/255)
                                                        if Bullshit.LightingEvent == nil then
                                                            Bullshit.LightingEvent = Light.Changed:connect(LightingHax)
                                                        end
                                                    else
                                                        FullbrightToggle.BackgroundColor3 = Color3.new(1, 1, 1)
                                                        Light.Ambient = Bullshit.AmbientBackup
                                                        Light.ColorShift_Bottom = Bullshit.ColorShiftBotBackup
                                                        Light.ColorShift_Top = Bullshit.ColorShiftTopBackup
                                                    end
                                                end)

                                                Crosshair.MouseButton1Click:connect(function()
                                                    Bullshit.CrosshairEnabled = not Bullshit.CrosshairEnabled
                                                    if Bullshit.CrosshairEnabled then
                                                        local g = Instance.new("ScreenGui", CoreGui)
                                                        g.Name = "Corsshair"
                                                        local line1 = Instance.new("TextLabel", g)
                                                        line1.Text = ""
                                                        line1.Size = UDim2.new(0, 35, 0, 1)
                                                        line1.BackgroundColor3 = Bullshit.Colors.Crosshair
                                                        line1.BorderSizePixel = 0
                                                        line1.ZIndex = 10
                                                        local line2 = Instance.new("TextLabel", g)
                                                        line2.Text = ""
                                                        line2.Size = UDim2.new(0, 1, 0, 35)
                                                        line2.BackgroundColor3 = Bullshit.Colors.Crosshair
                                                        line2.BorderSizePixel = 0
                                                        line2.ZIndex = 10

                                                        local viewport = MyCam.ViewportSize
                                                        local centerx = viewport.X / 2
                                                        local centery = viewport.Y / 2

                                                        line1.Position = UDim2.new(0, centerx - (35 / 2), 0, centery - 35)
                                                        line2.Position = UDim2.new(0, centerx, 0, centery - (35 / 2) - 35)

                                                        Crosshair.BackgroundColor3 = Color3.new(0/255,171/255,11/255)
                                                    else
                                                        local find = CoreGui:FindFirstChild("Corsshair")
                                                        if find then
                                                            find:Destroy()
                                                        end

                                                        Crosshairs.BackgroundColor3 = Color3.new(1, 1, 1)
                                                    end
                                                end)

                                                AimbotToggle.MouseButton1Click:connect(function()
                                                    if not (game.PlaceId == 292439477 or game.PlaceId == 606849621) then
                                                        Bullshit.AimbotEnabled = not Bullshit.AimbotEnabled
                                                        if Bullshit.AimbotEnabled then
                                                            AimbotToggle.BackgroundColor3 = Color3.new(0/255,171/255,11/255)
                                                        else
                                                            AimbotToggle.BackgroundColor3 = Color3.new(1, 1, 1)
                                                        end
                                                    else
                                                        local hint = Instance.new("Hint", CoreGui)
                                                        hint.Text = "This game prevents camera manipulation!"
                                                        wait(5)
                                                        hint:Destroy()
                                                    end
                                                end)

                                                TracersUnderChars.MouseButton1Click:connect(function()
                                                    Bullshit.PlaceTracersUnderCharacter = not Bullshit.PlaceTracersUnderCharacter
                                                    if Bullshit.PlaceTracersUnderCharacter then
                                                        TracersUnderChars.Text = "true"
                                                    else
                                                        TracersUnderChars.Text = "false"
                                                    end
                                                end)

                                                FreeForAll.MouseButton1Click:connect(function()
                                                    Bullshit.FreeForAll = not Bullshit.FreeForAll
                                                    if Bullshit.FreeForAll then
                                                        FreeForAll.Text = "true"
                                                    else
                                                        FreeForAll.Text = "false"
                                                    end
                                                end)

                                                ESPLength.FocusLost:connect(function()
                                                    local txt = ESPLength.Text
                                                    local num = tonumber(txt) or 10000
                                                    if num ~= nil then
                                                        if num < 100 then
                                                            num = 100
                                                            ESPLength.Text = num
                                                        elseif num > 10000 then
                                                            num = 10000
                                                            ESPLength.Text = num
                                                        end
                                                    end

                                                    Bullshit.ESPLength = num
                                                    ESPLength.Text = num
                                                end)

                                                CHAMSLength.FocusLost:connect(function()
                                                    local txt = CHAMSLength.Text
                                                    local num = tonumber(txt) or 500
                                                    if num ~= nil then
                                                        if num < 100 then
                                                            num = 100
                                                            CHAMSLength.Text = num
                                                        elseif num > 2048 then
                                                            num = 2048
                                                            CHAMSLength.Text = num
                                                        end
                                                    end

                                                    Bullshit.CHAMSLength = num
                                                    CHAMSLength.Text = num
                                                end)

                                                TracersLength.FocusLost:connect(function()
                                                    local txt = TracersLength.Text
                                                    local num = tonumber(txt) or 500
                                                    if num ~= nil then
                                                        if num < 100 then
                                                            num = 100
                                                            TracersLength.Text = num
                                                        elseif num > 2048 then
                                                            num = 2048
                                                            TracersLength.Text = num
                                                        end
                                                    end

                                                    Bullshit.TracersLength = num
                                                    TracersLength.Text = num
                                                end)

                                                EnemyColor.FocusLost:connect(function()
                                                    local R, G, B = string.match(RemoveSpacesFromString(EnemyColor.Text), "(%d+),(%d+),(%d+)")
                                                    R = tonumber(R)
                                                    G = tonumber(G)
                                                    B = tonumber(B)
                                                    if R > 1 then
                                                        R = R / 255
                                                    end
                                                    if G > 1 then
                                                        G = G / 255
                                                    end
                                                    if B > 1 then
                                                        B = B / 255
                                                    end

                                                    if R ~= nil and G ~= nil and B ~= nil then
                                                        if not (R > 1 and G > 1 and B > 1) and not (R < 0 and G < 0 and B < 0) then
                                                            Bullshit.Colors.Enemy = Color3.new(R, G, B)
                                                            EnemyColor.Text = tostring(Bullshit.Colors.Enemy)
                                                        else
                                                            EnemyColor.Text = tostring(Bullshit.Colors.Enemy)
                                                        end
                                                    else
                                                        EnemyColor.Text = tostring(Bullshit.Colors.Enemy)
                                                    end
                                                end)

                                                AllyColor.FocusLost:connect(function()
                                                    local R, G, B = string.match(RemoveSpacesFromString(AllyColor.Text), "(%d+),(%d+),(%d+)")
                                                    R = tonumber(R)
                                                    G = tonumber(G)
                                                    B = tonumber(B)
                                                    if R > 1 then
                                                        R = R / 255
                                                    end
                                                    if G > 1 then
                                                        G = G / 255
                                                    end
                                                    if B > 1 then
                                                        B = B / 255
                                                    end

                                                    if R ~= nil and G ~= nil and B ~= nil then
                                                        if not (R > 1 and G > 1 and B > 1) and not (R < 0 and G < 0 and B < 0) then
                                                            Bullshit.Colors.Ally = Color3.new(R, G, B)
                                                            AllyColor.Text = tostring(Bullshit.Colors.Ally)
                                                        else
                                                            AllyColor.Text = tostring(Bullshit.Colors.Ally)
                                                        end
                                                    else
                                                        AllyColor.Text = tostring(Bullshit.Colors.Ally)
                                                    end
                                                end)

                                                FriendColor.FocusLost:connect(function()
                                                    local R, G, B = string.match(RemoveSpacesFromString(FriendColor.Text), "(%d+),(%d+),(%d+)")
                                                    R = tonumber(R)
                                                    G = tonumber(G)
                                                    B = tonumber(B)
                                                    if R > 1 then
                                                        R = R / 255
                                                    end
                                                    if G > 1 then
                                                        G = G / 255
                                                    end
                                                    if B > 1 then
                                                        B = B / 255
                                                    end

                                                    if R ~= nil and G ~= nil and B ~= nil then
                                                        if not (R > 1 and G > 1 and B > 1) and not (R < 0 and G < 0 and B < 0) then
                                                            Bullshit.Colors.Ally = Color3.new(R, G, B)
                                                            FriendColor.Text = tostring(Bullshit.Colors.Friend)
                                                        else
                                                            FriendColor.Text = tostring(Bullshit.Colors.Friend)
                                                        end
                                                    else
                                                        FriendColor.Text = tostring(Bullshit.Colors.Friend)
                                                    end
                                                end)

                                                NeutralColor.FocusLost:connect(function()
                                                    local R, G, B = string.match(RemoveSpacesFromString(NeutralColor.Text), "(%d+),(%d+),(%d+)")
                                                    R = tonumber(R)
                                                    G = tonumber(G)
                                                    B = tonumber(B)
                                                    if R > 1 then
                                                        R = R / 255
                                                    end
                                                    if G > 1 then
                                                        G = G / 255
                                                    end
                                                    if B > 1 then
                                                        B = B / 255
                                                    end

                                                    if R ~= nil and G ~= nil and B ~= nil then
                                                        if not (R > 1 and G > 1 and B > 1) and not (R < 0 and G < 0 and B < 0) then
                                                            Bullshit.Colors.Ally = Color3.new(R, G, B)
                                                            NeutralColor.Text = tostring(Bullshit.Colors.Neutral)
                                                        else
                                                            NeutralColor.Text = tostring(Bullshit.Colors.Neutral)
                                                        end
                                                    else
                                                        NeutralColor.Text = tostring(Bullshit.Colors.Neutral)
                                                    end
                                                end)

                                                CrosshairColor.FocusLost:connect(function()
                                                    local R, G, B = string.match(RemoveSpacesFromString(CrosshairColor.Text), "(%d+),(%d+),(%d+)")
                                                    R = tonumber(R)
                                                    G = tonumber(G)
                                                    B = tonumber(B)
                                                    if R > 1 then
                                                        R = R / 255
                                                    end
                                                    if G > 1 then
                                                        G = G / 255
                                                    end
                                                    if B > 1 then
                                                        B = B / 255
                                                    end

                                                    if R ~= nil and G ~= nil and B ~= nil then
                                                        if not (R > 1 and G > 1 and B > 1) and not (R < 0 and G < 0 and B < 0) then
                                                            Bullshit.Colors.Ally = Color3.new(R, G, B)
                                                            EnemyColor.Text = tostring(Bullshit.Colors.Crosshair)
                                                        else
                                                            EnemyColor.Text = tostring(Bullshit.Colors.Crosshair)
                                                        end
                                                    else
                                                        EnemyColor.Text = tostring(Bullshit.Colors.Crosshair)
                                                    end
                                                end)

                                                AutoFireToggle.MouseButton1Click:connect(function()
                                                    local hint = Instance.new("Hint", CoreGui)
                                                    hint.Text = "Currently broken. :("
                                                    wait(3)
                                                    hint:Destroy()
                                                    --Bullshit.AutoFire = not Bullshit.AutoFire
                                                    --AutoFireToggle.Text = tostring(Bullshit.AutoFire)
                                                end)

                                                AimbotKey.MouseButton1Click:connect(function()
                                                    AimbotKey.Text = "Press any Key now."
                                                    local input = UserInput.InputBegan:wait()
                                                    if input.UserInputType == Enum.UserInputType.Keyboard then
                                                        Bullshit.AimbotKey = tostring(input.KeyCode)
                                                        AimbotKey.Text = string.sub(tostring(input.KeyCode), 14)
                                                    else
                                                        Bullshit.AimbotKey = tostring(input.UserInputType)
                                                        AimbotKey.Text = string.sub(tostring(input.UserInputType), 20)
                                                    end
                                                end)

                                                MobESPButton.MouseButton1Click:connect(function()
                                                    Bullshit.MobESP = not Bullshit.MobESP
                                                    MobESPButton.Text = tostring(Bullshit.MobESP)
                                                    if Bullshit.MobESP then
                                                        local hint = Instance.new("Hint", CoreGui)
                                                        hint.Text = "Turn ESP/Chams off and on again to see mob ESP."
                                                        wait(5)
                                                        hint.Text = "This is still in beta, expect problems! Message Racist Dolphin#5199 on discord if you encounter a bug!"
                                                        wait(10)
                                                        hint:Destroy()
                                                    end
                                                end)

                                                MobChamsButton.MouseButton1Click:connect(function()
                                                    Bullshit.MobChams = not Bullshit.MobChams
                                                    MobChamsButton.Text = tostring(Bullshit.MobChams)
                                                    if Bullshit.MobChams then
                                                        local hint = Instance.new("Hint", CoreGui)
                                                        hint.Text = "Turn ESP/Chams off and on again to see mob chams."
                                                        wait(5)
                                                        hint.Text = "This is still in beta, expect problems! Message Racist Dolphin#5199 on discord if you encounter a bug!"
                                                        wait(10)
                                                        hint:Destroy()
                                                    end
                                                end)

                                                Playername.FocusLost:connect(function()
                                                    local FindPlr = FindPlayer(Playername.Text)
                                                    if FindPlr then
                                                        Playername.Text = FindPlr.Name
                                                    elseif not Bullshit.Blacklist[Playername.Text] then
                                                        Playername.Text = "Player not Found!"
                                                        wait(1)
                                                        Playername.Text = "Enter Player Name"
                                                    end
                                                end)

                                                AddToBlacklist.MouseButton1Click:connect(function()
                                                    local FindPlr = FindPlayer(Playername.Text)
                                                    if FindPlr then
                                                        if not Bullshit.Blacklist[FindPlr.Name] then
                                                            Bullshit.Blacklist[FindPlr.Name] = true
                                                            UpdateChams(FindPlr)
                                                            CreatePlayerLabel(FindPlr.Name, players)
                                                        end
                                                    end
                                                end)

                                                RemoveToBlacklist.MouseButton1Click:connect(function()
                                                    local FindPlr = FindPlayer(Playername.Text)
                                                    if FindPlr then
                                                        if Bullshit.Blacklist[FindPlr.Name] then
                                                            Bullshit.Blacklist[FindPlr.Name] = nil
                                                            UpdateChams(FindPlr)
                                                            RefreshPlayerLabels(players, Bullshit.Blacklist)
                                                        end
                                                    else
                                                        if Bullshit.Blacklist[Playername.Text] then
                                                            Bullshit.Blacklist[Playername.Text] = nil
                                                            RefreshPlayerLabels(players, Bullshit.Blacklist)
                                                        end
                                                    end
                                                end)

                                                Playername2.FocusLost:connect(function()
                                                    local FindPlr = FindPlayer(Playername2.Text)
                                                    if FindPlr then
                                                        Playername2.Text = FindPlr.Name
                                                    elseif not Bullshit.FriendList[Playername2.Text] then
                                                        Playername2.Text = "Player not Found!"
                                                        wait(1)
                                                        Playername2.Text = "Enter Player Name"
                                                    end
                                                end)

                                                AddToWhitelist.MouseButton1Click:connect(function()
                                                    local FindPlr = FindPlayer(Playername2.Text)
                                                    if FindPlr then
                                                        if not Bullshit.FriendList[FindPlr.Name] then
                                                            Bullshit.FriendList[FindPlr.Name] = true
                                                            UpdateChams(FindPlr)
                                                            CreatePlayerLabel(FindPlr.Name, players2)
                                                        end
                                                    end
                                                end)

                                                RemoveToWhitelist.MouseButton1Click:connect(function()
                                                    local FindPlr = FindPlayer(Playername2.Text)
                                                    if FindPlr then
                                                        if Bullshit.FriendList[FindPlr.Name] then
                                                            Bullshit.FriendList[FindPlr.Name] = nil
                                                            UpdateChams(FindPlr)
                                                            RefreshPlayerLabels(players2, Bullshit.FriendList)
                                                        end
                                                    else
                                                        if Bullshit.FriendList[Playername2.Text] then
                                                            Bullshit.FriendList[Playername2.Text] = nil
                                                            RefreshPlayerLabels(players2, Bullshit.FriendList)
                                                        end
                                                    end
                                                end)

                                                SaveWhitelist.MouseButton1Click:connect(function()
                                                    pcall(function()
                                                        writefile("Whitelist.txt", HTTP:JSONEncode(Bullshit.FriendList))
                                                    end)
                                                    SaveWhitelist.Text = "Saved!"
                                                    wait(1)
                                                    SaveWhitelist.Text = "Save Friends List"
                                                end)

                                                SaveBlacklist.MouseButton1Click:connect(function()
                                                    pcall(function()
                                                        writefile("Blacklist.txt", HTTP:JSONEncode(Bullshit.Blacklist))
                                                    end)
                                                    SaveBlacklist.Text = "Saved!"
                                                    wait(1)
                                                    SaveBlacklist.Text = "Save Blacklist"
                                                end)

                                                Settings.MouseButton1Click:connect(function()
                                                    Settings_2.Visible = not Settings_2.Visible
                                                    Information_2.Visible = false
                                                    Blacklist.Visible = false
                                                    Whitelist.Visible = false
                                                    if Settings_2.Visible then
                                                        Settings.BackgroundColor3 = Color3.new(0/255,171/255,11/255)
                                                        Information.BackgroundColor3 = Color3.new(1, 1, 1)
                                                        BlacklistToggle.BackgroundColor3 = Color3.new(1, 1, 1)
                                                        WhitelistToggle.BackgroundColor3 = Color3.new(1, 1, 1)
                                                    else
                                                        Settings.BackgroundColor3 = Color3.new(1, 1, 1)
                                                    end
                                                end)

                                                Information.MouseButton1Click:connect(function()
                                                    Information_2.Visible = not Information_2.Visible
                                                    Settings_2.Visible = false
                                                    Blacklist.Visible = false
                                                    Whitelist.Visible = false
                                                    if Information_2.Visible then
                                                        Information.BackgroundColor3 = Color3.new(0/255,171/255,11/255)
                                                        Settings.BackgroundColor3 = Color3.new(1, 1, 1)
                                                        BlacklistToggle.BackgroundColor3 = Color3.new(1, 1, 1)
                                                        WhitelistToggle.BackgroundColor3 = Color3.new(1, 1, 1)
                                                    else
                                                        Information.BackgroundColor3 = Color3.new(1, 1, 1)
                                                    end
                                                end)

                                                BlacklistToggle.MouseButton1Click:connect(function()
                                                    Blacklist.Visible = not Blacklist.Visible
                                                    Settings_2.Visible = false
                                                    Information_2.Visible = false
                                                    Whitelist.Visible = false
                                                    if Blacklist.Visible then
                                                        BlacklistToggle.BackgroundColor3 = Color3.new(0/255,171/255,11/255)
                                                        Settings.BackgroundColor3 = Color3.new(1, 1, 1)
                                                        Information.BackgroundColor3 = Color3.new(1, 1, 1)
                                                        WhitelistToggle.BackgroundColor3 = Color3.new(1, 1, 1)
                                                    else
                                                        BlacklistToggle.BackgroundColor3 = Color3.new(1, 1, 1)
                                                    end
                                                end)

                                                WhitelistToggle.MouseButton1Click:connect(function()
                                                    Whitelist.Visible = not Whitelist.Visible
                                                    Settings_2.Visible = false
                                                    Information_2.Visible = false
                                                    Blacklist.Visible = false
                                                    if Whitelist.Visible then
                                                        WhitelistToggle.BackgroundColor3 = Color3.new(0/255,171/255,11/255)
                                                        Settings.BackgroundColor3 = Color3.new(1, 1, 1)
                                                        Information.BackgroundColor3 = Color3.new(1, 1, 1)
                                                        BlacklistToggle.BackgroundColor3 = Color3.new(1, 1, 1)
                                                    else
                                                        WhitelistToggle.BackgroundColor3 = Color3.new(1, 1, 1)
                                                    end
                                                end)

                                                SaveSettings.MouseButton1Click:connect(function()
                                                    SaveBullshitSettings()
                                                    SaveSettings.Text = "Saved!"
                                                    wait(1)
                                                    SaveSettings.Text = "Save Settings"
                                                end)

                                                UserInput.InputBegan:connect(function(input, ingui)
                                                    if not ingui then
                                                        if input.UserInputType == Enum.UserInputType.Keyboard then
                                                            if input.KeyCode == Enum.KeyCode.P then
                                                                MainFrame.Visible = not MainFrame.Visible
                                                            end
                                                        end

                                                        if tostring(input.KeyCode) == Bullshit.AimbotKey or tostring(input.UserInputType) == Bullshit.AimbotKey then
                                                            Bullshit.Aimbot = true
                                                        end
                                                    end
                                                end)

                                                UserInput.InputEnded:connect(function(input)
                                                    if tostring(input.KeyCode) == Bullshit.AimbotKey or tostring(input.UserInputType) == Bullshit.AimbotKey then
                                                        Bullshit.Aimbot = false
                                                    end
                                                end)
                                            end

                                            InitMain()

                                            Run:BindToRenderStep("UpdateESP", Enum.RenderPriority.Character.Value, function()
                                                for _, v in next, Plrs:GetPlayers() do
                                                    if v ~= MyPlr then
                                                        UpdateESP(v)
                                                    end
                                                end
                                            end)

                                            Run:BindToRenderStep("UpdateInfo", 1000, function()
                                                Bullshit.ClosestEnemy = GetClosestPlayer()
                                                MyChar = MyPlr.Character
                                                if Bullshit.DebugInfo then
                                                    local MyHead, MyTor, MyHum = MyChar:FindFirstChild("Head"), MyChar:FindFirstChild("HumanoidRootPart"), MyChar:FindFirstChild("Humanoid")

                                                    local GetChar, GetHead, GetTor, GetHum = nil, nil, nil, nil
                                                    if Bullshit.ClosestEnemy ~= nil then
                                                        GetChar = Bullshit.ClosestEnemy.Character
                                                        GetHead = GetChar:FindFirstChild("Head")
                                                        GetTor = GetChar:FindFirstChild("HumanoidRootPart")
                                                        GetHum = GetChar:FindFirstChild("Humanoid")

                                                        DebugMenu["PlayerSelected"].Text = "Closest Enemy: " .. tostring(Bullshit.ClosestEnemy)

                                                        if Bullshit.ClosestEnemy.Team ~= nil then
                                                            DebugMenu["PlayerTeam"].Text = "Team: " .. tostring(Bullshit.ClosestEnemy.Team)
                                                        else
                                                            DebugMenu["PlayerTeam"].Text = "Team: nil"
                                                        end

                                                        if GetHum then
                                                            DebugMenu["PlayerHealth"].Text = "Health: " .. string.format("%.0f", GetHum.Health)
                                                        end
                                                        if MyTor and GetTor then
                                                            local Pos = GetTor.Position
                                                            local Dist = (MyTor.Position - Pos).magnitude
                                                            DebugMenu["PlayerPosition"].Text = "Position: (X: " .. string.format("%.3f", Pos.X) .. " Y: " .. string.format("%.3f", Pos.Y) .. " Z: " .. string.format("%.3f", Pos.Z) .. ") Distance: " .. string.format("%.0f", Dist) .. " Studs"

                                                            local MyCharStuff = MyChar:GetDescendants()
                                                            local GetCharStuff = GetChar:GetDescendants()
                                                            for _, v in next, GetCharStuff do
                                                                if v ~= GetTor then
                                                                    table.insert(MyCharStuff, v)
                                                                end
                                                            end
                                                            local Ray = Ray.new(MyTor.Position, (Pos - MyTor.Position).unit * 300)
                                                            local part = workspace:FindPartOnRayWithIgnoreList(Ray, MyCharStuff)
                                                            if part == GetTor then
                                                                DebugMenu["BehindWall"].Text = "Behind Wall: false"
                                                            else
                                                                DebugMenu["BehindWall"].Text = "Behind Wall: true"
                                                            end

                                                            DebugMenu["Main"].Size = UDim2.new(0, DebugMenu["PlayerPosition"].TextBounds.X, 0, 200)
                                                        end
                                                    end

                                                    -- My Position
                                                    if MyTor then
                                                        local Pos = MyTor.Position
                                                        DebugMenu["Position"].Text = "My Position: (X: " .. string.format("%.3f", Pos.x) .. " Y: " .. string.format("%.3f", Pos.Y) .. " Z: " .. string.format("%.3f", Pos.Z) .. ")"
                                                    end

                                                    -- FPS
                                                    local fps = math.floor(.5 + (1 / (tick() - LastTick)))
                                                    local sum = 0
                                                    local ave = 0
                                                    table.insert(Bullshit.FPSAverage, fps)
                                                    for i = 1, #Bullshit.FPSAverage do
                                                        sum = sum + Bullshit.FPSAverage[i]
                                                    end
                                                    DebugMenu["FPS"].Text = "FPS: " .. tostring(fps) .. " Average: " .. string.format("%.0f", (sum / #Bullshit.FPSAverage))
                                                    if (tick() - LastTick) >= 15 then
                                                        Bullshit.FPSAverage = { }
                                                        LastTick = tick()
                                                    end
                                                    LastTick = tick()
                                                end
                                            end)

                                            Run:BindToRenderStep("Aimbot", Enum.RenderPriority.First.Value, function()
                                                ClosestEnemy = GetClosestPlayerNotBehindWall()
                                                if Bullshit.AimbotEnabled and Bullshit.Aimbot then
                                                    if ClosestEnemy ~= nil then
                                                        local GetChar = ClosestEnemy.Character
                                                        if MyChar and GetChar then
                                                            local MyCharStuff = MyChar:GetDescendants()
                                                            local MyHead = MyChar:FindFirstChild("Head")
                                                            local MyTor = MyChar:FindFirstChild("HumanoidRootPart")
                                                            local MyHum = MyChar:FindFirstChild("Humanoid")
                                                            local GetHead = GetChar:FindFirstChild("Head")
                                                            local GetTor = GetChar:FindFirstChild("HumanoidRootPart")
                                                            local GetHum = GetChar:FindFirstChild("Humanoid")
                                                            if MyHead and MyTor and MyHum and GetHead and GetTor and GetHum then
                                                                if MyHum.Health > 1 and (GetHum.Health > 1 and not GetChar:FindFirstChild("KO")) then
                                                                    MyPlr.CameraMode = Enum.CameraMode.LockFirstPerson
                                                                    MyCam.CFrame = CFrame.new(MyHead.CFrame.p, GetHead.CFrame.p)
                                                                    if Bullshit.AutoFire then
                                                                        mouse1click() -- >:(
                                                                    end
                                                                end
                                                            end
                                                        end
                                                    end
                                                else
                                                    MyPlr.CameraMode = Bullshit.CameraModeBackup
                                                end
                                            end)

                                            local succ, out = coroutine.resume(coroutine.create(function()
                                                while true do
                                                    for _, v in next, Plrs:GetPlayers() do
                                                        UpdateChams(v)
                                                        Run.RenderStepped:wait()
                                                    end
                                                end
                                            end))

                                            if not succ then
                                                error(out)
                                            end
end)

Section:NewButton("Brookhaven", "Cheating time!", function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/IceMael7/NewIceHub/main/Brookhaven"))()
end)

Section:NewButton("Coco Hub", "-", function()
    loadstring(game:HttpGet(('https://raw.githubusercontent.com/MarsQQ/CocoHub/master/CocoZHub'),true))()
end)

Section:NewButton("Dark Hub", "-", function()
    loadstring(game:HttpGet(("https://darkhub.xyz/remote-script.lua"), true))()
end)

Section:NewButton("WeAreDevs Dexplorer", "-", function()
    loadstring(game:HttpGet("https://cdn.wearedevs.net/scripts/Dex%20Explorer.txt"))()
end)

Section:NewButton("Dollhouse Roleplay", "Cheating time!", function()
    for i = 1, 1000 do
        for i = 1, 100 do
            for i = 1, 10 do
                game.ReplicatedStorage.ClaimReward:FireServer()
            end
        end
     end
end)

Section:NewButton("WeAreDevs ESP", "-", function()
    loadstring(game:HttpGet("https://cdn.wearedevs.net/scripts/WRD%20ESP.txt"))()
end)

Section:NewButton("Get Position", "-", function()
    local ScreenGui = Instance.new("ScreenGui")

    local Frame = Instance.new("Frame")
    local ImageLabel = Instance.new("ImageLabel")

    function createButton()
    local X = Instance.new("TextLabel")
    X.Parent = ImageLabel
    X.BackgroundColor3 = Color3.new(1, 1, 1)
    X.BackgroundTransparency = 1
    X.Size = UDim2.new(0.3, 0, 1, 0)
    X.Font = Enum.Font.SourceSans
    X.FontSize = Enum.FontSize.Size14
    X.TextScaled = true
    X.TextSize = 14
    X.TextStrokeColor3 = Color3.new(1, 10, 1)
    X.TextStrokeTransparency = 0
    X.TextWrapped = true
    return X
    end

    function round(val)
    return math.floor( (val * 10^2) + 0.5) / (10^2)
    end

    local X = createButton()
    local Y = createButton()
    local Z = createButton()

    ScreenGui.Parent = game.CoreGui

    Frame.Parent = ScreenGui
    Frame.BackgroundColor3 = Color3.new(1, 1, 1)
    Frame.BackgroundTransparency = 1
    Frame.Size = UDim2.new(1, 0, 1, 0)
    ImageLabel.Parent = Frame
    ImageLabel.BackgroundColor3 = Color3.new(1, 1, 1)
    ImageLabel.Size = UDim2.new(0.4, 0, 0.15, 0)
    ImageLabel.Image = "rbxassetidUndecided/401491488"
    Y.Position = UDim2.new(0.33, 0, 0, 0)
    Z.Position = UDim2.new(0.66, 0, 0, 0)

    while true do
    X.Text = round(game.Players.LocalPlayer.Character.HumanoidRootPart.Position.x)
    Y.Text = round(game.Players.LocalPlayer.Character.HumanoidRootPart.Position.y)
    Z.Text = round(game.Players.LocalPlayer.Character.HumanoidRootPart.Position.z)
    wait()
    end
end)

Section:NewButton("Stop It Slender", "Cheating time!", function()
    game:GetService("ReplicatedStorage").Remotes.ImGrabbed:FireServer()
end)

Section:NewButton("Hide And Seek [EXTREME]", "Cheating time!", function()
    local OrionLib = loadstring(game:HttpGet(('https://raw.githubusercontent.com/shlexware/Orion/main/source')))()

    local Window = OrionLib:MakeWindow({Name = "Hide and Seek [EXTREME]", HidePremium = false, SaveConfig = true, ConfigFolder = "OrionTest", IntroText = "Screepstu"})

    local Tab = Window:MakeTab({
        Name = "Cheats",
        Icon = "rbxassetid://4483345998",
        PremiumOnly = false
    })

    local Section = Tab:AddSection({
        Name = "Hider"
    })

    Tab:AddButton({
        Name = "Get All Coins",
        Callback = function()
                local me = game.Players.LocalPlayer
                local mechar = me.Character
                for i,v in pairs(game.Workspace.GameObjects:GetChildren()) do
                wait(0.5)
                mechar.HumanoidRootPart.CFrame = v.CFrame
                end
        end    
    })

    local Section = Tab:AddSection({
        Name = "Seeker"
    })

    Tab:AddButton({
        Name = "Get All Hiders And Coins",
        Callback = function()
                local me = game.Players.LocalPlayer
                local mechar = me.Character
                for i,v in pairs(game.Workspace.GameObjects:GetChildren()) do
                wait(0.25)
                mechar.HumanoidRootPart.CFrame = v.CFrame
                end
                wait(1.25)
                local players = game.Players:GetChildren()
                local me = game.Players.LocalPlayer
                local mechar = me.Character
                for i,v in pairs(players) do
                wait(0.25)
                mechar.HumanoidRootPart.CFrame = v.Character.HumanoidRootPart.CFrame
                end
        end    
    })

    local Section = Tab:AddSection({
        Name = "2 Roles Allowed"
    })

    Tab:AddButton({
        Name = "(Rejoin To Stop) Walk On Walls",
        Callback = function()
                loadstring(game:HttpGet('https://pastebin.com/raw/Hd4gexbN'))()
        end    
    })

    Tab:AddButton({
        Name = "ESP [WeAreDevs]",
        Callback = function()
                loadstring(game:HttpGet("https://cdn.wearedevs.net/scripts/WRD%20ESP.txt"))()
        end    
    })

    Tab:AddSlider({
        Name = "Speed Adjuster",
        Min = 16,
        Max = 100,
        Default = 16,
        Color = Color3.fromRGB(60,60,60),
        Increment = 1,
        ValueName = "Speed Power",
        Callback = function(Value)
            game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = Value
        end    
    })

    Tab:AddSlider({
        Name = "Jump Adjuster",
        Min = 50,
        Max = 220,
        Default = 50,
        Color = Color3.fromRGB(60,60,60),
        Increment = 1,
        ValueName = "Jump Power",
        Callback = function(Value)
            game.Players.LocalPlayer.Character.Humanoid.JumpPower = Value
        end    
    })


    Tab:AddTextbox({
        Name = "(CLIENT) Audio Trolling:",
        Default = "ID here...",
        TextDisappear = true,
        Callback = function(Value)
                local soundId = Value
                
                local properties = {
                    Pitch = 1,
                    Parent = workspace,
                    Volume = 2,
                    Looped = false,
                    PlayOnRemove = true,
                    TimePosition = math.huge
                }
                
                local localSound = Instance.new("Sound")
                local q = Instance.new("DistortionSoundEffect", localSound)
                local c = Instance.new("EqualizerSoundEffect", localSound)
                
                localSound.SoundId = "rbxassetid://"..soundId
                q.Level = .93
                c.HighGain = 1
                c.LowGain = -25
                c.MidGain = 8
                
                for i, v in pairs(properties) do
                    localSound[i] = v
                end
                
                game:GetService("ReplicatedStorage").Remotes.PlaySoundOthers:FireServer(soundId, properties)
                
                localSound:Play()
                localSound.Ended:Connect(function()
                    localSound:Destroy()
                end)
                task.wait(4)
                localSound:Destroy()
        end	  
    })

    Tab:AddButton({
        Name = "Infinite Yield",
        Callback = function()
                loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()
        end    
    })

    Tab:AddButton({
        Name = "(Very Safe) Chat Bypass",
        Callback = function()
            _G.Keybind = 'Q'
            loadstring(game:HttpGet("https://raw.githubusercontent.com/synnyyy/synergy/additional/betterbypasser",true))()
        end    
    })

    ------------------------------------------------------------------------------------------------------------------------------------------

    local Tab = Window:MakeTab({
        Name = "Credits",
        Icon = "rbxassetid://4483345998",
        PremiumOnly = false
    })

    local Section = Tab:AddSection({
        Name = "Credits"
    })

    Tab:AddLabel("Screepstu made by @creepstu.")

    Tab:AddLabel("Script Button created by @SKEPPY0_0MAN.")

    Tab:AddLabel("Original UI lib named Orion.")

    local Section = Tab:AddSection({
        Name = "FAQs"
    })

    OrionLib:MakeNotification({
        Name = "",
        Content = "Executed!",
        Image = "rbxassetid://12337168653",
        Time = 3
    })

    Tab:AddParagraph("Why the GUI named 'SCREEPSTU'?","The GUI named 'SCREEPSTU' because the creator of Screepstu (@creepstu) loves to create hack scripts and bunches of hack scripts (34K) in his file device , he also known as 'Screepstu'. S=Scripter, creepstu=His name.")

    local Section = Tab:AddSection({
        Name = "And"
    })

    Tab:AddParagraph("What is creepstu mean?","creep=Creepy, s=Slave, t=Through, u=Us.")

    local Section = Tab:AddSection({
        Name = "-The End- and BONUS SCRIPT"
    })

    Tab:AddButton({
        Name = "Old Screepstu Lib",
        Callback = function()
                loadstring(game:HttpGet('https://raw.githubusercontent.com/2trk/screepstu/main/master'))()
        end    
    })

    Tab:AddButton({
        Name = "(Free Executor Only) Dexplorer",
        Callback = function()
                loadstring(game:HttpGet("https://cdn.wearedevs.net/scripts/Dex%20Explorer.txt"))()
        end    
    })

    Tab:AddParagraph("Audio Trolling But FE","To make '(CLIENT) Audio Trolling' goes FE, copy link down below and open the link and copy then paste it into your executor.")

    Tab:AddLabel("https://pastebin.com/iTqSKGXR")

    OrionLib:Init()
end)

Section:NewButton("[2] Stop It Slender", "Cheating time!", function()
        -- Gui to Lua

    -- Version: 3.2

    

    -- Instances:

    

    local ScreenGui = Instance.new("ScreenGui")

    local Frame = Instance.new("Frame")

    local UICorner = Instance.new("UICorner")

    local Pages = Instance.new("TextLabel")

    local Generators = Instance.new("TextLabel")

    local Slender = Instance.new("TextLabel")

    

    --Properties:

    

    ScreenGui.Parent = game.CoreGui

    ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

    

    Frame.Parent = ScreenGui

    Frame.AnchorPoint = Vector2.new(0.5, 0.5)

    Frame.BackgroundColor3 = Color3.fromRGB(58, 58, 58)

    Frame.Position = UDim2.new(0.0873715281, 0, 0.5, 0)

    Frame.Selectable = true

    Frame.Active = true

    Frame.Draggable = true

    Frame.Size = UDim2.new(0.100000001, 0, 0.300000012, 0)

    

    UICorner.Parent = Frame

    

    Pages.Name = "Pages"

    Pages.Parent = Frame

    Pages.BackgroundColor3 = Color3.fromRGB(0, 0, 0)

    Pages.BorderSizePixel = 0

    Pages.Position = UDim2.new(0, 0, 0.119189508, 0)

    Pages.Size = UDim2.new(1, 0, 0.189511254, 0)

    Pages.Font = Enum.Font.SourceSans

    Pages.Text = "Show Pages (Z)"

    Pages.TextColor3 = Color3.fromRGB(255, 255, 255)

    Pages.TextScaled = true

    Pages.TextSize = 14.000

    Pages.TextWrapped = true

    

    Generators.Name = "GENERATORS"

    Generators.Parent = Frame

    Generators.BackgroundColor3 = Color3.fromRGB(0, 0, 0)

    Generators.BorderSizePixel = 0

    Generators.Position = UDim2.new(0, 0, 0.69129914, 0)

    Generators.Size = UDim2.new(1, 0, 0.189511254, 0)

    Generators.Font = Enum.Font.SourceSans

    Generators.Text = "Show Generators (X)"

    Generators.TextColor3 = Color3.fromRGB(255, 255, 255)

    Generators.TextScaled = true

    Generators.TextSize = 14.000

    Generators.TextWrapped = true

    

    Slender.Name = "Slender"

    Slender.Parent = Frame

    Slender.BackgroundColor3 = Color3.fromRGB(0, 0, 0)

    Slender.BorderSizePixel = 0

    Slender.Position = UDim2.new(0, 0, 0.40524435, 0)

    Slender.Size = UDim2.new(1, 0, 0.189511254, 0)

    Slender.Font = Enum.Font.SourceSans

    Slender.Text = "Show Slender (C)"

    Slender.TextColor3 = Color3.fromRGB(255, 255, 255)

    Slender.TextScaled = true

    Slender.TextSize = 14.000

    Slender.TextWrapped = true

    

    -- Scripts:

    

    local function TCIFN_fake_script() -- Pages.PageScript

    local script = Instance.new('LocalScript', Pages)

    

    local InS = game:GetService("UserInputService")

    

    local function createGuiPages(parent)

    if parent.Transparency == 0 then

    local BGui = Instance.new("BillboardGui")

    BGui.Parent = parent

    BGui.AlwaysOnTop = true

    BGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

    BGui.StudsOffset = Vector3.new(0, 3, 0)

    BGui.Size = UDim2.new(5, 0, 1.5, 0)

    

    local text = Instance.new("TextLabel")

    text.Parent = BGui

    text.Text = "++"

    text.TextScaled = true

    text.BackgroundTransparency = 1

    text.Size = UDim2.new(1, 0, 1, 0)

    text.TextColor3 = Color3.fromRGB(255, 255, 255)

    else

    

    end

    end

    

    

    InS.InputBegan:Connect(function(input, GPE)

    if input.KeyCode == Enum.KeyCode.Z then

    if game.Workspace.MAP.Pages ~= nil and game.Workspace.MAP.HPageSpawns ~= nil then

    

    local model1 = game.Workspace.MAP.Pages

    

    for _, v in pairs(model1:GetChildren()) do

    createGuiPages(v)

    

    v.Changed:Connect(function()

    if v.Transparency == 1 then

    

    local BGui = v.BillboardGui

    BGui:Destroy()

    end

    end)

    end

    

    local model2 = game.Workspace.MAP.HPageSpawns

    

    for _, v in pairs(model2:GetChildren()) do

    createGuiPages(v)

    

    v.Changed:Connect(function()

    if v.Transparency == 1 then

    

    local BGui = v.BillboardGui

    BGui:Destroy()

    end

    end)

    end

    end

    end

    end)

    end

    coroutine.wrap(TCIFN_fake_script)()

    local function WBNHNPG_fake_script() -- Generators.GenScript

    local script = Instance.new('LocalScript', Generators)

    

    local InS = game:GetService("UserInputService")

    

    local function createGuiGens(parent)

    local BGui = Instance.new("BillboardGui")

    BGui.Parent = parent

    BGui.AlwaysOnTop = true

    BGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

    BGui.StudsOffset = Vector3.new(0, 3, 0)

    BGui.Size = UDim2.new(5, 0, 1.5, 0)

    

    local text = Instance.new("TextLabel")

    text.Parent = BGui

    text.TextScaled = true

    text.BackgroundTransparency = 1

    text.Size = UDim2.new(1, 0, 1, 0)

    text.TextColor3 = Color3.fromRGB(0, 255, 0)

    text.Text = "-[]-"

    

    if parent:FindFirstChild("On") then

    

    if parent.On.Value == true then

    text.Text = "-[]- (Activated)"

    text.TextColor3 = Color3.fromRGB(0, 0, 255)

    end

    end

    end

    

    InS.InputBegan:Connect(function(input, GPE)

    if input.KeyCode == Enum.KeyCode.X then

    

    local model = game.Workspace.MAP.GENS

    for _, v in pairs(model:GetChildren()) do

    createGuiGens(v)

    

    if v:FindFirstChild("On") then

    local isOn = v.On

    

    isOn.Changed:Connect(function()

    v.BillboardGui.TextLabel.Text = "-[]- (Activated)"

    v.BillboardGui.TextLabel.TextColor3 = Color3.fromRGB(0, 0, 255)

    end)

    else

    

    end

    end

    

    end

    end)

    end

    coroutine.wrap(WBNHNPG_fake_script)()

    local function DXQRVQV_fake_script() -- Slender.SlenderScript

    local script = Instance.new('LocalScript', Slender)

    

    local InS = game:GetService("UserInputService")

    

    local function createGuiSlender(parent)

    local BGui = Instance.new("BillboardGui")

    BGui.Parent = parent

    BGui.AlwaysOnTop = true

    BGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

    BGui.StudsOffset = Vector3.new(0, 3, 0)

    BGui.Size = UDim2.new(5, 0, 1.5, 0)

    

    local text = Instance.new("TextLabel")

    text.Parent = BGui

    text.Text = ":{ENTITY}:"

    text.TextScaled = true

    text.BackgroundTransparency = 1

    text.Size = UDim2.new(1, 0, 1, 0)

    text.TextColor3 = Color3.fromRGB(255, 0, 0)

    end

    

    

    InS.InputBegan:Connect(function(input, GPE)

    if input.KeyCode == Enum.KeyCode.C then

    

    for _, v in pairs(game.Workspace:GetChildren()) do

    if v:FindFirstChild("SlenderProp") then

    createGuiSlender(v)

    end

    end

    end

    

    end)

    end

    coroutine.wrap(DXQRVQV_fake_script)()

    local function LSGPTFK_fake_script() -- Frame.HideShow

    local script = Instance.new('LocalScript', Frame)

    

    local frame = script.Parent

    local InS = game:GetService("UserInputService")

    

    InS.InputBegan:Connect(function(input, GPE)

    if input.KeyCode == Enum.KeyCode.LeftControl then

    if frame.Visible == true then

    frame.Visible = false

    else

    frame.Visible = true

    end

    end

    end)

    end

    coroutine.wrap(LSGPTFK_fake_script)()
end)

Section:NewButton("Tower Of Fun", "Cheating time!", function()
    local ScreenGui = Instance.new("ScreenGui")
    local Frame = Instance.new("Frame")
    local TextButton = Instance.new("TextButton")
    local TextLabel = Instance.new("TextLabel")
    local TextButton_2 = Instance.new("TextButton")
    
    ScreenGui.Parent = game.Players.LocalPlayer.PlayerGui
    ScreenGui.ResetOnSpawn = false
    ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    
    Frame.Parent = ScreenGui
    Frame.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    Frame.BorderColor3 = Color3.fromRGB(0, 0, 0)
    Frame.Position = UDim2.new(0.406716406, 0, 0.896226406, 0)
    Frame.Size = UDim2.new(0, 150, 0, 55)
    
    TextButton.Parent = Frame
    TextButton.BackgroundColor3 = Color3.fromRGB(65, 65, 65)
    TextButton.BorderSizePixel = 0
    TextButton.Position = UDim2.new(0.086666666, 0, 0.181818172, 0)
    TextButton.Size = UDim2.new(0, 123, 0, 36)
    TextButton.Font = Enum.Font.Unknown
    TextButton.Text = "TELEPORT"
    TextButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    TextButton.TextSize = 14.000
    TextButton.TextStrokeTransparency = 0.700
    TextButton.TextWrapped = true
    
    TextLabel.Parent = Frame
    TextLabel.BackgroundColor3 = Color3.fromRGB(65, 65, 65)
    TextLabel.BorderColor3 = Color3.fromRGB(0, 0, 0)
    TextLabel.Position = UDim2.new(0.0469999984, 0, -0.300000012, 0)
    TextLabel.Size = UDim2.new(0, 136, 0, 15)
    TextLabel.Font = Enum.Font.GothamBold
    TextLabel.Text = "!Click once after you join!"
    TextLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
    TextLabel.TextScaled = true
    TextLabel.TextSize = 14.000
    TextLabel.TextWrapped = true
    
    TextButton_2.Parent = Frame
    TextButton_2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    TextButton_2.BackgroundTransparency = 1.000
    TextButton_2.Position = UDim2.new(1, 0, -0.309090912, 0)
    TextButton_2.Size = UDim2.new(0, 15, 0, 15)
    TextButton_2.Font = Enum.Font.GothamBold
    TextButton_2.Text = "X"
    TextButton_2.TextColor3 = Color3.fromRGB(255, 0, 0)
    TextButton_2.TextSize = 14.000
    TextButton_2.TextStrokeTransparency = 0.700
    
    local function teleportfunction()
        local script = Instance.new('LocalScript', TextButton)
    
        function Teleport(teleportPlace)
            local player = game.Players.LocalPlayer
            player.Character.HumanoidRootPart.CFrame = teleportPlace
        end
        
        script.Parent.MouseButton1Click:Connect(function()
            Teleport(game:GetService("Workspace").Stages.EndStage.Start.CFrame)
        end)
    end
    coroutine.wrap(teleportfunction)()
    local function basicbaldi()
        local script = Instance.new('LocalScript', TextLabel)
    
        while true do
            wait(1)
            script.Parent.TextColor3 = Color3.new(1, 0, 0)
            wait(1)
            script.Parent.TextColor3 = Color3.new(0, 0, 1)
            wait(1)
            script.Parent.TextColor3 = Color3.new(0, 1, 0)
        end
    end
    coroutine.wrap(basicbaldi)()
    local function catvskid()
        local script = Instance.new('LocalScript', TextButton_2)
    
        script.Parent.MouseButton1Click:Connect(function()
            script.Parent.Parent.Parent:Destroy()
        end)
    end
    coroutine.wrap(catvskid)()
    local function kidvsdog()
        local script = Instance.new('LocalScript', ScreenGui)
    
        local frame = script.Parent.Frame
        frame.Active = true
        frame.Selectable = true
        frame.Draggable = true
    end
    coroutine.wrap(kidvsdog)()
    
end)

Section:NewButton("Walk On Walls", "-", function()
    repeat wait()
        a = pcall(function()
            game:WaitForChild("Players").LocalPlayer:WaitForChild("PlayerScripts").ChildAdded:Connect(function(c)
                if c.Name == "PlayerScriptsLoader"then
                    c.Disabled = true
                end
            end)
            end)
            if a == true then break end
        until true == false
        game:WaitForChild("Players").LocalPlayer:WaitForChild("PlayerScripts").ChildAdded:Connect(function(c)
            if c.Name == "PlayerScriptsLoader"then
                c.Disabled = true
            end
        end)
        
        
        function _CameraUI()
            local Players = game:GetService("Players")
            local TweenService = game:GetService("TweenService")
            
            local LocalPlayer = Players.LocalPlayer
            if not LocalPlayer then
                Players:GetPropertyChangedSignal("LocalPlayer"):Wait()
                LocalPlayer = Players.LocalPlayer
            end
            
            local function waitForChildOfClass(parent, class)
                local child = parent:FindFirstChildOfClass(class)
                while not child or child.ClassName ~= class do
                    child = parent.ChildAdded:Wait()
                end
                return child
            end
            
            local PlayerGui = waitForChildOfClass(LocalPlayer, "PlayerGui")
            
            local TOAST_OPEN_SIZE = UDim2.new(0, 326, 0, 58)
            local TOAST_CLOSED_SIZE = UDim2.new(0, 80, 0, 58)
            local TOAST_BACKGROUND_COLOR = Color3.fromRGB(32, 32, 32)
            local TOAST_BACKGROUND_TRANS = 0.4
            local TOAST_FOREGROUND_COLOR = Color3.fromRGB(200, 200, 200)
            local TOAST_FOREGROUND_TRANS = 0
            
            -- Convenient syntax for creating a tree of instanes
            local function create(className)
                return function(props)
                    local inst = Instance.new(className)
                    local parent = props.Parent
                    props.Parent = nil
                    for name, val in pairs(props) do
                        if type(name) == "string" then
                            inst[name] = val
                        else
                            val.Parent = inst
                        end
                    end
                    -- Only set parent after all other properties are initialized
                    inst.Parent = parent
                    return inst
                end
            end
            
            local initialized = false
            
            local uiRoot
            local toast
            local toastIcon
            local toastUpperText
            local toastLowerText
            
            local function initializeUI()
                assert(not initialized)
            
                uiRoot = create("ScreenGui"){
                    Name = "RbxCameraUI",
                    AutoLocalize = false,
                    Enabled = true,
                    DisplayOrder = -1, -- Appears behind default developer UI
                    IgnoreGuiInset = false,
                    ResetOnSpawn = false,
                    ZIndexBehavior = Enum.ZIndexBehavior.Sibling,
            
                    create("ImageLabel"){
                        Name = "Toast",
                        Visible = false,
                        AnchorPoint = Vector2.new(0.5, 0),
                        BackgroundTransparency = 1,
                        BorderSizePixel = 0,
                        Position = UDim2.new(0.5, 0, 0, 8),
                        Size = TOAST_CLOSED_SIZE,
                        Image = "rbxasset://textures/ui/Camera/CameraToast9Slice.png",
                        ImageColor3 = TOAST_BACKGROUND_COLOR,
                        ImageRectSize = Vector2.new(6, 6),
                        ImageTransparency = 1,
                        ScaleType = Enum.ScaleType.Slice,
                        SliceCenter = Rect.new(3, 3, 3, 3),
                        ClipsDescendants = true,
            
                        create("Frame"){
                            Name = "IconBuffer",
                            BackgroundTransparency = 1,
                            BorderSizePixel = 0,
                            Position = UDim2.new(0, 0, 0, 0),
                            Size = UDim2.new(0, 80, 1, 0),
            
                            create("ImageLabel"){
                                Name = "Icon",
                                AnchorPoint = Vector2.new(0.5, 0.5),
                                BackgroundTransparency = 1,
                                Position = UDim2.new(0.5, 0, 0.5, 0),
                                Size = UDim2.new(0, 48, 0, 48),
                                ZIndex = 2,
                                Image = "rbxasset://textures/ui/Camera/CameraToastIcon.png",
                                ImageColor3 = TOAST_FOREGROUND_COLOR,
                                ImageTransparency = 1,
                            }
                        },
            
                        create("Frame"){
                            Name = "TextBuffer",
                            BackgroundTransparency = 1,
                            BorderSizePixel = 0,
                            Position = UDim2.new(0, 80, 0, 0),
                            Size = UDim2.new(1, -80, 1, 0),
                            ClipsDescendants = true,
            
                            create("TextLabel"){
                                Name = "Upper",
                                AnchorPoint = Vector2.new(0, 1),
                                BackgroundTransparency = 1,
                                Position = UDim2.new(0, 0, 0.5, 0),
                                Size = UDim2.new(1, 0, 0, 19),
                                Font = Enum.Font.GothamSemibold,
                                Text = "Camera control enabled",
                                TextColor3 = TOAST_FOREGROUND_COLOR,
                                TextTransparency = 1,
                                TextSize = 19,
                                TextXAlignment = Enum.TextXAlignment.Left,
                                TextYAlignment = Enum.TextYAlignment.Center,
                            },
            
                            create("TextLabel"){
                                Name = "Lower",
                                AnchorPoint = Vector2.new(0, 0),
                                BackgroundTransparency = 1,
                                Position = UDim2.new(0, 0, 0.5, 3),
                                Size = UDim2.new(1, 0, 0, 15),
                                Font = Enum.Font.Gotham,
                                Text = "Right mouse button to toggle",
                                TextColor3 = TOAST_FOREGROUND_COLOR,
                                TextTransparency = 1,
                                TextSize = 15,
                                TextXAlignment = Enum.TextXAlignment.Left,
                                TextYAlignment = Enum.TextYAlignment.Center,
                            },
                        },
                    },
            
                    Parent = PlayerGui,
                }
            
                toast = uiRoot.Toast
                toastIcon = toast.IconBuffer.Icon
                toastUpperText = toast.TextBuffer.Upper
                toastLowerText = toast.TextBuffer.Lower
            
                initialized = true
            end
            
            local CameraUI = {}
            
            do
                -- Instantaneously disable the toast or enable for opening later on. Used when switching camera modes.
                function CameraUI.setCameraModeToastEnabled(enabled)
                    if not enabled and not initialized then
                        return
                    end
            
                    if not initialized then
                        initializeUI()
                    end
            
                    toast.Visible = enabled
                    if not enabled then
                        CameraUI.setCameraModeToastOpen(false)
                    end
                end
            
                local tweenInfo = TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
            
                -- Tween the toast in or out. Toast must be enabled with setCameraModeToastEnabled.
                function CameraUI.setCameraModeToastOpen(open)
                    assert(initialized)
            
                    TweenService:Create(toast, tweenInfo, {
                        Size = open and TOAST_OPEN_SIZE or TOAST_CLOSED_SIZE,
                        ImageTransparency = open and TOAST_BACKGROUND_TRANS or 1,
                    }):Play()
            
                    TweenService:Create(toastIcon, tweenInfo, {
                        ImageTransparency = open and TOAST_FOREGROUND_TRANS or 1,
                    }):Play()
            
                    TweenService:Create(toastUpperText, tweenInfo, {
                        TextTransparency = open and TOAST_FOREGROUND_TRANS or 1,
                    }):Play()
            
                    TweenService:Create(toastLowerText, tweenInfo, {
                        TextTransparency = open and TOAST_FOREGROUND_TRANS or 1,
                    }):Play()
                end
            end
            
            return CameraUI
        end
        
        function _CameraToggleStateController()
            local Players = game:GetService("Players")
            local UserInputService = game:GetService("UserInputService")
            local GameSettings = UserSettings():GetService("UserGameSettings")
            
            local LocalPlayer = Players.LocalPlayer
            if not LocalPlayer then
                Players:GetPropertyChangedSignal("LocalPlayer"):Wait()
                LocalPlayer = Players.LocalPlayer
            end
            
            local Mouse = LocalPlayer:GetMouse()
            
            local Input = _CameraInput()
            local CameraUI = _CameraUI()
            
            local lastTogglePan = false
            local lastTogglePanChange = tick()
            
            local CROSS_MOUSE_ICON = "rbxasset://textures/Cursors/CrossMouseIcon.png"
            
            local lockStateDirty = false
            local wasTogglePanOnTheLastTimeYouWentIntoFirstPerson = false
            local lastFirstPerson = false
            
            CameraUI.setCameraModeToastEnabled(false)
            
            return function(isFirstPerson)
                local togglePan = Input.getTogglePan()
                local toastTimeout = 3
            
                if isFirstPerson and togglePan ~= lastTogglePan then
                    lockStateDirty = true
                end
            
                if lastTogglePan ~= togglePan or tick() - lastTogglePanChange > toastTimeout then
                    local doShow = togglePan and tick() - lastTogglePanChange < toastTimeout
            
                    CameraUI.setCameraModeToastOpen(doShow)
            
                    if togglePan then
                        lockStateDirty = false
                    end
                    lastTogglePanChange = tick()
                    lastTogglePan = togglePan
                end
            
                if isFirstPerson ~= lastFirstPerson then
                    if isFirstPerson then
                        wasTogglePanOnTheLastTimeYouWentIntoFirstPerson = Input.getTogglePan()
                        Input.setTogglePan(true)
                    elseif not lockStateDirty then
                        Input.setTogglePan(wasTogglePanOnTheLastTimeYouWentIntoFirstPerson)
                    end
                end
            
                if isFirstPerson then
                    if Input.getTogglePan() then
                        Mouse.Icon = CROSS_MOUSE_ICON
                        UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
                        --GameSettings.RotationType = Enum.RotationType.CameraRelative
                    else
                        Mouse.Icon = ""
                        UserInputService.MouseBehavior = Enum.MouseBehavior.Default
                        --GameSettings.RotationType = Enum.RotationType.CameraRelative
                    end
            
                elseif Input.getTogglePan() then
                    Mouse.Icon = CROSS_MOUSE_ICON
                    UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
                    GameSettings.RotationType = Enum.RotationType.MovementRelative
            
                elseif Input.getHoldPan() then
                    Mouse.Icon = ""
                    UserInputService.MouseBehavior = Enum.MouseBehavior.LockCurrentPosition
                    GameSettings.RotationType = Enum.RotationType.MovementRelative
            
                else
                    Mouse.Icon = ""
                    UserInputService.MouseBehavior = Enum.MouseBehavior.Default
                    GameSettings.RotationType = Enum.RotationType.MovementRelative
                end
            
                lastFirstPerson = isFirstPerson
            end
        end
        
        function _CameraInput()
            local UserInputService = game:GetService("UserInputService")
            
            local MB_TAP_LENGTH = 0.3 -- length of time for a short mouse button tap to be registered
            
            local rmbDown, rmbUp
            do
                local rmbDownBindable = Instance.new("BindableEvent")
                local rmbUpBindable = Instance.new("BindableEvent")
            
                rmbDown = rmbDownBindable.Event
                rmbUp = rmbUpBindable.Event
            
                UserInputService.InputBegan:Connect(function(input, gpe)
                    if not gpe and input.UserInputType == Enum.UserInputType.MouseButton2 then
                        rmbDownBindable:Fire()
                    end
                end)
            
                UserInputService.InputEnded:Connect(function(input, gpe)
                    if input.UserInputType == Enum.UserInputType.MouseButton2 then
                        rmbUpBindable:Fire()
                    end
                end)
            end
            
            local holdPan = false
            local togglePan = false
            local lastRmbDown = 0 -- tick() timestamp of the last right mouse button down event
            
            local CameraInput = {}
            
            function CameraInput.getHoldPan()
                return holdPan
            end
            
            function CameraInput.getTogglePan()
                return togglePan
            end
            
            function CameraInput.getPanning()
                return togglePan or holdPan
            end
            
            function CameraInput.setTogglePan(value)
                togglePan = value
            end
            
            local cameraToggleInputEnabled = false
            local rmbDownConnection
            local rmbUpConnection
            
            function CameraInput.enableCameraToggleInput()
                if cameraToggleInputEnabled then
                    return
                end
                cameraToggleInputEnabled = true
            
                holdPan = false
                togglePan = false
            
                if rmbDownConnection then
                    rmbDownConnection:Disconnect()
                end
            
                if rmbUpConnection then
                    rmbUpConnection:Disconnect()
                end
            
                rmbDownConnection = rmbDown:Connect(function()
                    holdPan = true
                    lastRmbDown = tick()
                end)
            
                rmbUpConnection = rmbUp:Connect(function()
                    holdPan = false
                    if tick() - lastRmbDown < MB_TAP_LENGTH and (togglePan or UserInputService:GetMouseDelta().Magnitude < 2) then
                        togglePan = not togglePan
                    end
                end)
            end
            
            function CameraInput.disableCameraToggleInput()
                if not cameraToggleInputEnabled then
                    return
                end
                cameraToggleInputEnabled = false
            
                if rmbDownConnection then
                    rmbDownConnection:Disconnect()
                    rmbDownConnection = nil
                end
                if rmbUpConnection then
                    rmbUpConnection:Disconnect()
                    rmbUpConnection = nil
                end
            end
            
            return CameraInput
        end
        
        function _BaseCamera()
            --[[
                BaseCamera - Abstract base class for camera control modules
                2018 Camera Update - AllYourBlox
            --]]
            
            --[[ Local Constants ]]--
            local UNIT_Z = Vector3.new(0,0,1)
            local X1_Y0_Z1 = Vector3.new(1,0,1)	--Note: not a unit vector, used for projecting onto XZ plane
            
            local THUMBSTICK_DEADZONE = 0.2
            local DEFAULT_DISTANCE = 12.5	-- Studs
            local PORTRAIT_DEFAULT_DISTANCE = 25		-- Studs
            local FIRST_PERSON_DISTANCE_THRESHOLD = 1.0 -- Below this value, snap into first person
            
            local CAMERA_ACTION_PRIORITY = Enum.ContextActionPriority.Default.Value
            
            -- Note: DotProduct check in CoordinateFrame::lookAt() prevents using values within about
            -- 8.11 degrees of the +/- Y axis, that's why these limits are currently 80 degrees
            local MIN_Y = math.rad(-80)
            local MAX_Y = math.rad(80)
            
            local TOUCH_ADJUST_AREA_UP = math.rad(30)
            local TOUCH_ADJUST_AREA_DOWN = math.rad(-15)
            
            local TOUCH_SENSITIVTY_ADJUST_MAX_Y = 2.1
            local TOUCH_SENSITIVTY_ADJUST_MIN_Y = 0.5
            
            local VR_ANGLE = math.rad(15)
            local VR_LOW_INTENSITY_ROTATION = Vector2.new(math.rad(15), 0)
            local VR_HIGH_INTENSITY_ROTATION = Vector2.new(math.rad(45), 0)
            local VR_LOW_INTENSITY_REPEAT = 0.1
            local VR_HIGH_INTENSITY_REPEAT = 0.4
            
            local ZERO_VECTOR2 = Vector2.new(0,0)
            local ZERO_VECTOR3 = Vector3.new(0,0,0)
            
            local TOUCH_SENSITIVTY = Vector2.new(0.00945 * math.pi, 0.003375 * math.pi)
            local MOUSE_SENSITIVITY = Vector2.new( 0.002 * math.pi, 0.0015 * math.pi )
            
            local SEAT_OFFSET = Vector3.new(0,5,0)
            local VR_SEAT_OFFSET = Vector3.new(0,4,0)
            local HEAD_OFFSET = Vector3.new(0,1.5,0)
            local R15_HEAD_OFFSET = Vector3.new(0, 1.5, 0)
            local R15_HEAD_OFFSET_NO_SCALING = Vector3.new(0, 2, 0)
            local HUMANOID_ROOT_PART_SIZE = Vector3.new(2, 2, 1)
            
            local GAMEPAD_ZOOM_STEP_1 = 0
            local GAMEPAD_ZOOM_STEP_2 = 10
            local GAMEPAD_ZOOM_STEP_3 = 20
            
            local PAN_SENSITIVITY = 20
            local ZOOM_SENSITIVITY_CURVATURE = 0.5
            
            local abs = math.abs
            local sign = math.sign
            
            local FFlagUserCameraToggle do
                local success, result = pcall(function()
                    return UserSettings():IsUserFeatureEnabled("UserCameraToggle")
                end)
                FFlagUserCameraToggle = success and result
            end
            
            local FFlagUserDontAdjustSensitvityForPortrait do
                local success, result = pcall(function()
                    return UserSettings():IsUserFeatureEnabled("UserDontAdjustSensitvityForPortrait")
                end)
                FFlagUserDontAdjustSensitvityForPortrait = success and result
            end
            
            local FFlagUserFixZoomInZoomOutDiscrepancy do
                local success, result = pcall(function()
                    return UserSettings():IsUserFeatureEnabled("UserFixZoomInZoomOutDiscrepancy")
                end)
                FFlagUserFixZoomInZoomOutDiscrepancy = success and result
            end
            
            local Util = _CameraUtils()
            local ZoomController = _ZoomController()
            local CameraToggleStateController = _CameraToggleStateController()
            local CameraInput = _CameraInput()
            local CameraUI = _CameraUI()
            
            --[[ Roblox Services ]]--
            local Players = game:GetService("Players")
            local UserInputService = game:GetService("UserInputService")
            local StarterGui = game:GetService("StarterGui")
            local GuiService = game:GetService("GuiService")
            local ContextActionService = game:GetService("ContextActionService")
            local VRService = game:GetService("VRService")
            local UserGameSettings = UserSettings():GetService("UserGameSettings")
            
            local player = Players.LocalPlayer 
            
            --[[ The Module ]]--
            local BaseCamera = {}
            BaseCamera.__index = BaseCamera
            
            function BaseCamera.new()
                local self = setmetatable({}, BaseCamera)
            
                -- So that derived classes have access to this
                self.FIRST_PERSON_DISTANCE_THRESHOLD = FIRST_PERSON_DISTANCE_THRESHOLD
            
                self.cameraType = nil
                self.cameraMovementMode = nil
            
                self.lastCameraTransform = nil
                self.rotateInput = ZERO_VECTOR2
                self.userPanningCamera = false
                self.lastUserPanCamera = tick()
            
                self.humanoidRootPart = nil
                self.humanoidCache = {}
            
                -- Subject and position on last update call
                self.lastSubject = nil
                self.lastSubjectPosition = Vector3.new(0,5,0)
            
                -- These subject distance members refer to the nominal camera-to-subject follow distance that the camera
                -- is trying to maintain, not the actual measured value.
                -- The default is updated when screen orientation or the min/max distances change,
                -- to be sure the default is always in range and appropriate for the orientation.
                self.defaultSubjectDistance = math.clamp(DEFAULT_DISTANCE, player.CameraMinZoomDistance, player.CameraMaxZoomDistance)
                self.currentSubjectDistance = math.clamp(DEFAULT_DISTANCE, player.CameraMinZoomDistance, player.CameraMaxZoomDistance)
            
                self.inFirstPerson = false
                self.inMouseLockedMode = false
                self.portraitMode = false
                self.isSmallTouchScreen = false
            
                -- Used by modules which want to reset the camera angle on respawn.
                self.resetCameraAngle = true
            
                self.enabled = false
            
                -- Input Event Connections
                self.inputBeganConn = nil
                self.inputChangedConn = nil
                self.inputEndedConn = nil
            
                self.startPos = nil
                self.lastPos = nil
                self.panBeginLook = nil
            
                self.panEnabled = true
                self.keyPanEnabled = true
                self.distanceChangeEnabled = true
            
                self.PlayerGui = nil
            
                self.cameraChangedConn = nil
                self.viewportSizeChangedConn = nil
            
                self.boundContextActions = {}
            
                -- VR Support
                self.shouldUseVRRotation = false
                self.VRRotationIntensityAvailable = false
                self.lastVRRotationIntensityCheckTime = 0
                self.lastVRRotationTime = 0
                self.vrRotateKeyCooldown = {}
                self.cameraTranslationConstraints = Vector3.new(1, 1, 1)
                self.humanoidJumpOrigin = nil
                self.trackingHumanoid = nil
                self.cameraFrozen = false
                self.subjectStateChangedConn = nil
            
                -- Gamepad support
                self.activeGamepad = nil
                self.gamepadPanningCamera = false
                self.lastThumbstickRotate = nil
                self.numOfSeconds = 0.7
                self.currentSpeed = 0
                self.maxSpeed = 6
                self.vrMaxSpeed = 4
                self.lastThumbstickPos = Vector2.new(0,0)
                self.ySensitivity = 0.65
                self.lastVelocity = nil
                self.gamepadConnectedConn = nil
                self.gamepadDisconnectedConn = nil
                self.currentZoomSpeed = 1.0
                self.L3ButtonDown = false
                self.dpadLeftDown = false
                self.dpadRightDown = false
            
                -- Touch input support
                self.isDynamicThumbstickEnabled = false
                self.fingerTouches = {}
                self.dynamicTouchInput = nil
                self.numUnsunkTouches = 0
                self.inputStartPositions = {}
                self.inputStartTimes = {}
                self.startingDiff = nil
                self.pinchBeginZoom = nil
                self.userPanningTheCamera = false
                self.touchActivateConn = nil
            
                -- Mouse locked formerly known as shift lock mode
                self.mouseLockOffset = ZERO_VECTOR3
            
                -- [[ NOTICE ]] --
                -- Initialization things used to always execute at game load time, but now these camera modules are instantiated
                -- when needed, so the code here may run well after the start of the game
            
                if player.Character then
                    self:OnCharacterAdded(player.Character)
                end
            
                player.CharacterAdded:Connect(function(char)
                    self:OnCharacterAdded(char)
                end)
            
                if self.cameraChangedConn then self.cameraChangedConn:Disconnect() end
                self.cameraChangedConn = workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
                    self:OnCurrentCameraChanged()
                end)
                self:OnCurrentCameraChanged()
            
                if self.playerCameraModeChangeConn then self.playerCameraModeChangeConn:Disconnect() end
                self.playerCameraModeChangeConn = player:GetPropertyChangedSignal("CameraMode"):Connect(function()
                    self:OnPlayerCameraPropertyChange()
                end)
            
                if self.minDistanceChangeConn then self.minDistanceChangeConn:Disconnect() end
                self.minDistanceChangeConn = player:GetPropertyChangedSignal("CameraMinZoomDistance"):Connect(function()
                    self:OnPlayerCameraPropertyChange()
                end)
            
                if self.maxDistanceChangeConn then self.maxDistanceChangeConn:Disconnect() end
                self.maxDistanceChangeConn = player:GetPropertyChangedSignal("CameraMaxZoomDistance"):Connect(function()
                    self:OnPlayerCameraPropertyChange()
                end)
            
                if self.playerDevTouchMoveModeChangeConn then self.playerDevTouchMoveModeChangeConn:Disconnect() end
                self.playerDevTouchMoveModeChangeConn = player:GetPropertyChangedSignal("DevTouchMovementMode"):Connect(function()
                    self:OnDevTouchMovementModeChanged()
                end)
                self:OnDevTouchMovementModeChanged() -- Init
            
                if self.gameSettingsTouchMoveMoveChangeConn then self.gameSettingsTouchMoveMoveChangeConn:Disconnect() end
                self.gameSettingsTouchMoveMoveChangeConn = UserGameSettings:GetPropertyChangedSignal("TouchMovementMode"):Connect(function()
                    self:OnGameSettingsTouchMovementModeChanged()
                end)
                self:OnGameSettingsTouchMovementModeChanged() -- Init
            
                UserGameSettings:SetCameraYInvertVisible()
                UserGameSettings:SetGamepadCameraSensitivityVisible()
            
                self.hasGameLoaded = game:IsLoaded()
                if not self.hasGameLoaded then
                    self.gameLoadedConn = game.Loaded:Connect(function()
                        self.hasGameLoaded = true
                        self.gameLoadedConn:Disconnect()
                        self.gameLoadedConn = nil
                    end)
                end
            
                self:OnPlayerCameraPropertyChange()
            
                return self
            end
            
            function BaseCamera:GetModuleName()
                return "BaseCamera"
            end
            
            function BaseCamera:OnCharacterAdded(char)
                self.resetCameraAngle = self.resetCameraAngle or self:GetEnabled()
                self.humanoidRootPart = nil
                if UserInputService.TouchEnabled then
                    self.PlayerGui = player:WaitForChild("PlayerGui")
                    for _, child in ipairs(char:GetChildren()) do
                        if child:IsA("Tool") then
                            self.isAToolEquipped = true
                        end
                    end
                    char.ChildAdded:Connect(function(child)
                        if child:IsA("Tool") then
                            self.isAToolEquipped = true
                        end
                    end)
                    char.ChildRemoved:Connect(function(child)
                        if child:IsA("Tool") then
                            self.isAToolEquipped = false
                        end
                    end)
                end
            end
            
            function BaseCamera:GetHumanoidRootPart()
                if not self.humanoidRootPart then
                    if player.Character then
                        local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
                        if humanoid then
                            self.humanoidRootPart = humanoid.RootPart
                        end
                    end
                end
                return self.humanoidRootPart
            end
            
            function BaseCamera:GetBodyPartToFollow(humanoid, isDead)
                -- If the humanoid is dead, prefer the head part if one still exists as a sibling of the humanoid
                if humanoid:GetState() == Enum.HumanoidStateType.Dead then
                    local character = humanoid.Parent
                    if character and character:IsA("Model") then
                        return character:FindFirstChild("Head") or humanoid.RootPart
                    end
                end
            
                return humanoid.RootPart
            end
            
            function BaseCamera:GetSubjectPosition()
                local result = self.lastSubjectPosition
                local camera = game.Workspace.CurrentCamera
                local cameraSubject = camera and camera.CameraSubject
            
                if cameraSubject then
                    if cameraSubject:IsA("Humanoid") then
                        local humanoid = cameraSubject
                        local humanoidIsDead = humanoid:GetState() == Enum.HumanoidStateType.Dead
            
                        if VRService.VREnabled and humanoidIsDead and humanoid == self.lastSubject then
                            result = self.lastSubjectPosition
                        else
                            local bodyPartToFollow = humanoid.RootPart
            
                            -- If the humanoid is dead, prefer their head part as a follow target, if it exists
                            if humanoidIsDead then
                                if humanoid.Parent and humanoid.Parent:IsA("Model") then
                                    bodyPartToFollow = humanoid.Parent:FindFirstChild("Head") or bodyPartToFollow
                                end
                            end
            
                            if bodyPartToFollow and bodyPartToFollow:IsA("BasePart") then
                                local heightOffset
                                if humanoid.RigType == Enum.HumanoidRigType.R15 then
                                    if humanoid.AutomaticScalingEnabled then
                                        heightOffset = R15_HEAD_OFFSET
                                        if bodyPartToFollow == humanoid.RootPart then
                                            local rootPartSizeOffset = (humanoid.RootPart.Size.Y/2) - (HUMANOID_ROOT_PART_SIZE.Y/2)
                                            heightOffset = heightOffset + Vector3.new(0, rootPartSizeOffset, 0)
                                        end
                                    else
                                        heightOffset = R15_HEAD_OFFSET_NO_SCALING
                                    end
                                else
                                    heightOffset = HEAD_OFFSET
                                end
            
                                if humanoidIsDead then
                                    heightOffset = ZERO_VECTOR3
                                end
            
                                result = bodyPartToFollow.CFrame.p + bodyPartToFollow.CFrame:vectorToWorldSpace(heightOffset + humanoid.CameraOffset)
                            end
                        end
            
                    elseif cameraSubject:IsA("VehicleSeat") then
                        local offset = SEAT_OFFSET
                        if VRService.VREnabled then
                            offset = VR_SEAT_OFFSET
                        end
                        result = cameraSubject.CFrame.p + cameraSubject.CFrame:vectorToWorldSpace(offset)
                    elseif cameraSubject:IsA("SkateboardPlatform") then
                        result = cameraSubject.CFrame.p + SEAT_OFFSET
                    elseif cameraSubject:IsA("BasePart") then
                        result = cameraSubject.CFrame.p
                    elseif cameraSubject:IsA("Model") then
                        if cameraSubject.PrimaryPart then
                            result = cameraSubject:GetPrimaryPartCFrame().p
                        else
                            result = cameraSubject:GetModelCFrame().p
                        end
                    end
                else
                    -- cameraSubject is nil
                    -- Note: Previous RootCamera did not have this else case and let self.lastSubject and self.lastSubjectPosition
                    -- both get set to nil in the case of cameraSubject being nil. This function now exits here to preserve the
                    -- last set valid values for these, as nil values are not handled cases
                    return
                end
            
                self.lastSubject = cameraSubject
                self.lastSubjectPosition = result
            
                return result
            end
            
            function BaseCamera:UpdateDefaultSubjectDistance()
                if self.portraitMode then
                    self.defaultSubjectDistance = math.clamp(PORTRAIT_DEFAULT_DISTANCE, player.CameraMinZoomDistance, player.CameraMaxZoomDistance)
                else
                    self.defaultSubjectDistance = math.clamp(DEFAULT_DISTANCE, player.CameraMinZoomDistance, player.CameraMaxZoomDistance)
                end
            end
            
            function BaseCamera:OnViewportSizeChanged()
                local camera = game.Workspace.CurrentCamera
                local size = camera.ViewportSize
                self.portraitMode = size.X < size.Y
                self.isSmallTouchScreen = UserInputService.TouchEnabled and (size.Y < 500 or size.X < 700)
            
                self:UpdateDefaultSubjectDistance()
            end
            
            -- Listener for changes to workspace.CurrentCamera
            function BaseCamera:OnCurrentCameraChanged()
                if UserInputService.TouchEnabled then
                    if self.viewportSizeChangedConn then
                        self.viewportSizeChangedConn:Disconnect()
                        self.viewportSizeChangedConn = nil
                    end
            
                    local newCamera = game.Workspace.CurrentCamera
            
                    if newCamera then
                        self:OnViewportSizeChanged()
                        self.viewportSizeChangedConn = newCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
                            self:OnViewportSizeChanged()
                        end)
                    end
                end
            
                -- VR support additions
                if self.cameraSubjectChangedConn then
                    self.cameraSubjectChangedConn:Disconnect()
                    self.cameraSubjectChangedConn = nil
                end
            
                local camera = game.Workspace.CurrentCamera
                if camera then
                    self.cameraSubjectChangedConn = camera:GetPropertyChangedSignal("CameraSubject"):Connect(function()
                        self:OnNewCameraSubject()
                    end)
                    self:OnNewCameraSubject()
                end
            end
            
            function BaseCamera:OnDynamicThumbstickEnabled()
                if UserInputService.TouchEnabled then
                    self.isDynamicThumbstickEnabled = true
                end
            end
            
            function BaseCamera:OnDynamicThumbstickDisabled()
                self.isDynamicThumbstickEnabled = false
            end
            
            function BaseCamera:OnGameSettingsTouchMovementModeChanged()
                if player.DevTouchMovementMode == Enum.DevTouchMovementMode.UserChoice then
                    if (UserGameSettings.TouchMovementMode == Enum.TouchMovementMode.DynamicThumbstick
                        or UserGameSettings.TouchMovementMode == Enum.TouchMovementMode.Default) then
                        self:OnDynamicThumbstickEnabled()
                    else
                        self:OnDynamicThumbstickDisabled()
                    end
                end
            end
            
            function BaseCamera:OnDevTouchMovementModeChanged()
                if player.DevTouchMovementMode.Name == "DynamicThumbstick" then
                    self:OnDynamicThumbstickEnabled()
                else
                    self:OnGameSettingsTouchMovementModeChanged()
                end
            end
            
            function BaseCamera:OnPlayerCameraPropertyChange()
                -- This call forces re-evaluation of player.CameraMode and clamping to min/max distance which may have changed
                self:SetCameraToSubjectDistance(self.currentSubjectDistance)
            end
            
            function BaseCamera:GetCameraHeight()
                if VRService.VREnabled and not self.inFirstPerson then
                    return math.sin(VR_ANGLE) * self.currentSubjectDistance
                end
                return 0
            end
            
            function BaseCamera:InputTranslationToCameraAngleChange(translationVector, sensitivity)
                if not FFlagUserDontAdjustSensitvityForPortrait then
                    local camera = game.Workspace.CurrentCamera
                    if camera and camera.ViewportSize.X > 0 and camera.ViewportSize.Y > 0 and (camera.ViewportSize.Y > camera.ViewportSize.X) then
                        -- Screen has portrait orientation, swap X and Y sensitivity
                        return translationVector * Vector2.new( sensitivity.Y, sensitivity.X)
                    end
                end
                return translationVector * sensitivity
            end
            
            function BaseCamera:Enable(enable)
                if self.enabled ~= enable then
                    self.enabled = enable
                    if self.enabled then
                        self:ConnectInputEvents()
                        self:BindContextActions()
            
                        if player.CameraMode == Enum.CameraMode.LockFirstPerson then
                            self.currentSubjectDistance = 0.5
                            if not self.inFirstPerson then
                                self:EnterFirstPerson()
                            end
                        end
                    else
                        self:DisconnectInputEvents()
                        self:UnbindContextActions()
                        -- Clean up additional event listeners and reset a bunch of properties
                        self:Cleanup()
                    end
                end
            end
            
            function BaseCamera:GetEnabled()
                return self.enabled
            end
            
            function BaseCamera:OnInputBegan(input, processed)
                if input.UserInputType == Enum.UserInputType.Touch then
                    self:OnTouchBegan(input, processed)
                elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
                    self:OnMouse2Down(input, processed)
                elseif input.UserInputType == Enum.UserInputType.MouseButton3 then
                    self:OnMouse3Down(input, processed)
                end
            end
            
            function BaseCamera:OnInputChanged(input, processed)
                if input.UserInputType == Enum.UserInputType.Touch then
                    self:OnTouchChanged(input, processed)
                elseif input.UserInputType == Enum.UserInputType.MouseMovement then
                    self:OnMouseMoved(input, processed)
                end
            end
            
            function BaseCamera:OnInputEnded(input, processed)
                if input.UserInputType == Enum.UserInputType.Touch then
                    self:OnTouchEnded(input, processed)
                elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
                    self:OnMouse2Up(input, processed)
                elseif input.UserInputType == Enum.UserInputType.MouseButton3 then
                    self:OnMouse3Up(input, processed)
                end
            end
            
            function BaseCamera:OnPointerAction(wheel, pan, pinch, processed)
                if processed then
                    return
                end
            
                if pan.Magnitude > 0 then
                    local inversionVector = Vector2.new(1, UserGameSettings:GetCameraYInvertValue())
                    local rotateDelta = self:InputTranslationToCameraAngleChange(PAN_SENSITIVITY*pan, MOUSE_SENSITIVITY)*inversionVector
                    self.rotateInput = self.rotateInput + rotateDelta
                end
            
                local zoom = self.currentSubjectDistance
                local zoomDelta = -(wheel + pinch)
            
                if abs(zoomDelta) > 0 then
                    local newZoom
                    if self.inFirstPerson and zoomDelta > 0 then
                        newZoom = FIRST_PERSON_DISTANCE_THRESHOLD
                    else
                        if FFlagUserFixZoomInZoomOutDiscrepancy then
                            if (zoomDelta > 0) then
                                newZoom = zoom + zoomDelta*(1 + zoom*ZOOM_SENSITIVITY_CURVATURE)
                            else
                                newZoom = (zoom + zoomDelta) / (1 - zoomDelta*ZOOM_SENSITIVITY_CURVATURE)
                            end
                        else
                            newZoom = zoom + zoomDelta*(1 + zoom*ZOOM_SENSITIVITY_CURVATURE)
                        end
                    end
            
                    self:SetCameraToSubjectDistance(newZoom)
                end
            end
            
            function BaseCamera:ConnectInputEvents()
                self.pointerActionConn = UserInputService.PointerAction:Connect(function(wheel, pan, pinch, processed)
                    self:OnPointerAction(wheel, pan, pinch, processed)
                end)
            
                self.inputBeganConn = UserInputService.InputBegan:Connect(function(input, processed)
                    self:OnInputBegan(input, processed)
                end)
            
                self.inputChangedConn = UserInputService.InputChanged:Connect(function(input, processed)
                    self:OnInputChanged(input, processed)
                end)
            
                self.inputEndedConn = UserInputService.InputEnded:Connect(function(input, processed)
                    self:OnInputEnded(input, processed)
                end)
            
                self.menuOpenedConn = GuiService.MenuOpened:connect(function()
                    self:ResetInputStates()
                end)
            
                self.gamepadConnectedConn = UserInputService.GamepadDisconnected:connect(function(gamepadEnum)
                    if self.activeGamepad ~= gamepadEnum then return end
                    self.activeGamepad = nil
                    self:AssignActivateGamepad()
                end)
            
                self.gamepadDisconnectedConn = UserInputService.GamepadConnected:connect(function(gamepadEnum)
                    if self.activeGamepad == nil then
                        self:AssignActivateGamepad()
                    end
                end)
            
                self:AssignActivateGamepad()
                if not FFlagUserCameraToggle then
                    self:UpdateMouseBehavior()
                end
            end
            
            function BaseCamera:BindContextActions()
                self:BindGamepadInputActions()
                self:BindKeyboardInputActions()
            end
            
            function BaseCamera:AssignActivateGamepad()
                local connectedGamepads = UserInputService:GetConnectedGamepads()
                if #connectedGamepads > 0 then
                    for i = 1, #connectedGamepads do
                        if self.activeGamepad == nil then
                            self.activeGamepad = connectedGamepads[i]
                        elseif connectedGamepads[i].Value < self.activeGamepad.Value then
                            self.activeGamepad = connectedGamepads[i]
                        end
                    end
                end
            
                if self.activeGamepad == nil then -- nothing is connected, at least set up for gamepad1
                    self.activeGamepad = Enum.UserInputType.Gamepad1
                end
            end
            
            function BaseCamera:DisconnectInputEvents()
                if self.inputBeganConn then
                    self.inputBeganConn:Disconnect()
                    self.inputBeganConn = nil
                end
                if self.inputChangedConn then
                    self.inputChangedConn:Disconnect()
                    self.inputChangedConn = nil
                end
                if self.inputEndedConn then
                    self.inputEndedConn:Disconnect()
                    self.inputEndedConn = nil
                end
            end
            
            function BaseCamera:UnbindContextActions()
                for i = 1, #self.boundContextActions do
                    ContextActionService:UnbindAction(self.boundContextActions[i])
                end
                self.boundContextActions = {}
            end
            
            function BaseCamera:Cleanup()
                if self.pointerActionConn then
                    self.pointerActionConn:Disconnect()
                    self.pointerActionConn = nil
                end
                if self.menuOpenedConn then
                    self.menuOpenedConn:Disconnect()
                    self.menuOpenedConn = nil
                end
                if self.mouseLockToggleConn then
                    self.mouseLockToggleConn:Disconnect()
                    self.mouseLockToggleConn = nil
                end
                if self.gamepadConnectedConn then
                    self.gamepadConnectedConn:Disconnect()
                    self.gamepadConnectedConn = nil
                end
                if self.gamepadDisconnectedConn then
                    self.gamepadDisconnectedConn:Disconnect()
                    self.gamepadDisconnectedConn = nil
                end
                if self.subjectStateChangedConn then
                    self.subjectStateChangedConn:Disconnect()
                    self.subjectStateChangedConn = nil
                end
                if self.viewportSizeChangedConn then
                    self.viewportSizeChangedConn:Disconnect()
                    self.viewportSizeChangedConn = nil
                end
                if self.touchActivateConn then
                    self.touchActivateConn:Disconnect()
                    self.touchActivateConn = nil
                end
            
                self.turningLeft = false
                self.turningRight = false
                self.lastCameraTransform = nil
                self.lastSubjectCFrame = nil
                self.userPanningTheCamera = false
                self.rotateInput = Vector2.new()
                self.gamepadPanningCamera = Vector2.new(0,0)
            
                -- Reset input states
                self.startPos = nil
                self.lastPos = nil
                self.panBeginLook = nil
                self.isRightMouseDown = false
                self.isMiddleMouseDown = false
            
                self.fingerTouches = {}
                self.dynamicTouchInput = nil
                self.numUnsunkTouches = 0
            
                self.startingDiff = nil
                self.pinchBeginZoom = nil
            
                -- Unlock mouse for example if right mouse button was being held down
                if UserInputService.MouseBehavior ~= Enum.MouseBehavior.LockCenter then
                    UserInputService.MouseBehavior = Enum.MouseBehavior.Default
                end
            end
            
            -- This is called when settings menu is opened
            function BaseCamera:ResetInputStates()
                self.isRightMouseDown = false
                self.isMiddleMouseDown = false
                self:OnMousePanButtonReleased() -- this function doesn't seem to actually need parameters
            
                if UserInputService.TouchEnabled then
                    --[[menu opening was causing serious touch issues
                    this should disable all active touch events if
                    they're active when menu opens.]]
                    for inputObject in pairs(self.fingerTouches) do
                        self.fingerTouches[inputObject] = nil
                    end
                    self.dynamicTouchInput = nil
                    self.panBeginLook = nil
                    self.startPos = nil
                    self.lastPos = nil
                    self.userPanningTheCamera = false
                    self.startingDiff = nil
                    self.pinchBeginZoom = nil
                    self.numUnsunkTouches = 0
                end
            end
            
            function BaseCamera:GetGamepadPan(name, state, input)
                if input.UserInputType == self.activeGamepad and input.KeyCode == Enum.KeyCode.Thumbstick2 then
            --		if self.L3ButtonDown then
            --			-- L3 Thumbstick is depressed, right stick controls dolly in/out
            --			if (input.Position.Y > THUMBSTICK_DEADZONE) then
            --				self.currentZoomSpeed = 0.96
            --			elseif (input.Position.Y < -THUMBSTICK_DEADZONE) then
            --				self.currentZoomSpeed = 1.04
            --			else
            --				self.currentZoomSpeed = 1.00
            --			end
            --		else
                        if state == Enum.UserInputState.Cancel then
                            self.gamepadPanningCamera = ZERO_VECTOR2
                            return
                        end
            
                        local inputVector = Vector2.new(input.Position.X, -input.Position.Y)
                        if inputVector.magnitude > THUMBSTICK_DEADZONE then
                            self.gamepadPanningCamera = Vector2.new(input.Position.X, -input.Position.Y)
                        else
                            self.gamepadPanningCamera = ZERO_VECTOR2
                        end
                    --end
                    return Enum.ContextActionResult.Sink
                end
                return Enum.ContextActionResult.Pass
            end
            
            function BaseCamera:DoKeyboardPanTurn(name, state, input)
                if not self.hasGameLoaded and VRService.VREnabled then
                    return Enum.ContextActionResult.Pass
                end
            
                if state == Enum.UserInputState.Cancel then
                    self.turningLeft = false
                    self.turningRight = false
                    return Enum.ContextActionResult.Sink
                end
            
                if self.panBeginLook == nil and self.keyPanEnabled then
                    if input.KeyCode == Enum.KeyCode.Left then
                        self.turningLeft = state == Enum.UserInputState.Begin
                    elseif input.KeyCode == Enum.KeyCode.Right then
                        self.turningRight = state == Enum.UserInputState.Begin
                    end
                    return Enum.ContextActionResult.Sink
                end
                return Enum.ContextActionResult.Pass
            end
            
            function BaseCamera:DoPanRotateCamera(rotateAngle)
                local angle = Util.RotateVectorByAngleAndRound(self:GetCameraLookVector() * Vector3.new(1,0,1), rotateAngle, math.pi*0.25)
                if angle ~= 0 then
                    self.rotateInput = self.rotateInput + Vector2.new(angle, 0)
                    self.lastUserPanCamera = tick()
                    self.lastCameraTransform = nil
                end
            end
            
            function BaseCamera:DoGamepadZoom(name, state, input)
                if input.UserInputType == self.activeGamepad then
                    if input.KeyCode == Enum.KeyCode.ButtonR3 then
                        if state == Enum.UserInputState.Begin then
                            if self.distanceChangeEnabled then
                                local dist = self:GetCameraToSubjectDistance()
            
                                if dist > (GAMEPAD_ZOOM_STEP_2 + GAMEPAD_ZOOM_STEP_3)/2 then
                                    self:SetCameraToSubjectDistance(GAMEPAD_ZOOM_STEP_2)
                                elseif dist > (GAMEPAD_ZOOM_STEP_1 + GAMEPAD_ZOOM_STEP_2)/2 then
                                    self:SetCameraToSubjectDistance(GAMEPAD_ZOOM_STEP_1)
                                else
                                    self:SetCameraToSubjectDistance(GAMEPAD_ZOOM_STEP_3)
                                end
                            end
                        end
                    elseif input.KeyCode == Enum.KeyCode.DPadLeft then
                        self.dpadLeftDown = (state == Enum.UserInputState.Begin)
                    elseif input.KeyCode == Enum.KeyCode.DPadRight then
                        self.dpadRightDown = (state == Enum.UserInputState.Begin)
                    end
            
                    if self.dpadLeftDown then
                        self.currentZoomSpeed = 1.04
                    elseif self.dpadRightDown then
                        self.currentZoomSpeed = 0.96
                    else
                        self.currentZoomSpeed = 1.00
                    end
                    return Enum.ContextActionResult.Sink
                end
                return Enum.ContextActionResult.Pass
            --	elseif input.UserInputType == self.activeGamepad and input.KeyCode == Enum.KeyCode.ButtonL3 then
            --		if (state == Enum.UserInputState.Begin) then
            --			self.L3ButtonDown = true
            --		elseif (state == Enum.UserInputState.End) then
            --			self.L3ButtonDown = false
            --			self.currentZoomSpeed = 1.00
            --		end
            --	end
            end
            
            function BaseCamera:DoKeyboardZoom(name, state, input)
                if not self.hasGameLoaded and VRService.VREnabled then
                    return Enum.ContextActionResult.Pass
                end
            
                if state ~= Enum.UserInputState.Begin then
                    return Enum.ContextActionResult.Pass
                end
            
                if self.distanceChangeEnabled and player.CameraMode ~= Enum.CameraMode.LockFirstPerson then
                    if input.KeyCode == Enum.KeyCode.I then
                        self:SetCameraToSubjectDistance( self.currentSubjectDistance - 5 )
                    elseif input.KeyCode == Enum.KeyCode.O then
                        self:SetCameraToSubjectDistance( self.currentSubjectDistance + 5 )
                    end
                    return Enum.ContextActionResult.Sink
                end
                return Enum.ContextActionResult.Pass
            end
            
            function BaseCamera:BindAction(actionName, actionFunc, createTouchButton, ...)
                table.insert(self.boundContextActions, actionName)
                ContextActionService:BindActionAtPriority(actionName, actionFunc, createTouchButton,
                    CAMERA_ACTION_PRIORITY, ...)
            end
            
            function BaseCamera:BindGamepadInputActions()
                self:BindAction("BaseCameraGamepadPan", function(name, state, input) return self:GetGamepadPan(name, state, input) end,
                    false, Enum.KeyCode.Thumbstick2)
                self:BindAction("BaseCameraGamepadZoom", function(name, state, input) return self:DoGamepadZoom(name, state, input) end,
                    false, Enum.KeyCode.DPadLeft, Enum.KeyCode.DPadRight, Enum.KeyCode.ButtonR3)
            end
            
            function BaseCamera:BindKeyboardInputActions()
                self:BindAction("BaseCameraKeyboardPanArrowKeys", function(name, state, input) return self:DoKeyboardPanTurn(name, state, input) end,
                    false, Enum.KeyCode.Left, Enum.KeyCode.Right)
                self:BindAction("BaseCameraKeyboardZoom", function(name, state, input) return self:DoKeyboardZoom(name, state, input) end,
                    false, Enum.KeyCode.I, Enum.KeyCode.O)
            end
            
            local function isInDynamicThumbstickArea(input)
                local playerGui = player:FindFirstChildOfClass("PlayerGui")
                local touchGui = playerGui and playerGui:FindFirstChild("TouchGui")
                local touchFrame = touchGui and touchGui:FindFirstChild("TouchControlFrame")
                local thumbstickFrame = touchFrame and touchFrame:FindFirstChild("DynamicThumbstickFrame")
            
                if not thumbstickFrame then
                    return false
                end
            
                local frameCornerTopLeft = thumbstickFrame.AbsolutePosition
                local frameCornerBottomRight = frameCornerTopLeft + thumbstickFrame.AbsoluteSize
                if input.Position.X >= frameCornerTopLeft.X and input.Position.Y >= frameCornerTopLeft.Y then
                    if input.Position.X <= frameCornerBottomRight.X and input.Position.Y <= frameCornerBottomRight.Y then
                        return true
                    end
                end
            
                return false
            end
            
            ---Adjusts the camera Y touch Sensitivity when moving away from the center and in the TOUCH_SENSITIVTY_ADJUST_AREA
            function BaseCamera:AdjustTouchSensitivity(delta, sensitivity)
                local cameraCFrame = game.Workspace.CurrentCamera and game.Workspace.CurrentCamera.CFrame
                if not cameraCFrame then
                    return sensitivity
                end
                local currPitchAngle = cameraCFrame:ToEulerAnglesYXZ()
            
                local multiplierY = TOUCH_SENSITIVTY_ADJUST_MAX_Y
                if currPitchAngle > TOUCH_ADJUST_AREA_UP and delta.Y < 0 then
                    local fractionAdjust = (currPitchAngle - TOUCH_ADJUST_AREA_UP)/(MAX_Y - TOUCH_ADJUST_AREA_UP)
                    fractionAdjust = 1 - (1 - fractionAdjust)^3
                    multiplierY = TOUCH_SENSITIVTY_ADJUST_MAX_Y - fractionAdjust * (
                        TOUCH_SENSITIVTY_ADJUST_MAX_Y - TOUCH_SENSITIVTY_ADJUST_MIN_Y)
                elseif currPitchAngle < TOUCH_ADJUST_AREA_DOWN and delta.Y > 0 then
                    local fractionAdjust = (currPitchAngle - TOUCH_ADJUST_AREA_DOWN)/(MIN_Y - TOUCH_ADJUST_AREA_DOWN)
                    fractionAdjust = 1 - (1 - fractionAdjust)^3
                    multiplierY = TOUCH_SENSITIVTY_ADJUST_MAX_Y - fractionAdjust * (
                        TOUCH_SENSITIVTY_ADJUST_MAX_Y - TOUCH_SENSITIVTY_ADJUST_MIN_Y)
                end
            
                return Vector2.new(
                    sensitivity.X,
                    sensitivity.Y * multiplierY
                )
            end
            
            function BaseCamera:OnTouchBegan(input, processed)
                local canUseDynamicTouch = self.isDynamicThumbstickEnabled and not processed
                if canUseDynamicTouch then
                    if self.dynamicTouchInput == nil and isInDynamicThumbstickArea(input) then
                        -- First input in the dynamic thumbstick area should always be ignored for camera purposes
                        -- Even if the dynamic thumbstick does not process it immediately
                        self.dynamicTouchInput = input
                        return
                    end
                    self.fingerTouches[input] = processed
                    self.inputStartPositions[input] = input.Position
                    self.inputStartTimes[input] = tick()
                    self.numUnsunkTouches = self.numUnsunkTouches + 1
                end
            end
            
            function BaseCamera:OnTouchChanged(input, processed)
                if self.fingerTouches[input] == nil then
                    if self.isDynamicThumbstickEnabled then
                        return
                    end
                    self.fingerTouches[input] = processed
                    if not processed then
                        self.numUnsunkTouches = self.numUnsunkTouches + 1
                    end
                end
            
                if self.numUnsunkTouches == 1 then
                    if self.fingerTouches[input] == false then
                        self.panBeginLook = self.panBeginLook or self:GetCameraLookVector()
                        self.startPos = self.startPos or input.Position
                        self.lastPos = self.lastPos or self.startPos
                        self.userPanningTheCamera = true
            
                        local delta = input.Position - self.lastPos
                        delta = Vector2.new(delta.X, delta.Y * UserGameSettings:GetCameraYInvertValue())
                        if self.panEnabled then
                            local adjustedTouchSensitivity = TOUCH_SENSITIVTY
                            self:AdjustTouchSensitivity(delta, TOUCH_SENSITIVTY)
            
                            local desiredXYVector = self:InputTranslationToCameraAngleChange(delta, adjustedTouchSensitivity)
                            self.rotateInput = self.rotateInput + desiredXYVector
                        end
                        self.lastPos = input.Position
                    end
                else
                    self.panBeginLook = nil
                    self.startPos = nil
                    self.lastPos = nil
                    self.userPanningTheCamera = false
                end
                if self.numUnsunkTouches == 2 then
                    local unsunkTouches = {}
                    for touch, wasSunk in pairs(self.fingerTouches) do
                        if not wasSunk then
                            table.insert(unsunkTouches, touch)
                        end
                    end
                    if #unsunkTouches == 2 then
                        local difference = (unsunkTouches[1].Position - unsunkTouches[2].Position).magnitude
                        if self.startingDiff and self.pinchBeginZoom then
                            local scale = difference / math.max(0.01, self.startingDiff)
                            local clampedScale = math.clamp(scale, 0.1, 10)
                            if self.distanceChangeEnabled then
                                self:SetCameraToSubjectDistance(self.pinchBeginZoom / clampedScale)
                            end
                        else
                            self.startingDiff = difference
                            self.pinchBeginZoom = self:GetCameraToSubjectDistance()
                        end
                    end
                else
                    self.startingDiff = nil
                    self.pinchBeginZoom = nil
                end
            end
            
            function BaseCamera:OnTouchEnded(input, processed)
                if input == self.dynamicTouchInput then
                    self.dynamicTouchInput = nil
                    return
                end
            
                if self.fingerTouches[input] == false then
                    if self.numUnsunkTouches == 1 then
                        self.panBeginLook = nil
                        self.startPos = nil
                        self.lastPos = nil
                        self.userPanningTheCamera = false
                    elseif self.numUnsunkTouches == 2 then
                        self.startingDiff = nil
                        self.pinchBeginZoom = nil
                    end
                end
            
                if self.fingerTouches[input] ~= nil and self.fingerTouches[input] == false then
                    self.numUnsunkTouches = self.numUnsunkTouches - 1
                end
                self.fingerTouches[input] = nil
                self.inputStartPositions[input] = nil
                self.inputStartTimes[input] = nil
            end
            
            function BaseCamera:OnMouse2Down(input, processed)
                if processed then return end
            
                self.isRightMouseDown = true
                self:OnMousePanButtonPressed(input, processed)
            end
            
            function BaseCamera:OnMouse2Up(input, processed)
                self.isRightMouseDown = false
                self:OnMousePanButtonReleased(input, processed)
            end
            
            function BaseCamera:OnMouse3Down(input, processed)
                if processed then return end
            
                self.isMiddleMouseDown = true
                self:OnMousePanButtonPressed(input, processed)
            end
            
            function BaseCamera:OnMouse3Up(input, processed)
                self.isMiddleMouseDown = false
                self:OnMousePanButtonReleased(input, processed)
            end
            
            function BaseCamera:OnMouseMoved(input, processed)
                if not self.hasGameLoaded and VRService.VREnabled then
                    return
                end
            
                local inputDelta = input.Delta
                inputDelta = Vector2.new(inputDelta.X, inputDelta.Y * UserGameSettings:GetCameraYInvertValue())
            
                local isInputPanning = FFlagUserCameraToggle and CameraInput.getPanning()
                local isBeginLook = self.startPos and self.lastPos and self.panBeginLook
                local isPanning = isBeginLook or self.inFirstPerson or self.inMouseLockedMode or isInputPanning
            
                if self.panEnabled and isPanning then
                    local desiredXYVector = self:InputTranslationToCameraAngleChange(inputDelta, MOUSE_SENSITIVITY)
                    self.rotateInput = self.rotateInput + desiredXYVector
                end
            
                if self.startPos and self.lastPos and self.panBeginLook then
                    self.lastPos = self.lastPos + input.Delta
                end
            end
            
            function BaseCamera:OnMousePanButtonPressed(input, processed)
                if processed then return end
                if not FFlagUserCameraToggle then
                    self:UpdateMouseBehavior()
                end
                self.panBeginLook = self.panBeginLook or self:GetCameraLookVector()
                self.startPos = self.startPos or input.Position
                self.lastPos = self.lastPos or self.startPos
                self.userPanningTheCamera = true
            end
            
            function BaseCamera:OnMousePanButtonReleased(input, processed)
                if not FFlagUserCameraToggle then
                    self:UpdateMouseBehavior()
                end
                if not (self.isRightMouseDown or self.isMiddleMouseDown) then
                    self.panBeginLook = nil
                    self.startPos = nil
                    self.lastPos = nil
                    self.userPanningTheCamera = false
                end
            end
            
            function BaseCamera:UpdateMouseBehavior()
                if FFlagUserCameraToggle and self.isCameraToggle then
                    CameraUI.setCameraModeToastEnabled(true)
                    CameraInput.enableCameraToggleInput()
                    CameraToggleStateController(self.inFirstPerson)
                else
                    if FFlagUserCameraToggle then
                        CameraUI.setCameraModeToastEnabled(false)
                        CameraInput.disableCameraToggleInput()
                    end
                    -- first time transition to first person mode or mouse-locked third person
                    if self.inFirstPerson or self.inMouseLockedMode then
                        --UserGameSettings.RotationType = Enum.RotationType.CameraRelative
                        UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
                    else
                        UserGameSettings.RotationType = Enum.RotationType.MovementRelative
                        if self.isRightMouseDown or self.isMiddleMouseDown then
                            UserInputService.MouseBehavior = Enum.MouseBehavior.LockCurrentPosition
                        else
                            UserInputService.MouseBehavior = Enum.MouseBehavior.Default
                        end
                    end
                end
            end
            
            function BaseCamera:UpdateForDistancePropertyChange()
                -- Calling this setter with the current value will force checking that it is still
                -- in range after a change to the min/max distance limits
                self:SetCameraToSubjectDistance(self.currentSubjectDistance)
            end
            
            function BaseCamera:SetCameraToSubjectDistance(desiredSubjectDistance)
                local lastSubjectDistance = self.currentSubjectDistance
            
                -- By default, camera modules will respect LockFirstPerson and override the currentSubjectDistance with 0
                -- regardless of what Player.CameraMinZoomDistance is set to, so that first person can be made
                -- available by the developer without needing to allow players to mousewheel dolly into first person.
                -- Some modules will override this function to remove or change first-person capability.
                if player.CameraMode == Enum.CameraMode.LockFirstPerson then
                    self.currentSubjectDistance = 0.5
                    if not self.inFirstPerson then
                        self:EnterFirstPerson()
                    end
                else
                    local newSubjectDistance = math.clamp(desiredSubjectDistance, player.CameraMinZoomDistance, player.CameraMaxZoomDistance)
                    if newSubjectDistance < FIRST_PERSON_DISTANCE_THRESHOLD then
                        self.currentSubjectDistance = 0.5
                        if not self.inFirstPerson then
                            self:EnterFirstPerson()
                        end
                    else
                        self.currentSubjectDistance = newSubjectDistance
                        if self.inFirstPerson then
                            self:LeaveFirstPerson()
                        end
                    end
                end
            
                -- Pass target distance and zoom direction to the zoom controller
                ZoomController.SetZoomParameters(self.currentSubjectDistance, math.sign(desiredSubjectDistance - lastSubjectDistance))
            
                -- Returned only for convenience to the caller to know the outcome
                return self.currentSubjectDistance
            end
            
            function BaseCamera:SetCameraType( cameraType )
                --Used by derived classes
                self.cameraType = cameraType
            end
            
            function BaseCamera:GetCameraType()
                return self.cameraType
            end
            
            -- Movement mode standardized to Enum.ComputerCameraMovementMode values
            function BaseCamera:SetCameraMovementMode( cameraMovementMode )
                self.cameraMovementMode = cameraMovementMode
            end
            
            function BaseCamera:GetCameraMovementMode()
                return self.cameraMovementMode
            end
            
            function BaseCamera:SetIsMouseLocked(mouseLocked)
                self.inMouseLockedMode = mouseLocked
                if not FFlagUserCameraToggle then
                    self:UpdateMouseBehavior()
                end
            end
            
            function BaseCamera:GetIsMouseLocked()
                return self.inMouseLockedMode
            end
            
            function BaseCamera:SetMouseLockOffset(offsetVector)
                self.mouseLockOffset = offsetVector
            end
            
            function BaseCamera:GetMouseLockOffset()
                return self.mouseLockOffset
            end
            
            function BaseCamera:InFirstPerson()
                return self.inFirstPerson
            end
            
            function BaseCamera:EnterFirstPerson()
                -- Overridden in ClassicCamera, the only module which supports FirstPerson
            end
            
            function BaseCamera:LeaveFirstPerson()
                -- Overridden in ClassicCamera, the only module which supports FirstPerson
            end
            
            -- Nominal distance, set by dollying in and out with the mouse wheel or equivalent, not measured distance
            function BaseCamera:GetCameraToSubjectDistance()
                return self.currentSubjectDistance
            end
            
            -- Actual measured distance to the camera Focus point, which may be needed in special circumstances, but should
            -- never be used as the starting point for updating the nominal camera-to-subject distance (self.currentSubjectDistance)
            -- since that is a desired target value set only by mouse wheel (or equivalent) input, PopperCam, and clamped to min max camera distance
            function BaseCamera:GetMeasuredDistanceToFocus()
                local camera = game.Workspace.CurrentCamera
                if camera then
                    return (camera.CoordinateFrame.p - camera.Focus.p).magnitude
                end
                return nil
            end
            
            function BaseCamera:GetCameraLookVector()
                return game.Workspace.CurrentCamera and game.Workspace.CurrentCamera.CFrame.lookVector or UNIT_Z
            end
            
            -- Replacements for RootCamera:RotateCamera() which did not actually rotate the camera
            -- suppliedLookVector is not normally passed in, it's used only by Watch camera
            function BaseCamera:CalculateNewLookCFrame(suppliedLookVector)
                local currLookVector = suppliedLookVector or self:GetCameraLookVector()
                local currPitchAngle = math.asin(currLookVector.y)
                local yTheta = math.clamp(self.rotateInput.y, -MAX_Y + currPitchAngle, -MIN_Y + currPitchAngle)
                local constrainedRotateInput = Vector2.new(self.rotateInput.x, yTheta)
                local startCFrame = CFrame.new(ZERO_VECTOR3, currLookVector)
                local newLookCFrame = CFrame.Angles(0, -constrainedRotateInput.x, 0) * startCFrame * CFrame.Angles(-constrainedRotateInput.y,0,0)
                return newLookCFrame
            end
            function BaseCamera:CalculateNewLookVector(suppliedLookVector)
                local newLookCFrame = self:CalculateNewLookCFrame(suppliedLookVector)
                return newLookCFrame.lookVector
            end
            
            function BaseCamera:CalculateNewLookVectorVR()
                local subjectPosition = self:GetSubjectPosition()
                local vecToSubject = (subjectPosition - game.Workspace.CurrentCamera.CFrame.p)
                local currLookVector = (vecToSubject * X1_Y0_Z1).unit
                local vrRotateInput = Vector2.new(self.rotateInput.x, 0)
                local startCFrame = CFrame.new(ZERO_VECTOR3, currLookVector)
                local yawRotatedVector = (CFrame.Angles(0, -vrRotateInput.x, 0) * startCFrame * CFrame.Angles(-vrRotateInput.y,0,0)).lookVector
                return (yawRotatedVector * X1_Y0_Z1).unit
            end
            
            function BaseCamera:GetHumanoid()
                local character = player and player.Character
                if character then
                    local resultHumanoid = self.humanoidCache[player]
                    if resultHumanoid and resultHumanoid.Parent == character then
                        return resultHumanoid
                    else
                        self.humanoidCache[player] = nil -- Bust Old Cache
                        local humanoid = character:FindFirstChildOfClass("Humanoid")
                        if humanoid then
                            self.humanoidCache[player] = humanoid
                        end
                        return humanoid
                    end
                end
                return nil
            end
            
            function BaseCamera:GetHumanoidPartToFollow(humanoid, humanoidStateType)
                if humanoidStateType == Enum.HumanoidStateType.Dead then
                    local character = humanoid.Parent
                    if character then
                        return character:FindFirstChild("Head") or humanoid.Torso
                    else
                        return humanoid.Torso
                    end
                else
                    return humanoid.Torso
                end
            end
            
            function BaseCamera:UpdateGamepad()
                local gamepadPan = self.gamepadPanningCamera
                if gamepadPan and (self.hasGameLoaded or not VRService.VREnabled) then
                    gamepadPan = Util.GamepadLinearToCurve(gamepadPan)
                    local currentTime = tick()
                    if gamepadPan.X ~= 0 or gamepadPan.Y ~= 0 then
                        self.userPanningTheCamera = true
                    elseif gamepadPan == ZERO_VECTOR2 then
                        self.lastThumbstickRotate = nil
                        if self.lastThumbstickPos == ZERO_VECTOR2 then
                            self.currentSpeed = 0
                        end
                    end
            
                    local finalConstant = 0
            
                    if self.lastThumbstickRotate then
                        if VRService.VREnabled then
                            self.currentSpeed = self.vrMaxSpeed
                        else
                            local elapsedTime = (currentTime - self.lastThumbstickRotate) * 10
                            self.currentSpeed = self.currentSpeed + (self.maxSpeed * ((elapsedTime*elapsedTime)/self.numOfSeconds))
            
                            if self.currentSpeed > self.maxSpeed then self.currentSpeed = self.maxSpeed end
            
                            if self.lastVelocity then
                                local velocity = (gamepadPan - self.lastThumbstickPos)/(currentTime - self.lastThumbstickRotate)
                                local velocityDeltaMag = (velocity - self.lastVelocity).magnitude
            
                                if velocityDeltaMag > 12 then
                                    self.currentSpeed = self.currentSpeed * (20/velocityDeltaMag)
                                    if self.currentSpeed > self.maxSpeed then self.currentSpeed = self.maxSpeed end
                                end
                            end
                        end
            
                        finalConstant = UserGameSettings.GamepadCameraSensitivity * self.currentSpeed
                        self.lastVelocity = (gamepadPan - self.lastThumbstickPos)/(currentTime - self.lastThumbstickRotate)
                    end
            
                    self.lastThumbstickPos = gamepadPan
                    self.lastThumbstickRotate = currentTime
            
                    return Vector2.new( gamepadPan.X * finalConstant, gamepadPan.Y * finalConstant * self.ySensitivity * UserGameSettings:GetCameraYInvertValue())
                end
            
                return ZERO_VECTOR2
            end
            
            -- [[ VR Support Section ]] --
            
            function BaseCamera:ApplyVRTransform()
                if not VRService.VREnabled then
                    return
                end
            
                --we only want this to happen in first person VR
                local rootJoint = self.humanoidRootPart and self.humanoidRootPart:FindFirstChild("RootJoint")
                if not rootJoint then
                    return
                end
            
                local cameraSubject = game.Workspace.CurrentCamera.CameraSubject
                local isInVehicle = cameraSubject and cameraSubject:IsA("VehicleSeat")
            
                if self.inFirstPerson and not isInVehicle then
                    local vrFrame = VRService:GetUserCFrame(Enum.UserCFrame.Head)
                    local vrRotation = vrFrame - vrFrame.p
                    rootJoint.C0 = CFrame.new(vrRotation:vectorToObjectSpace(vrFrame.p)) * CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
                else
                    rootJoint.C0 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
                end
            end
            
            function BaseCamera:IsInFirstPerson()
                return self.inFirstPerson
            end
            
            function BaseCamera:ShouldUseVRRotation()
                if not VRService.VREnabled then
                    return false
                end
            
                if not self.VRRotationIntensityAvailable and tick() - self.lastVRRotationIntensityCheckTime < 1 then
                    return false
                end
            
                local success, vrRotationIntensity = pcall(function() return StarterGui:GetCore("VRRotationIntensity") end)
                self.VRRotationIntensityAvailable = success and vrRotationIntensity ~= nil
                self.lastVRRotationIntensityCheckTime = tick()
            
                self.shouldUseVRRotation = success and vrRotationIntensity ~= nil and vrRotationIntensity ~= "Smooth"
            
                return self.shouldUseVRRotation
            end
            
            function BaseCamera:GetVRRotationInput()
                local vrRotateSum = ZERO_VECTOR2
                local success, vrRotationIntensity = pcall(function() return StarterGui:GetCore("VRRotationIntensity") end)
            
                if not success then
                    return
                end
            
                local vrGamepadRotation = self.GamepadPanningCamera or ZERO_VECTOR2
                local delayExpired = (tick() - self.lastVRRotationTime) >= self:GetRepeatDelayValue(vrRotationIntensity)
            
                if math.abs(vrGamepadRotation.x) >= self:GetActivateValue() then
                    if (delayExpired or not self.vrRotateKeyCooldown[Enum.KeyCode.Thumbstick2]) then
                        local sign = 1
                        if vrGamepadRotation.x < 0 then
                            sign = -1
                        end
                        vrRotateSum = vrRotateSum + self:GetRotateAmountValue(vrRotationIntensity) * sign
                        self.vrRotateKeyCooldown[Enum.KeyCode.Thumbstick2] = true
                    end
                elseif math.abs(vrGamepadRotation.x) < self:GetActivateValue() - 0.1 then
                    self.vrRotateKeyCooldown[Enum.KeyCode.Thumbstick2] = nil
                end
                if self.turningLeft then
                    if delayExpired or not self.vrRotateKeyCooldown[Enum.KeyCode.Left] then
                        vrRotateSum = vrRotateSum - self:GetRotateAmountValue(vrRotationIntensity)
                        self.vrRotateKeyCooldown[Enum.KeyCode.Left] = true
                    end
                else
                    self.vrRotateKeyCooldown[Enum.KeyCode.Left] = nil
                end
                if self.turningRight then
                    if (delayExpired or not self.vrRotateKeyCooldown[Enum.KeyCode.Right]) then
                        vrRotateSum = vrRotateSum + self:GetRotateAmountValue(vrRotationIntensity)
                        self.vrRotateKeyCooldown[Enum.KeyCode.Right] = true
                    end
                else
                    self.vrRotateKeyCooldown[Enum.KeyCode.Right] = nil
                end
            
                if vrRotateSum ~= ZERO_VECTOR2 then
                    self.lastVRRotationTime = tick()
                end
            
                return vrRotateSum
            end
            
            function BaseCamera:CancelCameraFreeze(keepConstraints)
                if not keepConstraints then
                    self.cameraTranslationConstraints = Vector3.new(self.cameraTranslationConstraints.x, 1, self.cameraTranslationConstraints.z)
                end
                if self.cameraFrozen then
                    self.trackingHumanoid = nil
                    self.cameraFrozen = false
                end
            end
            
            function BaseCamera:StartCameraFreeze(subjectPosition, humanoidToTrack)
                if not self.cameraFrozen then
                    self.humanoidJumpOrigin = subjectPosition
                    self.trackingHumanoid = humanoidToTrack
                    self.cameraTranslationConstraints = Vector3.new(self.cameraTranslationConstraints.x, 0, self.cameraTranslationConstraints.z)
                    self.cameraFrozen = true
                end
            end
            
            function BaseCamera:OnNewCameraSubject()
                if self.subjectStateChangedConn then
                    self.subjectStateChangedConn:Disconnect()
                    self.subjectStateChangedConn = nil
                end
            
                local humanoid = workspace.CurrentCamera and workspace.CurrentCamera.CameraSubject
                if self.trackingHumanoid ~= humanoid then
                    self:CancelCameraFreeze()
                end
                if humanoid and humanoid:IsA("Humanoid") then
                    self.subjectStateChangedConn = humanoid.StateChanged:Connect(function(oldState, newState)
                        if VRService.VREnabled and newState == Enum.HumanoidStateType.Jumping and not self.inFirstPerson then
                            self:StartCameraFreeze(self:GetSubjectPosition(), humanoid)
                        elseif newState ~= Enum.HumanoidStateType.Jumping and newState ~= Enum.HumanoidStateType.Freefall then
                            self:CancelCameraFreeze(true)
                        end
                    end)
                end
            end
            
            function BaseCamera:GetVRFocus(subjectPosition, timeDelta)
                local lastFocus = self.LastCameraFocus or subjectPosition
                if not self.cameraFrozen then
                    self.cameraTranslationConstraints = Vector3.new(self.cameraTranslationConstraints.x, math.min(1, self.cameraTranslationConstraints.y + 0.42 * timeDelta), self.cameraTranslationConstraints.z)
                end
            
                local newFocus
                if self.cameraFrozen and self.humanoidJumpOrigin and self.humanoidJumpOrigin.y > lastFocus.y then
                    newFocus = CFrame.new(Vector3.new(subjectPosition.x, math.min(self.humanoidJumpOrigin.y, lastFocus.y + 5 * timeDelta), subjectPosition.z))
                else
                    newFocus = CFrame.new(Vector3.new(subjectPosition.x, lastFocus.y, subjectPosition.z):lerp(subjectPosition, self.cameraTranslationConstraints.y))
                end
            
                if self.cameraFrozen then
                    -- No longer in 3rd person
                    if self.inFirstPerson then -- not VRService.VREnabled
                        self:CancelCameraFreeze()
                    end
                    -- This case you jumped off a cliff and want to keep your character in view
                    -- 0.5 is to fix floating point error when not jumping off cliffs
                    if self.humanoidJumpOrigin and subjectPosition.y < (self.humanoidJumpOrigin.y - 0.5) then
                        self:CancelCameraFreeze()
                    end
                end
            
                return newFocus
            end
            
            function BaseCamera:GetRotateAmountValue(vrRotationIntensity)
                vrRotationIntensity = vrRotationIntensity or StarterGui:GetCore("VRRotationIntensity")
                if vrRotationIntensity then
                    if vrRotationIntensity == "Low" then
                        return VR_LOW_INTENSITY_ROTATION
                    elseif vrRotationIntensity == "High" then
                        return VR_HIGH_INTENSITY_ROTATION
                    end
                end
                return ZERO_VECTOR2
            end
            
            function BaseCamera:GetRepeatDelayValue(vrRotationIntensity)
                vrRotationIntensity = vrRotationIntensity or StarterGui:GetCore("VRRotationIntensity")
                if vrRotationIntensity then
                    if vrRotationIntensity == "Low" then
                        return VR_LOW_INTENSITY_REPEAT
                    elseif vrRotationIntensity == "High" then
                        return VR_HIGH_INTENSITY_REPEAT
                    end
                end
                return 0
            end
            
            function BaseCamera:Update(dt)
                error("BaseCamera:Update() This is a virtual function that should never be getting called.", 2)
            end
            
            BaseCamera.UpCFrame = CFrame.new()
            
            function BaseCamera:UpdateUpCFrame(cf)
                self.UpCFrame = cf
            end
            local ZERO = Vector3.new(0, 0, 0)
            function BaseCamera:CalculateNewLookCFrame(suppliedLookVector)
                local currLookVector = suppliedLookVector or self:GetCameraLookVector()
                currLookVector = self.UpCFrame:VectorToObjectSpace(currLookVector)
                
                local currPitchAngle = math.asin(currLookVector.y)
                local yTheta = math.clamp(self.rotateInput.y, -MAX_Y + currPitchAngle, -MIN_Y + currPitchAngle)
                local constrainedRotateInput = Vector2.new(self.rotateInput.x, yTheta)
                local startCFrame = CFrame.new(ZERO, currLookVector)
                local newLookCFrame = CFrame.Angles(0, -constrainedRotateInput.x, 0) * startCFrame * CFrame.Angles(-constrainedRotateInput.y,0,0)
                
                return newLookCFrame
            end
            
            return BaseCamera
        end
        
        function _BaseOcclusion()
            --[[ The Module ]]--
            local BaseOcclusion = {}
            BaseOcclusion.__index = BaseOcclusion
            setmetatable(BaseOcclusion, {
                __call = function(_, ...)
                    return BaseOcclusion.new(...)
                end
            })
            
            function BaseOcclusion.new()
                local self = setmetatable({}, BaseOcclusion)
                return self
            end
            
            -- Called when character is added
            function BaseOcclusion:CharacterAdded(char, player)
            end
            
            -- Called when character is about to be removed
            function BaseOcclusion:CharacterRemoving(char, player)
            end
            
            function BaseOcclusion:OnCameraSubjectChanged(newSubject)
            end
            
            --[[ Derived classes are required to override and implement all of the following functions ]]--
            function BaseOcclusion:GetOcclusionMode()
                -- Must be overridden in derived classes to return an Enum.DevCameraOcclusionMode value
                warn("BaseOcclusion GetOcclusionMode must be overridden by derived classes")
                return nil
            end
            
            function BaseOcclusion:Enable(enabled)
                warn("BaseOcclusion Enable must be overridden by derived classes")
            end
            
            function BaseOcclusion:Update(dt, desiredCameraCFrame, desiredCameraFocus)
                warn("BaseOcclusion Update must be overridden by derived classes")
                return desiredCameraCFrame, desiredCameraFocus
            end
            
            return BaseOcclusion
        end
        
        function _Popper()
            
            local Players = game:GetService("Players")
            
            local camera = game.Workspace.CurrentCamera
            
            local min = math.min
            local tan = math.tan
            local rad = math.rad
            local inf = math.huge
            local ray = Ray.new
            
            local function getTotalTransparency(part)
                return 1 - (1 - part.Transparency)*(1 - part.LocalTransparencyModifier)
            end
            
            local function eraseFromEnd(t, toSize)
                for i = #t, toSize + 1, -1 do
                    t[i] = nil
                end
            end
            
            local nearPlaneZ, projX, projY do
                local function updateProjection()
                    local fov = rad(camera.FieldOfView)
                    local view = camera.ViewportSize
                    local ar = view.X/view.Y
            
                    projY = 2*tan(fov/2)
                    projX = ar*projY
                end
            
                camera:GetPropertyChangedSignal("FieldOfView"):Connect(updateProjection)
                camera:GetPropertyChangedSignal("ViewportSize"):Connect(updateProjection)
            
                updateProjection()
            
                nearPlaneZ = camera.NearPlaneZ
                camera:GetPropertyChangedSignal("NearPlaneZ"):Connect(function()
                    nearPlaneZ = camera.NearPlaneZ
                end)
            end
            
            local blacklist = {} do
                local charMap = {}
            
                local function refreshIgnoreList()
                    local n = 1
                    blacklist = {}
                    for _, character in pairs(charMap) do
                        blacklist[n] = character
                        n = n + 1
                    end
                end
            
                local function playerAdded(player)
                    local function characterAdded(character)
                        charMap[player] = character
                        refreshIgnoreList()
                    end
                    local function characterRemoving()
                        charMap[player] = nil
                        refreshIgnoreList()
                    end
            
                    player.CharacterAdded:Connect(characterAdded)
                    player.CharacterRemoving:Connect(characterRemoving)
                    if player.Character then
                        characterAdded(player.Character)
                    end
                end
            
                local function playerRemoving(player)
                    charMap[player] = nil
                    refreshIgnoreList()
                end
            
                Players.PlayerAdded:Connect(playerAdded)
                Players.PlayerRemoving:Connect(playerRemoving)
            
                for _, player in ipairs(Players:GetPlayers()) do
                    playerAdded(player)
                end
                refreshIgnoreList()
            end
            
            --------------------------------------------------------------------------------------------
            -- Popper uses the level geometry find an upper bound on subject-to-camera distance.
            --
            -- Hard limits are applied immediately and unconditionally. They are generally caused
            -- when level geometry intersects with the near plane (with exceptions, see below).
            --
            -- Soft limits are only applied under certain conditions.
            -- They are caused when level geometry occludes the subject without actually intersecting
            -- with the near plane at the target distance.
            --
            -- Soft limits can be promoted to hard limits and hard limits can be demoted to soft limits.
            -- We usually don"t want the latter to happen.
            --
            -- A soft limit will be promoted to a hard limit if an obstruction
            -- lies between the current and target camera positions.
            --------------------------------------------------------------------------------------------
            
            local subjectRoot
            local subjectPart
            
            camera:GetPropertyChangedSignal("CameraSubject"):Connect(function()
                local subject = camera.CameraSubject
                if subject:IsA("Humanoid") then
                    subjectPart = subject.RootPart
                elseif subject:IsA("BasePart") then
                    subjectPart = subject
                else
                    subjectPart = nil
                end
            end)
            
            local function canOcclude(part)
                -- Occluders must be:
                -- 1. Opaque
                -- 2. Interactable
                -- 3. Not in the same assembly as the subject
            
                return
                    getTotalTransparency(part) < 0.25 and
                    part.CanCollide and
                    subjectRoot ~= (part:GetRootPart() or part) and
                    not part:IsA("TrussPart")
            end
            
            -- Offsets for the volume visibility test
            local SCAN_SAMPLE_OFFSETS = {
                Vector2.new( 0.4, 0.0),
                Vector2.new(-0.4, 0.0),
                Vector2.new( 0.0,-0.4),
                Vector2.new( 0.0, 0.4),
                Vector2.new( 0.0, 0.2),
            }
            
            --------------------------------------------------------------------------------
            -- Piercing raycasts
            
            local function getCollisionPoint(origin, dir)
                local originalSize = #blacklist
                repeat
                    local hitPart, hitPoint = workspace:FindPartOnRayWithIgnoreList(
                        ray(origin, dir), blacklist, false, true
                    )
            
                    if hitPart then
                        if hitPart.CanCollide then
                            eraseFromEnd(blacklist, originalSize)
                            return hitPoint, true
                        end
                        blacklist[#blacklist + 1] = hitPart
                    end
                until not hitPart
            
                eraseFromEnd(blacklist, originalSize)
                return origin + dir, false
            end
            
            --------------------------------------------------------------------------------
            
            local function queryPoint(origin, unitDir, dist, lastPos)
                debug.profilebegin("queryPoint")
            
                local originalSize = #blacklist
            
                dist = dist + nearPlaneZ
                local target = origin + unitDir*dist
            
                local softLimit = inf
                local hardLimit = inf
                local movingOrigin = origin
            
                repeat
                    local entryPart, entryPos = workspace:FindPartOnRayWithIgnoreList(ray(movingOrigin, target - movingOrigin), blacklist, false, true)
            
                    if entryPart then
                        if canOcclude(entryPart) then
                            local wl = {entryPart}
                            local exitPart = workspace:FindPartOnRayWithWhitelist(ray(target, entryPos - target), wl, true)
            
                            local lim = (entryPos - origin).Magnitude
            
                            if exitPart then
                                local promote = false
                                if lastPos then
                                    promote =
                                        workspace:FindPartOnRayWithWhitelist(ray(lastPos, target - lastPos), wl, true) or
                                        workspace:FindPartOnRayWithWhitelist(ray(target, lastPos - target), wl, true)
                                end
            
                                if promote then
                                    -- Ostensibly a soft limit, but the camera has passed through it in the last frame, so promote to a hard limit.
                                    hardLimit = lim
                                elseif dist < softLimit then
                                    -- Trivial soft limit
                                    softLimit = lim
                                end
                            else
                                -- Trivial hard limit
                                hardLimit = lim
                            end
                        end
            
                        blacklist[#blacklist + 1] = entryPart
                        movingOrigin = entryPos - unitDir*1e-3
                    end
                until hardLimit < inf or not entryPart
            
                eraseFromEnd(blacklist, originalSize)
            
                debug.profileend()
                return softLimit - nearPlaneZ, hardLimit - nearPlaneZ
            end
            
            local function queryViewport(focus, dist)
                debug.profilebegin("queryViewport")
            
                local fP =  focus.p
                local fX =  focus.rightVector
                local fY =  focus.upVector
                local fZ = -focus.lookVector
            
                local viewport = camera.ViewportSize
            
                local hardBoxLimit = inf
                local softBoxLimit = inf
            
                -- Center the viewport on the PoI, sweep points on the edge towards the target, and take the minimum limits
                for viewX = 0, 1 do
                    local worldX = fX*((viewX - 0.5)*projX)
            
                    for viewY = 0, 1 do
                        local worldY = fY*((viewY - 0.5)*projY)
            
                        local origin = fP + nearPlaneZ*(worldX + worldY)
                        local lastPos = camera:ViewportPointToRay(
                            viewport.x*viewX,
                            viewport.y*viewY
                        ).Origin
            
                        local softPointLimit, hardPointLimit = queryPoint(origin, fZ, dist, lastPos)
            
                        if hardPointLimit < hardBoxLimit then
                            hardBoxLimit = hardPointLimit
                        end
                        if softPointLimit < softBoxLimit then
                            softBoxLimit = softPointLimit
                        end
                    end
                end
                debug.profileend()
            
                return softBoxLimit, hardBoxLimit
            end
            
            local function testPromotion(focus, dist, focusExtrapolation)
                debug.profilebegin("testPromotion")
            
                local fP = focus.p
                local fX = focus.rightVector
                local fY = focus.upVector
                local fZ = -focus.lookVector
            
                do
                    -- Dead reckoning the camera rotation and focus
                    debug.profilebegin("extrapolate")
            
                    local SAMPLE_DT = 0.0625
                    local SAMPLE_MAX_T = 1.25
            
                    local maxDist = (getCollisionPoint(fP, focusExtrapolation.posVelocity*SAMPLE_MAX_T) - fP).Magnitude
                    -- Metric that decides how many samples to take
                    local combinedSpeed = focusExtrapolation.posVelocity.magnitude
            
                    for dt = 0, min(SAMPLE_MAX_T, focusExtrapolation.rotVelocity.magnitude + maxDist/combinedSpeed), SAMPLE_DT do
                        local cfDt = focusExtrapolation.extrapolate(dt) -- Extrapolated CFrame at time dt
            
                        if queryPoint(cfDt.p, -cfDt.lookVector, dist) >= dist then
                            return false
                        end
                    end
            
                    debug.profileend()
                end
            
                do
                    -- Test screen-space offsets from the focus for the presence of soft limits
                    debug.profilebegin("testOffsets")
            
                    for _, offset in ipairs(SCAN_SAMPLE_OFFSETS) do
                        local scaledOffset = offset
                        local pos = getCollisionPoint(fP, fX*scaledOffset.x + fY*scaledOffset.y)
                        if queryPoint(pos, (fP + fZ*dist - pos).Unit, dist) == inf then
                            return false
                        end
                    end
            
                    debug.profileend()
                end
            
                debug.profileend()
                return true
            end
            
            local function Popper(focus, targetDist, focusExtrapolation)
                debug.profilebegin("popper")
            
                subjectRoot = subjectPart and subjectPart:GetRootPart() or subjectPart
            
                local dist = targetDist
                local soft, hard = queryViewport(focus, targetDist)
                if hard < dist then
                    dist = hard
                end
                if soft < dist and testPromotion(focus, targetDist, focusExtrapolation) then
                    dist = soft
                end
            
                subjectRoot = nil
            
                debug.profileend()
                return dist
            end
            
            return Popper
        end
        
        function _ZoomController()
            local ZOOM_STIFFNESS = 4.5
            local ZOOM_DEFAULT = 12.5
            local ZOOM_ACCELERATION = 0.0375
            
            local MIN_FOCUS_DIST = 0.5
            local DIST_OPAQUE = 1
            
            local Popper = _Popper()
            
            local clamp = math.clamp
            local exp = math.exp
            local min = math.min
            local max = math.max
            local pi = math.pi
            
            local cameraMinZoomDistance, cameraMaxZoomDistance do
                local Player = game:GetService("Players").LocalPlayer
            
                local function updateBounds()
                    cameraMinZoomDistance = Player.CameraMinZoomDistance
                    cameraMaxZoomDistance = Player.CameraMaxZoomDistance
                end
            
                updateBounds()
            
                Player:GetPropertyChangedSignal("CameraMinZoomDistance"):Connect(updateBounds)
                Player:GetPropertyChangedSignal("CameraMaxZoomDistance"):Connect(updateBounds)
            end
            
            local ConstrainedSpring = {} do
                ConstrainedSpring.__index = ConstrainedSpring
            
                function ConstrainedSpring.new(freq, x, minValue, maxValue)
                    x = clamp(x, minValue, maxValue)
                    return setmetatable({
                        freq = freq, -- Undamped frequency (Hz)
                        x = x, -- Current position
                        v = 0, -- Current velocity
                        minValue = minValue, -- Minimum bound
                        maxValue = maxValue, -- Maximum bound
                        goal = x, -- Goal position
                    }, ConstrainedSpring)
                end
            
                function ConstrainedSpring:Step(dt)
                    local freq = self.freq*2*pi -- Convert from Hz to rad/s
                    local x = self.x
                    local v = self.v
                    local minValue = self.minValue
                    local maxValue = self.maxValue
                    local goal = self.goal
            
                    -- Solve the spring ODE for position and velocity after time t, assuming critical damping:
                    --   2*f*x'[t] + x''[t] = f^2*(g - x[t])
                    -- Knowns are x[0] and x'[0].
                    -- Solve for x[t] and x'[t].
            
                    local offset = goal - x
                    local step = freq*dt
                    local decay = exp(-step)
            
                    local x1 = goal + (v*dt - offset*(step + 1))*decay
                    local v1 = ((offset*freq - v)*step + v)*decay
            
                    -- Constrain
                    if x1 < minValue then
                        x1 = minValue
                        v1 = 0
                    elseif x1 > maxValue then
                        x1 = maxValue
                        v1 = 0
                    end
            
                    self.x = x1
                    self.v = v1
            
                    return x1
                end
            end
            
            local zoomSpring = ConstrainedSpring.new(ZOOM_STIFFNESS, ZOOM_DEFAULT, MIN_FOCUS_DIST, cameraMaxZoomDistance)
            
            local function stepTargetZoom(z, dz, zoomMin, zoomMax)
                z = clamp(z + dz*(1 + z*ZOOM_ACCELERATION), zoomMin, zoomMax)
                if z < DIST_OPAQUE then
                    z = dz <= 0 and zoomMin or DIST_OPAQUE
                end
                return z
            end
            
            local zoomDelta = 0
            
            local Zoom = {} do
                function Zoom.Update(renderDt, focus, extrapolation)
                    local poppedZoom = math.huge
            
                    if zoomSpring.goal > DIST_OPAQUE then
                        -- Make a pessimistic estimate of zoom distance for this step without accounting for poppercam
                        local maxPossibleZoom = max(
                            zoomSpring.x,
                            stepTargetZoom(zoomSpring.goal, zoomDelta, cameraMinZoomDistance, cameraMaxZoomDistance)
                        )
            
                        -- Run the Popper algorithm on the feasible zoom range, [MIN_FOCUS_DIST, maxPossibleZoom]
                        poppedZoom = Popper(
                            focus*CFrame.new(0, 0, MIN_FOCUS_DIST),
                            maxPossibleZoom - MIN_FOCUS_DIST,
                            extrapolation
                        ) + MIN_FOCUS_DIST
                    end
            
                    zoomSpring.minValue = MIN_FOCUS_DIST
                    zoomSpring.maxValue = min(cameraMaxZoomDistance, poppedZoom)
            
                    return zoomSpring:Step(renderDt)
                end
            
                function Zoom.SetZoomParameters(targetZoom, newZoomDelta)
                    zoomSpring.goal = targetZoom
                    zoomDelta = newZoomDelta
                end
            end
            
            return Zoom
        end
        
        function _MouseLockController()
            --[[ Constants ]]--
            local DEFAULT_MOUSE_LOCK_CURSOR = "rbxasset://textures/MouseLockedCursor.png"
            
            local CONTEXT_ACTION_NAME = "MouseLockSwitchAction"
            local MOUSELOCK_ACTION_PRIORITY = Enum.ContextActionPriority.Default.Value
            
            --[[ Services ]]--
            local PlayersService = game:GetService("Players")
            local ContextActionService = game:GetService("ContextActionService")
            local Settings = UserSettings()	-- ignore warning
            local GameSettings = Settings.GameSettings
            local Mouse = PlayersService.LocalPlayer:GetMouse()
            
            --[[ The Module ]]--
            local MouseLockController = {}
            MouseLockController.__index = MouseLockController
            
            function MouseLockController.new()
                local self = setmetatable({}, MouseLockController)
            
                self.isMouseLocked = false
                self.savedMouseCursor = nil
                self.boundKeys = {Enum.KeyCode.LeftShift, Enum.KeyCode.RightShift} -- defaults
            
                self.mouseLockToggledEvent = Instance.new("BindableEvent")
            
                local boundKeysObj = script:FindFirstChild("BoundKeys")
                if (not boundKeysObj) or (not boundKeysObj:IsA("StringValue")) then
                    -- If object with correct name was found, but it's not a StringValue, destroy and replace
                    if boundKeysObj then
                        boundKeysObj:Destroy()
                    end
            
                    boundKeysObj = Instance.new("StringValue")
                    boundKeysObj.Name = "BoundKeys"
                    boundKeysObj.Value = "LeftShift,RightShift"
                    boundKeysObj.Parent = script
                end
            
                if boundKeysObj then
                    boundKeysObj.Changed:Connect(function(value)
                        self:OnBoundKeysObjectChanged(value)
                    end)
                    self:OnBoundKeysObjectChanged(boundKeysObj.Value) -- Initial setup call
                end
            
                -- Watch for changes to user's ControlMode and ComputerMovementMode settings and update the feature availability accordingly
                GameSettings.Changed:Connect(function(property)
                    if property == "ControlMode" or property == "ComputerMovementMode" then
                        self:UpdateMouseLockAvailability()
                    end
                end)
            
                -- Watch for changes to DevEnableMouseLock and update the feature availability accordingly
                PlayersService.LocalPlayer:GetPropertyChangedSignal("DevEnableMouseLock"):Connect(function()
                    self:UpdateMouseLockAvailability()
                end)
            
                -- Watch for changes to DevEnableMouseLock and update the feature availability accordingly
                PlayersService.LocalPlayer:GetPropertyChangedSignal("DevComputerMovementMode"):Connect(function()
                    self:UpdateMouseLockAvailability()
                end)
            
                self:UpdateMouseLockAvailability()
            
                return self
            end
            
            function MouseLockController:GetIsMouseLocked()
                return self.isMouseLocked
            end
            
            function MouseLockController:GetBindableToggleEvent()
                return self.mouseLockToggledEvent.Event
            end
            
            function MouseLockController:GetMouseLockOffset()
                local offsetValueObj = script:FindFirstChild("CameraOffset")
                if offsetValueObj and offsetValueObj:IsA("Vector3Value") then
                    return offsetValueObj.Value
                else
                    -- If CameraOffset object was found but not correct type, destroy
                    if offsetValueObj then
                        offsetValueObj:Destroy()
                    end
                    offsetValueObj = Instance.new("Vector3Value")
                    offsetValueObj.Name = "CameraOffset"
                    offsetValueObj.Value = Vector3.new(1.75,0,0) -- Legacy Default Value
                    offsetValueObj.Parent = script
                end
            
                if offsetValueObj and offsetValueObj.Value then
                    return offsetValueObj.Value
                end
            
                return Vector3.new(1.75,0,0)
            end
            
            function MouseLockController:UpdateMouseLockAvailability()
                local devAllowsMouseLock = PlayersService.LocalPlayer.DevEnableMouseLock
                local devMovementModeIsScriptable = PlayersService.LocalPlayer.DevComputerMovementMode == Enum.DevComputerMovementMode.Scriptable
                local userHasMouseLockModeEnabled = GameSettings.ControlMode == Enum.ControlMode.MouseLockSwitch
                local userHasClickToMoveEnabled =  GameSettings.ComputerMovementMode == Enum.ComputerMovementMode.ClickToMove
                local MouseLockAvailable = devAllowsMouseLock and userHasMouseLockModeEnabled and not userHasClickToMoveEnabled and not devMovementModeIsScriptable
            
                if MouseLockAvailable~=self.enabled then
                    self:EnableMouseLock(MouseLockAvailable)
                end
            end
            
            function MouseLockController:OnBoundKeysObjectChanged(newValue)
                self.boundKeys = {} -- Overriding defaults, note: possibly with nothing at all if boundKeysObj.Value is "" or contains invalid values
                for token in string.gmatch(newValue,"[^%s,]+") do
                    for _, keyEnum in pairs(Enum.KeyCode:GetEnumItems()) do
                        if token == keyEnum.Name then
                            self.boundKeys[#self.boundKeys+1] = keyEnum
                            break
                        end
                    end
                end
                self:UnbindContextActions()
                self:BindContextActions()
            end
            
            --[[ Local Functions ]]--
            function MouseLockController:OnMouseLockToggled()
                self.isMouseLocked = not self.isMouseLocked
            
                if self.isMouseLocked then
                    local cursorImageValueObj = script:FindFirstChild("CursorImage")
                    if cursorImageValueObj and cursorImageValueObj:IsA("StringValue") and cursorImageValueObj.Value then
                        self.savedMouseCursor = Mouse.Icon
                        Mouse.Icon = cursorImageValueObj.Value
                    else
                        if cursorImageValueObj then
                            cursorImageValueObj:Destroy()
                        end
                        cursorImageValueObj = Instance.new("StringValue")
                        cursorImageValueObj.Name = "CursorImage"
                        cursorImageValueObj.Value = DEFAULT_MOUSE_LOCK_CURSOR
                        cursorImageValueObj.Parent = script
                        self.savedMouseCursor = Mouse.Icon
                        Mouse.Icon = DEFAULT_MOUSE_LOCK_CURSOR
                    end
                else
                    if self.savedMouseCursor then
                        Mouse.Icon = self.savedMouseCursor
                        self.savedMouseCursor = nil
                    end
                end
            
                self.mouseLockToggledEvent:Fire()
            end
            
            function MouseLockController:DoMouseLockSwitch(name, state, input)
                if state == Enum.UserInputState.Begin then
                    self:OnMouseLockToggled()
                    return Enum.ContextActionResult.Sink
                end
                return Enum.ContextActionResult.Pass
            end
            
            function MouseLockController:BindContextActions()
                ContextActionService:BindActionAtPriority(CONTEXT_ACTION_NAME, function(name, state, input)
                    return self:DoMouseLockSwitch(name, state, input)
                end, false, MOUSELOCK_ACTION_PRIORITY, unpack(self.boundKeys))
            end
            
            function MouseLockController:UnbindContextActions()
                ContextActionService:UnbindAction(CONTEXT_ACTION_NAME)
            end
            
            function MouseLockController:IsMouseLocked()
                return self.enabled and self.isMouseLocked
            end
            
            function MouseLockController:EnableMouseLock(enable)
                if enable ~= self.enabled then
            
                    self.enabled = enable
            
                    if self.enabled then
                        -- Enabling the mode
                        self:BindContextActions()
                    else
                        -- Disabling
                        -- Restore mouse cursor
                        if Mouse.Icon~="" then
                            Mouse.Icon = ""
                        end
            
                        self:UnbindContextActions()
            
                        -- If the mode is disabled while being used, fire the event to toggle it off
                        if self.isMouseLocked then
                            self.mouseLockToggledEvent:Fire()
                        end
            
                        self.isMouseLocked = false
                    end
            
                end
            end
            
            return MouseLockController
        end
        
        function _TransparencyController()
            
            local MAX_TWEEN_RATE = 2.8 -- per second
            
            local Util = _CameraUtils()
            
            --[[ The Module ]]--
            local TransparencyController = {}
            TransparencyController.__index = TransparencyController
            
            function TransparencyController.new()
                local self = setmetatable({}, TransparencyController)
            
                self.lastUpdate = tick()
                self.transparencyDirty = false
                self.enabled = false
                self.lastTransparency = nil
            
                self.descendantAddedConn, self.descendantRemovingConn = nil, nil
                self.toolDescendantAddedConns = {}
                self.toolDescendantRemovingConns = {}
                self.cachedParts = {}
            
                return self
            end
            
            
            function TransparencyController:HasToolAncestor(object)
                if object.Parent == nil then return false end
                return object.Parent:IsA('Tool') or self:HasToolAncestor(object.Parent)
            end
            
            function TransparencyController:IsValidPartToModify(part)
                if part:IsA('BasePart') or part:IsA('Decal') then
                    return not self:HasToolAncestor(part)
                end
                return false
            end
            
            function TransparencyController:CachePartsRecursive(object)
                if object then
                    if self:IsValidPartToModify(object) then
                        self.cachedParts[object] = true
                        self.transparencyDirty = true
                    end
                    for _, child in pairs(object:GetChildren()) do
                        self:CachePartsRecursive(child)
                    end
                end
            end
            
            function TransparencyController:TeardownTransparency()
                for child, _ in pairs(self.cachedParts) do
                    child.LocalTransparencyModifier = 0
                end
                self.cachedParts = {}
                self.transparencyDirty = true
                self.lastTransparency = nil
            
                if self.descendantAddedConn then
                    self.descendantAddedConn:disconnect()
                    self.descendantAddedConn = nil
                end
                if self.descendantRemovingConn then
                    self.descendantRemovingConn:disconnect()
                    self.descendantRemovingConn = nil
                end
                for object, conn in pairs(self.toolDescendantAddedConns) do
                    conn:Disconnect()
                    self.toolDescendantAddedConns[object] = nil
                end
                for object, conn in pairs(self.toolDescendantRemovingConns) do
                    conn:Disconnect()
                    self.toolDescendantRemovingConns[object] = nil
                end
            end
            
            function TransparencyController:SetupTransparency(character)
                self:TeardownTransparency()
            
                if self.descendantAddedConn then self.descendantAddedConn:disconnect() end
                self.descendantAddedConn = character.DescendantAdded:Connect(function(object)
                    -- This is a part we want to invisify
                    if self:IsValidPartToModify(object) then
                        self.cachedParts[object] = true
                        self.transparencyDirty = true
                    -- There is now a tool under the character
                    elseif object:IsA('Tool') then
                        if self.toolDescendantAddedConns[object] then self.toolDescendantAddedConns[object]:Disconnect() end
                        self.toolDescendantAddedConns[object] = object.DescendantAdded:Connect(function(toolChild)
                            self.cachedParts[toolChild] = nil
                            if toolChild:IsA('BasePart') or toolChild:IsA('Decal') then
                                -- Reset the transparency
                                toolChild.LocalTransparencyModifier = 0
                            end
                        end)
                        if self.toolDescendantRemovingConns[object] then self.toolDescendantRemovingConns[object]:disconnect() end
                        self.toolDescendantRemovingConns[object] = object.DescendantRemoving:Connect(function(formerToolChild)
                            wait() -- wait for new parent
                            if character and formerToolChild and formerToolChild:IsDescendantOf(character) then
                                if self:IsValidPartToModify(formerToolChild) then
                                    self.cachedParts[formerToolChild] = true
                                    self.transparencyDirty = true
                                end
                            end
                        end)
                    end
                end)
                if self.descendantRemovingConn then self.descendantRemovingConn:disconnect() end
                self.descendantRemovingConn = character.DescendantRemoving:connect(function(object)
                    if self.cachedParts[object] then
                        self.cachedParts[object] = nil
                        -- Reset the transparency
                        object.LocalTransparencyModifier = 0
                    end
                end)
                self:CachePartsRecursive(character)
            end
            
            
            function TransparencyController:Enable(enable)
                if self.enabled ~= enable then
                    self.enabled = enable
                    self:Update()
                end
            end
            
            function TransparencyController:SetSubject(subject)
                local character = nil
                if subject and subject:IsA("Humanoid") then
                    character = subject.Parent
                end
                if subject and subject:IsA("VehicleSeat") and subject.Occupant then
                    character = subject.Occupant.Parent
                end
                if character then
                    self:SetupTransparency(character)
                else
                    self:TeardownTransparency()
                end
            end
            
            function TransparencyController:Update()
                local instant = false
                local now = tick()
                local currentCamera = workspace.CurrentCamera
            
                if currentCamera then
                    local transparency = 0
                    if not self.enabled then
                        instant = true
                    else
                        local distance = (currentCamera.Focus.p - currentCamera.CoordinateFrame.p).magnitude
                        transparency = (distance<2) and (1.0-(distance-0.5)/1.5) or 0 --(7 - distance) / 5
                        if transparency < 0.5 then
                            transparency = 0
                        end
            
                        if self.lastTransparency then
                            local deltaTransparency = transparency - self.lastTransparency
            
                            -- Don't tween transparency if it is instant or your character was fully invisible last frame
                            if not instant and transparency < 1 and self.lastTransparency < 0.95 then
                                local maxDelta = MAX_TWEEN_RATE * (now - self.lastUpdate)
                                deltaTransparency = math.clamp(deltaTransparency, -maxDelta, maxDelta)
                            end
                            transparency = self.lastTransparency + deltaTransparency
                        else
                            self.transparencyDirty = true
                        end
            
                        transparency = math.clamp(Util.Round(transparency, 2), 0, 1)
                    end
            
                    if self.transparencyDirty or self.lastTransparency ~= transparency then
                        for child, _ in pairs(self.cachedParts) do
                            child.LocalTransparencyModifier = transparency
                        end
                        self.transparencyDirty = false
                        self.lastTransparency = transparency
                    end
                end
                self.lastUpdate = now
            end
            
            return TransparencyController
        end
        
        function _Poppercam()
            local ZoomController =  _ZoomController()
            
            local TransformExtrapolator = {} do
                TransformExtrapolator.__index = TransformExtrapolator
            
                local CF_IDENTITY = CFrame.new()
            
                local function cframeToAxis(cframe)
                    local axis, angle = cframe:toAxisAngle()
                    return axis*angle
                end
            
                local function axisToCFrame(axis)
                    local angle = axis.magnitude
                    if angle > 1e-5 then
                        return CFrame.fromAxisAngle(axis, angle)
                    end
                    return CF_IDENTITY
                end
            
                local function extractRotation(cf)
                    local _, _, _, xx, yx, zx, xy, yy, zy, xz, yz, zz = cf:components()
                    return CFrame.new(0, 0, 0, xx, yx, zx, xy, yy, zy, xz, yz, zz)
                end
            
                function TransformExtrapolator.new()
                    return setmetatable({
                        lastCFrame = nil,
                    }, TransformExtrapolator)
                end
            
                function TransformExtrapolator:Step(dt, currentCFrame)
                    local lastCFrame = self.lastCFrame or currentCFrame
                    self.lastCFrame = currentCFrame
            
                    local currentPos = currentCFrame.p
                    local currentRot = extractRotation(currentCFrame)
            
                    local lastPos = lastCFrame.p
                    local lastRot = extractRotation(lastCFrame)
            
                    -- Estimate velocities from the delta between now and the last frame
                    -- This estimation can be a little noisy.
                    local dp = (currentPos - lastPos)/dt
                    local dr = cframeToAxis(currentRot*lastRot:inverse())/dt
            
                    local function extrapolate(t)
                        local p = dp*t + currentPos
                        local r = axisToCFrame(dr*t)*currentRot
                        return r + p
                    end
            
                    return {
                        extrapolate = extrapolate,
                        posVelocity = dp,
                        rotVelocity = dr,
                    }
                end
            
                function TransformExtrapolator:Reset()
                    self.lastCFrame = nil
                end
            end
            
            --[[ The Module ]]--
            local BaseOcclusion = _BaseOcclusion()
            local Poppercam = setmetatable({}, BaseOcclusion)
            Poppercam.__index = Poppercam
            
            function Poppercam.new()
                local self = setmetatable(BaseOcclusion.new(), Poppercam)
                self.focusExtrapolator = TransformExtrapolator.new()
                return self
            end
            
            function Poppercam:GetOcclusionMode()
                return Enum.DevCameraOcclusionMode.Zoom
            end
            
            function Poppercam:Enable(enable)
                self.focusExtrapolator:Reset()
            end
            
            function Poppercam:Update(renderDt, desiredCameraCFrame, desiredCameraFocus, cameraController)
                local rotatedFocus = CFrame.new(desiredCameraFocus.p, desiredCameraCFrame.p)*CFrame.new(
                    0, 0, 0,
                    -1, 0, 0,
                    0, 1, 0,
                    0, 0, -1
                )
                local extrapolation = self.focusExtrapolator:Step(renderDt, rotatedFocus)
                local zoom = ZoomController.Update(renderDt, rotatedFocus, extrapolation)
                return rotatedFocus*CFrame.new(0, 0, zoom), desiredCameraFocus
            end
            
            -- Called when character is added
            function Poppercam:CharacterAdded(character, player)
            end
            
            -- Called when character is about to be removed
            function Poppercam:CharacterRemoving(character, player)
            end
            
            function Poppercam:OnCameraSubjectChanged(newSubject)
            end
            
            local ZoomController = _ZoomController()
            
            function Poppercam:Update(renderDt, desiredCameraCFrame, desiredCameraFocus, cameraController)
                local rotatedFocus = desiredCameraFocus * (desiredCameraCFrame - desiredCameraCFrame.p)
                local extrapolation = self.focusExtrapolator:Step(renderDt, rotatedFocus)
                local zoom = ZoomController.Update(renderDt, rotatedFocus, extrapolation)
                return rotatedFocus*CFrame.new(0, 0, zoom), desiredCameraFocus
            end
            
            return Poppercam
        end
        
        function _Invisicam()
            
            --[[ Top Level Roblox Services ]]--
            local PlayersService = game:GetService("Players")
            
            --[[ Constants ]]--
            local ZERO_VECTOR3 = Vector3.new(0,0,0)
            local USE_STACKING_TRANSPARENCY = true	-- Multiple items between the subject and camera get transparency values that add up to TARGET_TRANSPARENCY
            local TARGET_TRANSPARENCY = 0.75 -- Classic Invisicam's Value, also used by new invisicam for parts hit by head and torso rays
            local TARGET_TRANSPARENCY_PERIPHERAL = 0.5 -- Used by new SMART_CIRCLE mode for items not hit by head and torso rays
            
            local MODE = {
                --CUSTOM = 1, 		-- Retired, unused
                LIMBS = 2, 			-- Track limbs
                MOVEMENT = 3, 		-- Track movement
                CORNERS = 4, 		-- Char model corners
                CIRCLE1 = 5, 		-- Circle of casts around character
                CIRCLE2 = 6, 		-- Circle of casts around character, camera relative
                LIMBMOVE = 7, 		-- LIMBS mode + MOVEMENT mode
                SMART_CIRCLE = 8, 	-- More sample points on and around character
                CHAR_OUTLINE = 9,	-- Dynamic outline around the character
            }
            
            local LIMB_TRACKING_SET = {
                -- Body parts common to R15 and R6
                ['Head'] = true,
            
                -- Body parts unique to R6
                ['Left Arm'] = true,
                ['Right Arm'] = true,
                ['Left Leg'] = true,
                ['Right Leg'] = true,
            
                -- Body parts unique to R15
                ['LeftLowerArm'] = true,
                ['RightLowerArm'] = true,
                ['LeftUpperLeg'] = true,
                ['RightUpperLeg'] = true
            }
            
            local CORNER_FACTORS = {
                Vector3.new(1,1,-1),
                Vector3.new(1,-1,-1),
                Vector3.new(-1,-1,-1),
                Vector3.new(-1,1,-1)
            }
            
            local CIRCLE_CASTS = 10
            local MOVE_CASTS = 3
            local SMART_CIRCLE_CASTS = 24
            local SMART_CIRCLE_INCREMENT = 2.0 * math.pi / SMART_CIRCLE_CASTS
            local CHAR_OUTLINE_CASTS = 24
            
            -- Used to sanitize user-supplied functions
            local function AssertTypes(param, ...)
                local allowedTypes = {}
                local typeString = ''
                for _, typeName in pairs({...}) do
                    allowedTypes[typeName] = true
                    typeString = typeString .. (typeString == '' and '' or ' or ') .. typeName
                end
                local theType = type(param)
                assert(allowedTypes[theType], typeString .. " type expected, got: " .. theType)
            end
            
            -- Helper function for Determinant of 3x3, not in CameraUtils for performance reasons
            local function Det3x3(a,b,c,d,e,f,g,h,i)
                return (a*(e*i-f*h)-b*(d*i-f*g)+c*(d*h-e*g))
            end
            
            -- Smart Circle mode needs the intersection of 2 rays that are known to be in the same plane
            -- because they are generated from cross products with a common vector. This function is computing
            -- that intersection, but it's actually the general solution for the point halfway between where
            -- two skew lines come nearest to each other, which is more forgiving.
            local function RayIntersection(p0, v0, p1, v1)
                local v2 = v0:Cross(v1)
                local d1 = p1.x - p0.x
                local d2 = p1.y - p0.y
                local d3 = p1.z - p0.z
                local denom = Det3x3(v0.x,-v1.x,v2.x,v0.y,-v1.y,v2.y,v0.z,-v1.z,v2.z)
            
                if (denom == 0) then
                    return ZERO_VECTOR3 -- No solution (rays are parallel)
                end
            
                local t0 = Det3x3(d1,-v1.x,v2.x,d2,-v1.y,v2.y,d3,-v1.z,v2.z) / denom
                local t1 = Det3x3(v0.x,d1,v2.x,v0.y,d2,v2.y,v0.z,d3,v2.z) / denom
                local s0 = p0 + t0 * v0
                local s1 = p1 + t1 * v1
                local s = s0 + 0.5 * ( s1 - s0 )
            
                -- 0.25 studs is a threshold for deciding if the rays are
                -- close enough to be considered intersecting, found through testing 
                if (s1-s0).Magnitude < 0.25 then
                    return s
                else
                    return ZERO_VECTOR3
                end
            end
            
            
            
            --[[ The Module ]]--
            local BaseOcclusion = _BaseOcclusion()
            local Invisicam = setmetatable({}, BaseOcclusion)
            Invisicam.__index = Invisicam
            
            function Invisicam.new()
                local self = setmetatable(BaseOcclusion.new(), Invisicam)
            
                self.char = nil
                self.humanoidRootPart = nil
                self.torsoPart = nil
                self.headPart = nil
            
                self.childAddedConn = nil
                self.childRemovedConn = nil
            
                self.behaviors = {} 	-- Map of modes to behavior fns
                self.behaviors[MODE.LIMBS] = self.LimbBehavior
                self.behaviors[MODE.MOVEMENT] = self.MoveBehavior
                self.behaviors[MODE.CORNERS] = self.CornerBehavior
                self.behaviors[MODE.CIRCLE1] = self.CircleBehavior
                self.behaviors[MODE.CIRCLE2] = self.CircleBehavior
                self.behaviors[MODE.LIMBMOVE] = self.LimbMoveBehavior
                self.behaviors[MODE.SMART_CIRCLE] = self.SmartCircleBehavior
                self.behaviors[MODE.CHAR_OUTLINE] = self.CharacterOutlineBehavior
            
                self.mode = MODE.SMART_CIRCLE
                self.behaviorFunction = self.SmartCircleBehavior
            
                self.savedHits = {} 	-- Objects currently being faded in/out
                self.trackedLimbs = {}	-- Used in limb-tracking casting modes
            
                self.camera = game.Workspace.CurrentCamera
            
                self.enabled = false
                return self
            end
            
            function Invisicam:Enable(enable)
                self.enabled = enable
            
                if not enable then
                    self:Cleanup()
                end
            end
            
            function Invisicam:GetOcclusionMode()
                return Enum.DevCameraOcclusionMode.Invisicam
            end
            
            --[[ Module functions ]]--
            function Invisicam:LimbBehavior(castPoints)
                for limb, _ in pairs(self.trackedLimbs) do
                    castPoints[#castPoints + 1] = limb.Position
                end
            end
            
            function Invisicam:MoveBehavior(castPoints)
                for i = 1, MOVE_CASTS do
                    local position, velocity = self.humanoidRootPart.Position, self.humanoidRootPart.Velocity
                    local horizontalSpeed = Vector3.new(velocity.X, 0, velocity.Z).Magnitude / 2
                    local offsetVector = (i - 1) * self.humanoidRootPart.CFrame.lookVector * horizontalSpeed
                    castPoints[#castPoints + 1] = position + offsetVector
                end
            end
            
            function Invisicam:CornerBehavior(castPoints)
                local cframe = self.humanoidRootPart.CFrame
                local centerPoint = cframe.p
                local rotation = cframe - centerPoint
                local halfSize = self.char:GetExtentsSize() / 2 --NOTE: Doesn't update w/ limb animations
                castPoints[#castPoints + 1] = centerPoint
                for i = 1, #CORNER_FACTORS do
                    castPoints[#castPoints + 1] = centerPoint + (rotation * (halfSize * CORNER_FACTORS[i]))
                end
            end
            
            function Invisicam:CircleBehavior(castPoints)
                local cframe
                if self.mode == MODE.CIRCLE1 then
                    cframe = self.humanoidRootPart.CFrame
                else
                    local camCFrame = self.camera.CoordinateFrame
                    cframe = camCFrame - camCFrame.p + self.humanoidRootPart.Position
                end
                castPoints[#castPoints + 1] = cframe.p
                for i = 0, CIRCLE_CASTS - 1 do
                    local angle = (2 * math.pi / CIRCLE_CASTS) * i
                    local offset = 3 * Vector3.new(math.cos(angle), math.sin(angle), 0)
                    castPoints[#castPoints + 1] = cframe * offset
                end
            end
            
            function Invisicam:LimbMoveBehavior(castPoints)
                self:LimbBehavior(castPoints)
                self:MoveBehavior(castPoints)
            end
            
            function Invisicam:CharacterOutlineBehavior(castPoints)
                local torsoUp = self.torsoPart.CFrame.upVector.unit
                local torsoRight = self.torsoPart.CFrame.rightVector.unit
            
                -- Torso cross of points for interior coverage
                castPoints[#castPoints + 1] = self.torsoPart.CFrame.p
                castPoints[#castPoints + 1] = self.torsoPart.CFrame.p + torsoUp
                castPoints[#castPoints + 1] = self.torsoPart.CFrame.p - torsoUp
                castPoints[#castPoints + 1] = self.torsoPart.CFrame.p + torsoRight
                castPoints[#castPoints + 1] = self.torsoPart.CFrame.p - torsoRight
                if self.headPart then
                    castPoints[#castPoints + 1] = self.headPart.CFrame.p
                end
            
                local cframe = CFrame.new(ZERO_VECTOR3,Vector3.new(self.camera.CoordinateFrame.lookVector.X,0,self.camera.CoordinateFrame.lookVector.Z))
                local centerPoint = (self.torsoPart and self.torsoPart.Position or self.humanoidRootPart.Position)
            
                local partsWhitelist = {self.torsoPart}
                if self.headPart then
                    partsWhitelist[#partsWhitelist + 1] = self.headPart
                end
            
                for i = 1, CHAR_OUTLINE_CASTS do
                    local angle = (2 * math.pi * i / CHAR_OUTLINE_CASTS)
                    local offset = cframe * (3 * Vector3.new(math.cos(angle), math.sin(angle), 0))
            
                    offset = Vector3.new(offset.X, math.max(offset.Y, -2.25), offset.Z)	
            
                    local ray = Ray.new(centerPoint + offset, -3 * offset)
                    local hit, hitPoint = game.Workspace:FindPartOnRayWithWhitelist(ray, partsWhitelist, false, false)
            
                    if hit then
                        -- Use hit point as the cast point, but nudge it slightly inside the character so that bumping up against
                        -- walls is less likely to cause a transparency glitch
                        castPoints[#castPoints + 1] = hitPoint + 0.2 * (centerPoint - hitPoint).unit
                    end
                end
            end
            
            function Invisicam:SmartCircleBehavior(castPoints)
                local torsoUp = self.torsoPart.CFrame.upVector.unit
                local torsoRight = self.torsoPart.CFrame.rightVector.unit
            
                -- SMART_CIRCLE mode includes rays to head and 5 to the torso.
                -- Hands, arms, legs and feet are not included since they
                -- are not canCollide and can therefore go inside of parts
                castPoints[#castPoints + 1] = self.torsoPart.CFrame.p
                castPoints[#castPoints + 1] = self.torsoPart.CFrame.p + torsoUp
                castPoints[#castPoints + 1] = self.torsoPart.CFrame.p - torsoUp
                castPoints[#castPoints + 1] = self.torsoPart.CFrame.p + torsoRight
                castPoints[#castPoints + 1] = self.torsoPart.CFrame.p - torsoRight
                if self.headPart then
                    castPoints[#castPoints + 1] = self.headPart.CFrame.p
                end
            
                local cameraOrientation = self.camera.CFrame - self.camera.CFrame.p
                local torsoPoint = Vector3.new(0,0.5,0) + (self.torsoPart and self.torsoPart.Position or self.humanoidRootPart.Position)
                local radius = 2.5
            
                -- This loop first calculates points in a circle of radius 2.5 around the torso of the character, in the
                -- plane orthogonal to the camera's lookVector. Each point is then raycast to, to determine if it is within
                -- the free space surrounding the player (not inside anything). Two iterations are done to adjust points that
                -- are inside parts, to try to move them to valid locations that are still on their camera ray, so that the
                -- circle remains circular from the camera's perspective, but does not cast rays into walls or parts that are
                -- behind, below or beside the character and not really obstructing view of the character. This minimizes
                -- the undesirable situation where the character walks up to an exterior wall and it is made invisible even
                -- though it is behind the character.
                for i = 1, SMART_CIRCLE_CASTS do
                    local angle = SMART_CIRCLE_INCREMENT * i - 0.5 * math.pi
                    local offset = radius * Vector3.new(math.cos(angle), math.sin(angle), 0)
                    local circlePoint = torsoPoint + cameraOrientation * offset
            
                    -- Vector from camera to point on the circle being tested
                    local vp = circlePoint - self.camera.CFrame.p
            
                    local ray = Ray.new(torsoPoint, circlePoint - torsoPoint)
                    local hit, hp, hitNormal = game.Workspace:FindPartOnRayWithIgnoreList(ray, {self.char}, false, false )
                    local castPoint = circlePoint
            
                    if hit then
                        local hprime = hp + 0.1 * hitNormal.unit -- Slightly offset hit point from the hit surface
                        local v0 = hprime - torsoPoint -- Vector from torso to offset hit point
            
                        local perp = (v0:Cross(vp)).unit
            
                        -- Vector from the offset hit point, along the hit surface
                        local v1 = (perp:Cross(hitNormal)).unit
            
                        -- Vector from camera to offset hit
                        local vprime = (hprime - self.camera.CFrame.p).unit
            
                        -- This dot product checks to see if the vector along the hit surface would hit the correct
                        -- side of the invisicam cone, or if it would cross the camera look vector and hit the wrong side
                        if ( v0.unit:Dot(-v1) < v0.unit:Dot(vprime)) then
                            castPoint = RayIntersection(hprime, v1, circlePoint, vp)
            
                            if castPoint.Magnitude > 0 then
                                local ray = Ray.new(hprime, castPoint - hprime)
                                local hit, hitPoint, hitNormal = game.Workspace:FindPartOnRayWithIgnoreList(ray, {self.char}, false, false )
            
                                if hit then
                                    local hprime2 = hitPoint + 0.1 * hitNormal.unit
                                    castPoint = hprime2
                                end
                            else
                                castPoint = hprime
                            end
                        else
                            castPoint = hprime
                        end
            
                        local ray = Ray.new(torsoPoint, (castPoint - torsoPoint))
                        local hit, hitPoint, hitNormal = game.Workspace:FindPartOnRayWithIgnoreList(ray, {self.char}, false, false )
            
                        if hit then
                            local castPoint2 = hitPoint - 0.1 * (castPoint - torsoPoint).unit
                            castPoint = castPoint2
                        end
                    end
            
                    castPoints[#castPoints + 1] = castPoint
                end
            end
            
            function Invisicam:CheckTorsoReference()
                if self.char then
                    self.torsoPart = self.char:FindFirstChild("Torso")
                    if not self.torsoPart then
                        self.torsoPart = self.char:FindFirstChild("UpperTorso")
                        if not self.torsoPart then
                            self.torsoPart = self.char:FindFirstChild("HumanoidRootPart")
                        end
                    end
            
                    self.headPart = self.char:FindFirstChild("Head")
                end
            end
            
            function Invisicam:CharacterAdded(char, player)
                -- We only want the LocalPlayer's character
                if player~=PlayersService.LocalPlayer then return end
            
                if self.childAddedConn then
                    self.childAddedConn:Disconnect()
                    self.childAddedConn = nil
                end
                if self.childRemovedConn then
                    self.childRemovedConn:Disconnect()
                    self.childRemovedConn = nil
                end
            
                self.char = char
            
                self.trackedLimbs = {}
                local function childAdded(child)
                    if child:IsA("BasePart") then
                        if LIMB_TRACKING_SET[child.Name] then
                            self.trackedLimbs[child] = true
                        end
            
                        if child.Name == "Torso" or child.Name == "UpperTorso" then
                            self.torsoPart = child
                        end
            
                        if child.Name == "Head" then
                            self.headPart = child
                        end
                    end
                end
            
                local function childRemoved(child)
                    self.trackedLimbs[child] = nil
            
                    -- If removed/replaced part is 'Torso' or 'UpperTorso' double check that we still have a TorsoPart to use
                    self:CheckTorsoReference()
                end
            
                self.childAddedConn = char.ChildAdded:Connect(childAdded)
                self.childRemovedConn = char.ChildRemoved:Connect(childRemoved)
                for _, child in pairs(self.char:GetChildren()) do
                    childAdded(child)
                end
            end
            
            function Invisicam:SetMode(newMode)
                AssertTypes(newMode, 'number')
                for _, modeNum in pairs(MODE) do
                    if modeNum == newMode then
                        self.mode = newMode
                        self.behaviorFunction = self.behaviors[self.mode]
                        return
                    end
                end
                error("Invalid mode number")
            end
            
            function Invisicam:GetObscuredParts()
                return self.savedHits
            end
            
            -- Want to turn off Invisicam? Be sure to call this after.
            function Invisicam:Cleanup()
                for hit, originalFade in pairs(self.savedHits) do
                    hit.LocalTransparencyModifier = originalFade
                end
            end
            
            function Invisicam:Update(dt, desiredCameraCFrame, desiredCameraFocus)
                -- Bail if there is no Character
                if not self.enabled or not self.char then
                    return desiredCameraCFrame, desiredCameraFocus
                end
            
                self.camera = game.Workspace.CurrentCamera
            
                -- TODO: Move this to a GetHumanoidRootPart helper, probably combine with CheckTorsoReference
                -- Make sure we still have a HumanoidRootPart
                if not self.humanoidRootPart then
                    local humanoid = self.char:FindFirstChildOfClass("Humanoid")
                    if humanoid and humanoid.RootPart then
                        self.humanoidRootPart = humanoid.RootPart
                    else
                        -- Not set up with Humanoid? Try and see if there's one in the Character at all:
                        self.humanoidRootPart = self.char:FindFirstChild("HumanoidRootPart")
                        if not self.humanoidRootPart then
                            -- Bail out, since we're relying on HumanoidRootPart existing
                            return desiredCameraCFrame, desiredCameraFocus
                        end
                    end
            
                    -- TODO: Replace this with something more sensible
                    local ancestryChangedConn
                    ancestryChangedConn = self.humanoidRootPart.AncestryChanged:Connect(function(child, parent)
                        if child == self.humanoidRootPart and not parent then 
                            self.humanoidRootPart = nil
                            if ancestryChangedConn and ancestryChangedConn.Connected then
                                ancestryChangedConn:Disconnect()
                                ancestryChangedConn = nil
                            end
                        end
                    end)
                end
            
                if not self.torsoPart then
                    self:CheckTorsoReference()
                    if not self.torsoPart then
                        -- Bail out, since we're relying on Torso existing, should never happen since we fall back to using HumanoidRootPart as torso
                        return desiredCameraCFrame, desiredCameraFocus
                    end
                end
            
                -- Make a list of world points to raycast to
                local castPoints = {}
                self.behaviorFunction(self, castPoints)
            
                -- Cast to get a list of objects between the camera and the cast points
                local currentHits = {}
                local ignoreList = {self.char}
                local function add(hit)
                    currentHits[hit] = true
                    if not self.savedHits[hit] then
                        self.savedHits[hit] = hit.LocalTransparencyModifier
                    end
                end
            
                local hitParts
                local hitPartCount = 0
            
                -- Hash table to treat head-ray-hit parts differently than the rest of the hit parts hit by other rays
                -- head/torso ray hit parts will be more transparent than peripheral parts when USE_STACKING_TRANSPARENCY is enabled
                local headTorsoRayHitParts = {}
            
                local perPartTransparencyHeadTorsoHits = TARGET_TRANSPARENCY
                local perPartTransparencyOtherHits = TARGET_TRANSPARENCY
            
                if USE_STACKING_TRANSPARENCY then
            
                    -- This first call uses head and torso rays to find out how many parts are stacked up
                    -- for the purpose of calculating required per-part transparency
                    local headPoint = self.headPart and self.headPart.CFrame.p or castPoints[1]
                    local torsoPoint = self.torsoPart and self.torsoPart.CFrame.p or castPoints[2]
                    hitParts = self.camera:GetPartsObscuringTarget({headPoint, torsoPoint}, ignoreList)
            
                    -- Count how many things the sample rays passed through, including decals. This should only
                    -- count decals facing the camera, but GetPartsObscuringTarget does not return surface normals,
                    -- so my compromise for now is to just let any decal increase the part count by 1. Only one
                    -- decal per part will be considered.
                    for i = 1, #hitParts do
                        local hitPart = hitParts[i]
                        hitPartCount = hitPartCount + 1 -- count the part itself
                        headTorsoRayHitParts[hitPart] = true
                        for _, child in pairs(hitPart:GetChildren()) do
                            if child:IsA('Decal') or child:IsA('Texture') then
                                hitPartCount = hitPartCount + 1 -- count first decal hit, then break
                                break
                            end
                        end
                    end
            
                    if (hitPartCount > 0) then
                        perPartTransparencyHeadTorsoHits = math.pow( ((0.5 * TARGET_TRANSPARENCY) + (0.5 * TARGET_TRANSPARENCY / hitPartCount)), 1 / hitPartCount )
                        perPartTransparencyOtherHits = math.pow( ((0.5 * TARGET_TRANSPARENCY_PERIPHERAL) + (0.5 * TARGET_TRANSPARENCY_PERIPHERAL / hitPartCount)), 1 / hitPartCount )
                    end
                end
            
                -- Now get all the parts hit by all the rays
                hitParts = self.camera:GetPartsObscuringTarget(castPoints, ignoreList)
            
                local partTargetTransparency = {}
            
                -- Include decals and textures
                for i = 1, #hitParts do
                    local hitPart = hitParts[i]
            
                    partTargetTransparency[hitPart] =headTorsoRayHitParts[hitPart] and perPartTransparencyHeadTorsoHits or perPartTransparencyOtherHits
            
                    -- If the part is not already as transparent or more transparent than what invisicam requires, add it to the list of
                    -- parts to be modified by invisicam
                    if hitPart.Transparency < partTargetTransparency[hitPart] then
                        add(hitPart)
                    end
            
                    -- Check all decals and textures on the part
                    for _, child in pairs(hitPart:GetChildren()) do
                        if child:IsA('Decal') or child:IsA('Texture') then
                            if (child.Transparency < partTargetTransparency[hitPart]) then
                                partTargetTransparency[child] = partTargetTransparency[hitPart]
                                add(child)
                            end
                        end
                    end
                end
            
                -- Invisibilize objects that are in the way, restore those that aren't anymore
                for hitPart, originalLTM in pairs(self.savedHits) do
                    if currentHits[hitPart] then
                        -- LocalTransparencyModifier gets whatever value is required to print the part's total transparency to equal perPartTransparency
                        hitPart.LocalTransparencyModifier = (hitPart.Transparency < 1) and ((partTargetTransparency[hitPart] - hitPart.Transparency) / (1.0 - hitPart.Transparency)) or 0
                    else -- Restore original pre-invisicam value of LTM
                        hitPart.LocalTransparencyModifier = originalLTM
                        self.savedHits[hitPart] = nil
                    end
                end
            
                -- Invisicam does not change the camera values
                return desiredCameraCFrame, desiredCameraFocus
            end
            
            return Invisicam
        end
        
        function _LegacyCamera()
            
            local ZERO_VECTOR2 = Vector2.new(0,0)
            
            local Util = _CameraUtils()
            
            --[[ Services ]]--
            local PlayersService = game:GetService('Players')
            
            --[[ The Module ]]--
            local BaseCamera = _BaseCamera()
            local LegacyCamera = setmetatable({}, BaseCamera)
            LegacyCamera.__index = LegacyCamera
            
            function LegacyCamera.new()
                local self = setmetatable(BaseCamera.new(), LegacyCamera)
            
                self.cameraType = Enum.CameraType.Fixed
                self.lastUpdate = tick()
                self.lastDistanceToSubject = nil
            
                return self
            end
            
            function LegacyCamera:GetModuleName()
                return "LegacyCamera"
            end
            
            --[[ Functions overridden from BaseCamera ]]--
            function LegacyCamera:SetCameraToSubjectDistance(desiredSubjectDistance)
                return BaseCamera.SetCameraToSubjectDistance(self,desiredSubjectDistance)
            end
            
            function LegacyCamera:Update(dt)
            
                -- Cannot update until cameraType has been set
                if not self.cameraType then return end
            
                local now = tick()
                local timeDelta = (now - self.lastUpdate)
                local camera = 	workspace.CurrentCamera
                local newCameraCFrame = camera.CFrame
                local newCameraFocus = camera.Focus
                local player = PlayersService.LocalPlayer
            
                if self.lastUpdate == nil or timeDelta > 1 then
                    self.lastDistanceToSubject = nil
                end
                local subjectPosition = self:GetSubjectPosition()
            
                if self.cameraType == Enum.CameraType.Fixed then
                    if self.lastUpdate then
                        -- Cap out the delta to 0.1 so we don't get some crazy things when we re-resume from
                        local delta = math.min(0.1, now - self.lastUpdate)
                        local gamepadRotation = self:UpdateGamepad()
                        self.rotateInput = self.rotateInput + (gamepadRotation * delta)
                    end
            
                    if subjectPosition and player and camera then
                        local distanceToSubject = self:GetCameraToSubjectDistance()
                        local newLookVector = self:CalculateNewLookVector()
                        self.rotateInput = ZERO_VECTOR2
            
                        newCameraFocus = camera.Focus -- Fixed camera does not change focus
                        newCameraCFrame = CFrame.new(camera.CFrame.p, camera.CFrame.p + (distanceToSubject * newLookVector))
                    end
                elseif self.cameraType == Enum.CameraType.Attach then
                    if subjectPosition and camera then
                        local distanceToSubject = self:GetCameraToSubjectDistance()
                        local humanoid = self:GetHumanoid()
                        if self.lastUpdate and humanoid and humanoid.RootPart then
            
                            -- Cap out the delta to 0.1 so we don't get some crazy things when we re-resume from
                            local delta = math.min(0.1, now - self.lastUpdate)
                            local gamepadRotation = self:UpdateGamepad()
                            self.rotateInput = self.rotateInput + (gamepadRotation * delta)
            
                            local forwardVector = humanoid.RootPart.CFrame.lookVector
            
                            local y = Util.GetAngleBetweenXZVectors(forwardVector, self:GetCameraLookVector())
                            if Util.IsFinite(y) then
                                -- Preserve vertical rotation from user input
                                self.rotateInput = Vector2.new(y, self.rotateInput.Y)
                            end
                        end
            
                        local newLookVector = self:CalculateNewLookVector()
                        self.rotateInput = ZERO_VECTOR2
            
                        newCameraFocus = CFrame.new(subjectPosition)
                        newCameraCFrame = CFrame.new(subjectPosition - (distanceToSubject * newLookVector), subjectPosition)
                    end
                elseif self.cameraType == Enum.CameraType.Watch then
                    if subjectPosition and player and camera then
                        local cameraLook = nil
            
                        local humanoid = self:GetHumanoid()
                        if humanoid and humanoid.RootPart then
                            local diffVector = subjectPosition - camera.CFrame.p
                            cameraLook = diffVector.unit
            
                            if self.lastDistanceToSubject and self.lastDistanceToSubject == self:GetCameraToSubjectDistance() then
                                -- Don't clobber the zoom if they zoomed the camera
                                local newDistanceToSubject = diffVector.magnitude
                                self:SetCameraToSubjectDistance(newDistanceToSubject)
                            end
                        end
            
                        local distanceToSubject = self:GetCameraToSubjectDistance()
                        local newLookVector = self:CalculateNewLookVector(cameraLook)
                        self.rotateInput = ZERO_VECTOR2
            
                        newCameraFocus = CFrame.new(subjectPosition)
                        newCameraCFrame = CFrame.new(subjectPosition - (distanceToSubject * newLookVector), subjectPosition)
            
                        self.lastDistanceToSubject = distanceToSubject
                    end
                else
                    -- Unsupported type, return current values unchanged
                    return camera.CFrame, camera.Focus
                end
            
                self.lastUpdate = now
                return newCameraCFrame, newCameraFocus
            end
            
            return LegacyCamera
        end
        
        function _OrbitalCamera()
            
            -- Local private variables and constants
            local UNIT_Z = Vector3.new(0,0,1)
            local X1_Y0_Z1 = Vector3.new(1,0,1)	--Note: not a unit vector, used for projecting onto XZ plane
            local ZERO_VECTOR3 = Vector3.new(0,0,0)
            local ZERO_VECTOR2 = Vector2.new(0,0)
            local TAU = 2 * math.pi
            
            --[[ Gamepad Support ]]--
            local THUMBSTICK_DEADZONE = 0.2
            
            -- Do not edit these values, they are not the developer-set limits, they are limits
            -- to the values the camera system equations can correctly handle
            local MIN_ALLOWED_ELEVATION_DEG = -80
            local MAX_ALLOWED_ELEVATION_DEG = 80
            
            local externalProperties = {}
            externalProperties["InitialDistance"]  = 25
            externalProperties["MinDistance"]      = 10
            externalProperties["MaxDistance"]      = 100
            externalProperties["InitialElevation"] = 35
            externalProperties["MinElevation"]     = 35
            externalProperties["MaxElevation"]     = 35
            externalProperties["ReferenceAzimuth"] = -45	-- Angle around the Y axis where the camera starts. -45 offsets the camera in the -X and +Z directions equally
            externalProperties["CWAzimuthTravel"]  = 90	-- How many degrees the camera is allowed to rotate from the reference position, CW as seen from above
            externalProperties["CCWAzimuthTravel"] = 90	-- How many degrees the camera is allowed to rotate from the reference position, CCW as seen from above
            externalProperties["UseAzimuthLimits"] = false -- Full rotation around Y axis available by default
            
            local Util = _CameraUtils()
            
            --[[ Services ]]--
            local PlayersService = game:GetService('Players')
            local VRService = game:GetService("VRService")
            
            --[[ The Module ]]--
            local BaseCamera = _BaseCamera()
            local OrbitalCamera = setmetatable({}, BaseCamera)
            OrbitalCamera.__index = OrbitalCamera
            
            
            function OrbitalCamera.new()
                local self = setmetatable(BaseCamera.new(), OrbitalCamera)
            
                self.lastUpdate = tick()
            
                -- OrbitalCamera-specific members
                self.changedSignalConnections = {}
                self.refAzimuthRad = nil
                self.curAzimuthRad = nil
                self.minAzimuthAbsoluteRad = nil
                self.maxAzimuthAbsoluteRad = nil
                self.useAzimuthLimits = nil
                self.curElevationRad = nil
                self.minElevationRad = nil
                self.maxElevationRad = nil
                self.curDistance = nil
                self.minDistance = nil
                self.maxDistance = nil
            
                -- Gamepad
                self.r3ButtonDown = false
                self.l3ButtonDown = false
                self.gamepadDollySpeedMultiplier = 1
            
                self.lastUserPanCamera = tick()
            
                self.externalProperties = {}
                self.externalProperties["InitialDistance"] 	= 25
                self.externalProperties["MinDistance"] 		= 10
                self.externalProperties["MaxDistance"] 		= 100
                self.externalProperties["InitialElevation"] 	= 35
                self.externalProperties["MinElevation"] 		= 35
                self.externalProperties["MaxElevation"] 		= 35
                self.externalProperties["ReferenceAzimuth"] 	= -45	-- Angle around the Y axis where the camera starts. -45 offsets the camera in the -X and +Z directions equally
                self.externalProperties["CWAzimuthTravel"] 	= 90	-- How many degrees the camera is allowed to rotate from the reference position, CW as seen from above
                self.externalProperties["CCWAzimuthTravel"] 	= 90	-- How many degrees the camera is allowed to rotate from the reference position, CCW as seen from above
                self.externalProperties["UseAzimuthLimits"] 	= false -- Full rotation around Y axis available by default
                self:LoadNumberValueParameters()
            
                return self
            end
            
            function OrbitalCamera:LoadOrCreateNumberValueParameter(name, valueType, updateFunction)
                local valueObj = script:FindFirstChild(name)
            
                if valueObj and valueObj:isA(valueType) then
                    -- Value object exists and is the correct type, use its value
                    self.externalProperties[name] = valueObj.Value
                elseif self.externalProperties[name] ~= nil then
                    -- Create missing (or replace incorrectly-typed) valueObject with default value
                    valueObj = Instance.new(valueType)
                    valueObj.Name = name
                    valueObj.Parent = script
                    valueObj.Value = self.externalProperties[name]
                else
                    print("externalProperties table has no entry for ",name)
                    return
                end
            
                if updateFunction then
                    if self.changedSignalConnections[name] then
                        self.changedSignalConnections[name]:Disconnect()
                    end
                    self.changedSignalConnections[name] = valueObj.Changed:Connect(function(newValue)
                        self.externalProperties[name] = newValue
                        updateFunction(self)
                    end)
                end
            end
            
            function OrbitalCamera:SetAndBoundsCheckAzimuthValues()
                self.minAzimuthAbsoluteRad = math.rad(self.externalProperties["ReferenceAzimuth"]) - math.abs(math.rad(self.externalProperties["CWAzimuthTravel"]))
                self.maxAzimuthAbsoluteRad = math.rad(self.externalProperties["ReferenceAzimuth"]) + math.abs(math.rad(self.externalProperties["CCWAzimuthTravel"]))
                self.useAzimuthLimits = self.externalProperties["UseAzimuthLimits"]
                if self.useAzimuthLimits then
                    self.curAzimuthRad = math.max(self.curAzimuthRad, self.minAzimuthAbsoluteRad)
                    self.curAzimuthRad = math.min(self.curAzimuthRad, self.maxAzimuthAbsoluteRad)
                end
            end
            
            function OrbitalCamera:SetAndBoundsCheckElevationValues()
                -- These degree values are the direct user input values. It is deliberate that they are
                -- ranged checked only against the extremes, and not against each other. Any time one
                -- is changed, both of the internal values in radians are recalculated. This allows for
                -- A developer to change the values in any order and for the end results to be that the
                -- internal values adjust to match intent as best as possible.
                local minElevationDeg = math.max(self.externalProperties["MinElevation"], MIN_ALLOWED_ELEVATION_DEG)
                local maxElevationDeg = math.min(self.externalProperties["MaxElevation"], MAX_ALLOWED_ELEVATION_DEG)
            
                -- Set internal values in radians
                self.minElevationRad = math.rad(math.min(minElevationDeg, maxElevationDeg))
                self.maxElevationRad = math.rad(math.max(minElevationDeg, maxElevationDeg))
                self.curElevationRad = math.max(self.curElevationRad, self.minElevationRad)
                self.curElevationRad = math.min(self.curElevationRad, self.maxElevationRad)
            end
            
            function OrbitalCamera:SetAndBoundsCheckDistanceValues()
                self.minDistance = self.externalProperties["MinDistance"]
                self.maxDistance = self.externalProperties["MaxDistance"]
                self.curDistance = math.max(self.curDistance, self.minDistance)
                self.curDistance = math.min(self.curDistance, self.maxDistance)
            end
            
            -- This loads from, or lazily creates, NumberValue objects for exposed parameters
            function OrbitalCamera:LoadNumberValueParameters()
                -- These initial values do not require change listeners since they are read only once
                self:LoadOrCreateNumberValueParameter("InitialElevation", "NumberValue", nil)
                self:LoadOrCreateNumberValueParameter("InitialDistance", "NumberValue", nil)
            
                -- Note: ReferenceAzimuth is also used as an initial value, but needs a change listener because it is used in the calculation of the limits
                self:LoadOrCreateNumberValueParameter("ReferenceAzimuth", "NumberValue", self.SetAndBoundsCheckAzimuthValue)
                self:LoadOrCreateNumberValueParameter("CWAzimuthTravel", "NumberValue", self.SetAndBoundsCheckAzimuthValues)
                self:LoadOrCreateNumberValueParameter("CCWAzimuthTravel", "NumberValue", self.SetAndBoundsCheckAzimuthValues)
                self:LoadOrCreateNumberValueParameter("MinElevation", "NumberValue", self.SetAndBoundsCheckElevationValues)
                self:LoadOrCreateNumberValueParameter("MaxElevation", "NumberValue", self.SetAndBoundsCheckElevationValues)
                self:LoadOrCreateNumberValueParameter("MinDistance", "NumberValue", self.SetAndBoundsCheckDistanceValues)
                self:LoadOrCreateNumberValueParameter("MaxDistance", "NumberValue", self.SetAndBoundsCheckDistanceValues)
                self:LoadOrCreateNumberValueParameter("UseAzimuthLimits", "BoolValue", self.SetAndBoundsCheckAzimuthValues)
            
                -- Internal values set (in radians, from degrees), plus sanitization
                self.curAzimuthRad = math.rad(self.externalProperties["ReferenceAzimuth"])
                self.curElevationRad = math.rad(self.externalProperties["InitialElevation"])
                self.curDistance = self.externalProperties["InitialDistance"]
            
                self:SetAndBoundsCheckAzimuthValues()
                self:SetAndBoundsCheckElevationValues()
                self:SetAndBoundsCheckDistanceValues()
            end
            
            function OrbitalCamera:GetModuleName()
                return "OrbitalCamera"
            end
            
            function OrbitalCamera:SetInitialOrientation(humanoid)
                if not humanoid or not humanoid.RootPart then
                    warn("OrbitalCamera could not set initial orientation due to missing humanoid")
                    return
                end
                local newDesiredLook = (humanoid.RootPart.CFrame.lookVector - Vector3.new(0,0.23,0)).unit
                local horizontalShift = Util.GetAngleBetweenXZVectors(newDesiredLook, self:GetCameraLookVector())
                local vertShift = math.asin(self:GetCameraLookVector().y) - math.asin(newDesiredLook.y)
                if not Util.IsFinite(horizontalShift) then
                    horizontalShift = 0
                end
                if not Util.IsFinite(vertShift) then
                    vertShift = 0
                end
                self.rotateInput = Vector2.new(horizontalShift, vertShift)
            end
            
            --[[ Functions of BaseCamera that are overridden by OrbitalCamera ]]--
            function OrbitalCamera:GetCameraToSubjectDistance()
                return self.curDistance
            end
            
            function OrbitalCamera:SetCameraToSubjectDistance(desiredSubjectDistance)
                print("OrbitalCamera SetCameraToSubjectDistance ",desiredSubjectDistance)
                local player = PlayersService.LocalPlayer
                if player then
                    self.currentSubjectDistance = math.clamp(desiredSubjectDistance, self.minDistance, self.maxDistance)
            
                    -- OrbitalCamera is not allowed to go into the first-person range
                    self.currentSubjectDistance = math.max(self.currentSubjectDistance, self.FIRST_PERSON_DISTANCE_THRESHOLD)
                end
                self.inFirstPerson = false
                self:UpdateMouseBehavior()
                return self.currentSubjectDistance
            end
            
            function OrbitalCamera:CalculateNewLookVector(suppliedLookVector, xyRotateVector)
                local currLookVector = suppliedLookVector or self:GetCameraLookVector()
                local currPitchAngle = math.asin(currLookVector.y)
                local yTheta = math.clamp(xyRotateVector.y, currPitchAngle - math.rad(MAX_ALLOWED_ELEVATION_DEG), currPitchAngle - math.rad(MIN_ALLOWED_ELEVATION_DEG))
                local constrainedRotateInput = Vector2.new(xyRotateVector.x, yTheta)
                local startCFrame = CFrame.new(ZERO_VECTOR3, currLookVector)
                local newLookVector = (CFrame.Angles(0, -constrainedRotateInput.x, 0) * startCFrame * CFrame.Angles(-constrainedRotateInput.y,0,0)).lookVector
                return newLookVector
            end
            
            function OrbitalCamera:GetGamepadPan(name, state, input)
                if input.UserInputType == self.activeGamepad and input.KeyCode == Enum.KeyCode.Thumbstick2 then
                    if self.r3ButtonDown or self.l3ButtonDown then
                    -- R3 or L3 Thumbstick is depressed, right stick controls dolly in/out
                        if (input.Position.Y > THUMBSTICK_DEADZONE) then
                            self.gamepadDollySpeedMultiplier = 0.96
                        elseif (input.Position.Y < -THUMBSTICK_DEADZONE) then
                            self.gamepadDollySpeedMultiplier = 1.04
                        else
                            self.gamepadDollySpeedMultiplier = 1.00
                        end
                    else
                        if state == Enum.UserInputState.Cancel then
                            self.gamepadPanningCamera = ZERO_VECTOR2
                            return
                        end
            
                        local inputVector = Vector2.new(input.Position.X, -input.Position.Y)
                        if inputVector.magnitude > THUMBSTICK_DEADZONE then
                            self.gamepadPanningCamera = Vector2.new(input.Position.X, -input.Position.Y)
                        else
                            self.gamepadPanningCamera = ZERO_VECTOR2
                        end
                    end
                    return Enum.ContextActionResult.Sink
                end
                return Enum.ContextActionResult.Pass
            end
            
            function OrbitalCamera:DoGamepadZoom(name, state, input)
                if input.UserInputType == self.activeGamepad and (input.KeyCode == Enum.KeyCode.ButtonR3 or input.KeyCode == Enum.KeyCode.ButtonL3) then
                    if (state == Enum.UserInputState.Begin) then
                        self.r3ButtonDown = input.KeyCode == Enum.KeyCode.ButtonR3
                        self.l3ButtonDown = input.KeyCode == Enum.KeyCode.ButtonL3
                    elseif (state == Enum.UserInputState.End) then
                        if (input.KeyCode == Enum.KeyCode.ButtonR3) then
                            self.r3ButtonDown = false
                        elseif (input.KeyCode == Enum.KeyCode.ButtonL3) then
                            self.l3ButtonDown = false
                        end
                        if (not self.r3ButtonDown) and (not self.l3ButtonDown) then
                            self.gamepadDollySpeedMultiplier = 1.00
                        end
                    end
                    return Enum.ContextActionResult.Sink
                end
                return Enum.ContextActionResult.Pass
            end
            
            function OrbitalCamera:BindGamepadInputActions()
                self:BindAction("OrbitalCamGamepadPan", function(name, state, input) return self:GetGamepadPan(name, state, input) end,
                    false, Enum.KeyCode.Thumbstick2)
                self:BindAction("OrbitalCamGamepadZoom", function(name, state, input) return self:DoGamepadZoom(name, state, input) end,
                    false, Enum.KeyCode.ButtonR3, Enum.KeyCode.ButtonL3)
            end
            
            
            -- [[ Update ]]--
            function OrbitalCamera:Update(dt)
                local now = tick()
                local timeDelta = (now - self.lastUpdate)
                local userPanningTheCamera = (self.UserPanningTheCamera == true)
                local camera = 	workspace.CurrentCamera
                local newCameraCFrame = camera.CFrame
                local newCameraFocus = camera.Focus
                local player = PlayersService.LocalPlayer
                local cameraSubject = camera and camera.CameraSubject
                local isInVehicle = cameraSubject and cameraSubject:IsA('VehicleSeat')
                local isOnASkateboard = cameraSubject and cameraSubject:IsA('SkateboardPlatform')
            
                if self.lastUpdate == nil or timeDelta > 1 then
                    self.lastCameraTransform = nil
                end
            
                if self.lastUpdate then
                    local gamepadRotation = self:UpdateGamepad()
            
                    if self:ShouldUseVRRotation() then
                        self.RotateInput = self.RotateInput + self:GetVRRotationInput()
                    else
                        -- Cap out the delta to 0.1 so we don't get some crazy things when we re-resume from
                        local delta = math.min(0.1, timeDelta)
            
                        if gamepadRotation ~= ZERO_VECTOR2 then
                            userPanningTheCamera = true
                            self.rotateInput = self.rotateInput + (gamepadRotation * delta)
                        end
            
                        local angle = 0
                        if not (isInVehicle or isOnASkateboard) then
                            angle = angle + (self.TurningLeft and -120 or 0)
                            angle = angle + (self.TurningRight and 120 or 0)
                        end
            
                        if angle ~= 0 then
                            self.rotateInput = self.rotateInput +  Vector2.new(math.rad(angle * delta), 0)
                            userPanningTheCamera = true
                        end
                    end
                end
            
                -- Reset tween speed if user is panning
                if userPanningTheCamera then
                    self.lastUserPanCamera = tick()
                end
            
                local subjectPosition = self:GetSubjectPosition()
            
                if subjectPosition and player and camera then
            
                    -- Process any dollying being done by gamepad
                    -- TODO: Move this
                    if self.gamepadDollySpeedMultiplier ~= 1 then
                        self:SetCameraToSubjectDistance(self.currentSubjectDistance * self.gamepadDollySpeedMultiplier)
                    end
            
                    local VREnabled = VRService.VREnabled
                    newCameraFocus = VREnabled and self:GetVRFocus(subjectPosition, timeDelta) or CFrame.new(subjectPosition)
            
                    local cameraFocusP = newCameraFocus.p
                    if VREnabled and not self:IsInFirstPerson() then
                        local cameraHeight = self:GetCameraHeight()
                        local vecToSubject = (subjectPosition - camera.CFrame.p)
                        local distToSubject = vecToSubject.magnitude
            
                        -- Only move the camera if it exceeded a maximum distance to the subject in VR
                        if distToSubject > self.currentSubjectDistance or self.rotateInput.x ~= 0 then
                            local desiredDist = math.min(distToSubject, self.currentSubjectDistance)
            
                            -- Note that CalculateNewLookVector is overridden from BaseCamera
                            vecToSubject = self:CalculateNewLookVector(vecToSubject.unit * X1_Y0_Z1, Vector2.new(self.rotateInput.x, 0)) * desiredDist
            
                            local newPos = cameraFocusP - vecToSubject
                            local desiredLookDir = camera.CFrame.lookVector
                            if self.rotateInput.x ~= 0 then
                                desiredLookDir = vecToSubject
                            end
                            local lookAt = Vector3.new(newPos.x + desiredLookDir.x, newPos.y, newPos.z + desiredLookDir.z)
                            self.RotateInput = ZERO_VECTOR2
            
                            newCameraCFrame = CFrame.new(newPos, lookAt) + Vector3.new(0, cameraHeight, 0)
                        end
                    else
                        -- self.RotateInput is a Vector2 of mouse movement deltas since last update
                        self.curAzimuthRad = self.curAzimuthRad - self.rotateInput.x
            
                        if self.useAzimuthLimits then
                            self.curAzimuthRad = math.clamp(self.curAzimuthRad, self.minAzimuthAbsoluteRad, self.maxAzimuthAbsoluteRad)
                        else
                            self.curAzimuthRad = (self.curAzimuthRad ~= 0) and (math.sign(self.curAzimuthRad) * (math.abs(self.curAzimuthRad) % TAU)) or 0
                        end
            
                        self.curElevationRad = math.clamp(self.curElevationRad + self.rotateInput.y, self.minElevationRad, self.maxElevationRad)
            
                        local cameraPosVector = self.currentSubjectDistance * ( CFrame.fromEulerAnglesYXZ( -self.curElevationRad, self.curAzimuthRad, 0 ) * UNIT_Z )
                        local camPos = subjectPosition + cameraPosVector
            
                        newCameraCFrame = CFrame.new(camPos, subjectPosition)
            
                        self.rotateInput = ZERO_VECTOR2
                    end
            
                    self.lastCameraTransform = newCameraCFrame
                    self.lastCameraFocus = newCameraFocus
                    if (isInVehicle or isOnASkateboard) and cameraSubject:IsA('BasePart') then
                        self.lastSubjectCFrame = cameraSubject.CFrame
                    else
                        self.lastSubjectCFrame = nil
                    end
                end
            
                self.lastUpdate = now
                return newCameraCFrame, newCameraFocus
            end
            
            return OrbitalCamera
        end
        
        function _ClassicCamera()
            
            -- Local private variables and constants
            local ZERO_VECTOR2 = Vector2.new(0,0)
            
            local tweenAcceleration = math.rad(220)		--Radians/Second^2
            local tweenSpeed = math.rad(0)				--Radians/Second
            local tweenMaxSpeed = math.rad(250)			--Radians/Second
            local TIME_BEFORE_AUTO_ROTATE = 2.0 		--Seconds, used when auto-aligning camera with vehicles
            
            local INITIAL_CAMERA_ANGLE = CFrame.fromOrientation(math.rad(-15), 0, 0)
            
            local FFlagUserCameraToggle do
                local success, result = pcall(function()
                    return UserSettings():IsUserFeatureEnabled("UserCameraToggle")
                end)
                FFlagUserCameraToggle = success and result
            end
            
            --[[ Services ]]--
            local PlayersService = game:GetService('Players')
            local VRService = game:GetService("VRService")
            
            local CameraInput = _CameraInput()
            local Util = _CameraUtils()
            
            --[[ The Module ]]--
            local BaseCamera = _BaseCamera()
            local ClassicCamera = setmetatable({}, BaseCamera)
            ClassicCamera.__index = ClassicCamera
            
            function ClassicCamera.new()
                local self = setmetatable(BaseCamera.new(), ClassicCamera)
            
                self.isFollowCamera = false
                self.isCameraToggle = false
                self.lastUpdate = tick()
                self.cameraToggleSpring = Util.Spring.new(5, 0)
            
                return self
            end
            
            function ClassicCamera:GetCameraToggleOffset(dt)
                assert(FFlagUserCameraToggle)
            
                if self.isCameraToggle then
                    local zoom = self.currentSubjectDistance
            
                    if CameraInput.getTogglePan() then
                        self.cameraToggleSpring.goal = math.clamp(Util.map(zoom, 0.5, self.FIRST_PERSON_DISTANCE_THRESHOLD, 0, 1), 0, 1)
                    else
                        self.cameraToggleSpring.goal = 0
                    end
            
                    local distanceOffset = math.clamp(Util.map(zoom, 0.5, 64, 0, 1), 0, 1) + 1
                    return Vector3.new(0, self.cameraToggleSpring:step(dt)*distanceOffset, 0)
                end
            
                return Vector3.new()
            end
            
            -- Movement mode standardized to Enum.ComputerCameraMovementMode values
            function ClassicCamera:SetCameraMovementMode(cameraMovementMode)
                BaseCamera.SetCameraMovementMode(self, cameraMovementMode)
            
                self.isFollowCamera = cameraMovementMode == Enum.ComputerCameraMovementMode.Follow
                self.isCameraToggle = cameraMovementMode == Enum.ComputerCameraMovementMode.CameraToggle
            end
            
            function ClassicCamera:Update()
                local now = tick()
                local timeDelta = now - self.lastUpdate
            
                local camera = workspace.CurrentCamera
                local newCameraCFrame = camera.CFrame
                local newCameraFocus = camera.Focus
            
                local overrideCameraLookVector = nil
                if self.resetCameraAngle then
                    local rootPart = self:GetHumanoidRootPart()
                    if rootPart then
                        overrideCameraLookVector = (rootPart.CFrame * INITIAL_CAMERA_ANGLE).lookVector
                    else
                        overrideCameraLookVector = INITIAL_CAMERA_ANGLE.lookVector
                    end
                    self.resetCameraAngle = false
                end
            
                local player = PlayersService.LocalPlayer
                local humanoid = self:GetHumanoid()
                local cameraSubject = camera.CameraSubject
                local isInVehicle = cameraSubject and cameraSubject:IsA('VehicleSeat')
                local isOnASkateboard = cameraSubject and cameraSubject:IsA('SkateboardPlatform')
                local isClimbing = humanoid and humanoid:GetState() == Enum.HumanoidStateType.Climbing
            
                if self.lastUpdate == nil or timeDelta > 1 then
                    self.lastCameraTransform = nil
                end
            
                if self.lastUpdate then
                    local gamepadRotation = self:UpdateGamepad()
            
                    if self:ShouldUseVRRotation() then
                        self.rotateInput = self.rotateInput + self:GetVRRotationInput()
                    else
                        -- Cap out the delta to 0.1 so we don't get some crazy things when we re-resume from
                        local delta = math.min(0.1, timeDelta)
            
                        if gamepadRotation ~= ZERO_VECTOR2 then
                            self.rotateInput = self.rotateInput + (gamepadRotation * delta)
                        end
            
                        local angle = 0
                        if not (isInVehicle or isOnASkateboard) then
                            angle = angle + (self.turningLeft and -120 or 0)
                            angle = angle + (self.turningRight and 120 or 0)
                        end
            
                        if angle ~= 0 then
                            self.rotateInput = self.rotateInput +  Vector2.new(math.rad(angle * delta), 0)
                        end
                    end
                end
            
                local cameraHeight = self:GetCameraHeight()
            
                -- Reset tween speed if user is panning
                if self.userPanningTheCamera then
                    tweenSpeed = 0
                    self.lastUserPanCamera = tick()
                end
            
                local userRecentlyPannedCamera = now - self.lastUserPanCamera < TIME_BEFORE_AUTO_ROTATE
                local subjectPosition = self:GetSubjectPosition()
            
                if subjectPosition and player and camera then
                    local zoom = self:GetCameraToSubjectDistance()
                    if zoom < 0.5 then
                        zoom = 0.5
                    end
            
                    if self:GetIsMouseLocked() and not self:IsInFirstPerson() then
                        -- We need to use the right vector of the camera after rotation, not before
                        local newLookCFrame = self:CalculateNewLookCFrame(overrideCameraLookVector)
            
                        local offset = self:GetMouseLockOffset()
                        local cameraRelativeOffset = offset.X * newLookCFrame.rightVector + offset.Y * newLookCFrame.upVector + offset.Z * newLookCFrame.lookVector
            
                        --offset can be NAN, NAN, NAN if newLookVector has only y component
                        if Util.IsFiniteVector3(cameraRelativeOffset) then
                            subjectPosition = subjectPosition + cameraRelativeOffset
                        end
                    else
                        if not self.userPanningTheCamera and self.lastCameraTransform then
            
                            local isInFirstPerson = self:IsInFirstPerson()
            
                            if (isInVehicle or isOnASkateboard or (self.isFollowCamera and isClimbing)) and self.lastUpdate and humanoid and humanoid.Torso then
                                if isInFirstPerson then
                                    if self.lastSubjectCFrame and (isInVehicle or isOnASkateboard) and cameraSubject:IsA('BasePart') then
                                        local y = -Util.GetAngleBetweenXZVectors(self.lastSubjectCFrame.lookVector, cameraSubject.CFrame.lookVector)
                                        if Util.IsFinite(y) then
                                            self.rotateInput = self.rotateInput + Vector2.new(y, 0)
                                        end
                                        tweenSpeed = 0
                                    end
                                elseif not userRecentlyPannedCamera then
                                    local forwardVector = humanoid.Torso.CFrame.lookVector
                                    if isOnASkateboard then
                                        forwardVector = cameraSubject.CFrame.lookVector
                                    end
            
                                    tweenSpeed = math.clamp(tweenSpeed + tweenAcceleration * timeDelta, 0, tweenMaxSpeed)
            
                                    local percent = math.clamp(tweenSpeed * timeDelta, 0, 1)
                                    if self:IsInFirstPerson() and not (self.isFollowCamera and self.isClimbing) then
                                        percent = 1
                                    end
            
                                    local y = Util.GetAngleBetweenXZVectors(forwardVector, self:GetCameraLookVector())
                                    if Util.IsFinite(y) and math.abs(y) > 0.0001 then
                                        self.rotateInput = self.rotateInput + Vector2.new(y * percent, 0)
                                    end
                                end
            
                            elseif self.isFollowCamera and (not (isInFirstPerson or userRecentlyPannedCamera) and not VRService.VREnabled) then
                                -- Logic that was unique to the old FollowCamera module
                                local lastVec = -(self.lastCameraTransform.p - subjectPosition)
            
                                local y = Util.GetAngleBetweenXZVectors(lastVec, self:GetCameraLookVector())
            
                                -- This cutoff is to decide if the humanoid's angle of movement,
                                -- relative to the camera's look vector, is enough that
                                -- we want the camera to be following them. The point is to provide
                                -- a sizable dead zone to allow more precise forward movements.
                                local thetaCutoff = 0.4
            
                                -- Check for NaNs
                                if Util.IsFinite(y) and math.abs(y) > 0.0001 and math.abs(y) > thetaCutoff * timeDelta then
                                    self.rotateInput = self.rotateInput + Vector2.new(y, 0)
                                end
                            end
                        end
                    end
            
                    if not self.isFollowCamera then
                        local VREnabled = VRService.VREnabled
            
                        if VREnabled then
                            newCameraFocus = self:GetVRFocus(subjectPosition, timeDelta)
                        else
                            newCameraFocus = CFrame.new(subjectPosition)
                        end
            
                        local cameraFocusP = newCameraFocus.p
                        if VREnabled and not self:IsInFirstPerson() then
                            local vecToSubject = (subjectPosition - camera.CFrame.p)
                            local distToSubject = vecToSubject.magnitude
            
                            -- Only move the camera if it exceeded a maximum distance to the subject in VR
                            if distToSubject > zoom or self.rotateInput.x ~= 0 then
                                local desiredDist = math.min(distToSubject, zoom)
                                vecToSubject = self:CalculateNewLookVectorVR() * desiredDist
                                local newPos = cameraFocusP - vecToSubject
                                local desiredLookDir = camera.CFrame.lookVector
                                if self.rotateInput.x ~= 0 then
                                    desiredLookDir = vecToSubject
                                end
                                local lookAt = Vector3.new(newPos.x + desiredLookDir.x, newPos.y, newPos.z + desiredLookDir.z)
                                self.rotateInput = ZERO_VECTOR2
            
                                newCameraCFrame = CFrame.new(newPos, lookAt) + Vector3.new(0, cameraHeight, 0)
                            end
                        else
                            local newLookVector = self:CalculateNewLookVector(overrideCameraLookVector)
                            self.rotateInput = ZERO_VECTOR2
                            newCameraCFrame = CFrame.new(cameraFocusP - (zoom * newLookVector), cameraFocusP)
                        end
                    else -- is FollowCamera
                        local newLookVector = self:CalculateNewLookVector(overrideCameraLookVector)
                        self.rotateInput = ZERO_VECTOR2
            
                        if VRService.VREnabled then
                            newCameraFocus = self:GetVRFocus(subjectPosition, timeDelta)
                        else
                            newCameraFocus = CFrame.new(subjectPosition)
                        end
                        newCameraCFrame = CFrame.new(newCameraFocus.p - (zoom * newLookVector), newCameraFocus.p) + Vector3.new(0, cameraHeight, 0)
                    end
            
                    if FFlagUserCameraToggle then
                        local toggleOffset = self:GetCameraToggleOffset(timeDelta)
                        newCameraFocus = newCameraFocus + toggleOffset
                        newCameraCFrame = newCameraCFrame + toggleOffset
                    end
            
                    self.lastCameraTransform = newCameraCFrame
                    self.lastCameraFocus = newCameraFocus
                    if (isInVehicle or isOnASkateboard) and cameraSubject:IsA('BasePart') then
                        self.lastSubjectCFrame = cameraSubject.CFrame
                    else
                        self.lastSubjectCFrame = nil
                    end
                end
            
                self.lastUpdate = now
                return newCameraCFrame, newCameraFocus
            end
            
            function ClassicCamera:EnterFirstPerson()
                self.inFirstPerson = true
                self:UpdateMouseBehavior()
            end
            
            function ClassicCamera:LeaveFirstPerson()
                self.inFirstPerson = false
                self:UpdateMouseBehavior()
            end
            
            return ClassicCamera
        end
        
        function _CameraUtils()
        
            local CameraUtils = {}
            
            local FFlagUserCameraToggle do
                local success, result = pcall(function()
                    return UserSettings():IsUserFeatureEnabled("UserCameraToggle")
                end)
                FFlagUserCameraToggle = success and result
            end
            
            local function round(num)
                return math.floor(num + 0.5)
            end
            
            -- Critically damped spring class for fluid motion effects
            local Spring = {} do
                Spring.__index = Spring
            
                -- Initialize to a given undamped frequency and default position
                function Spring.new(freq, pos)
                    return setmetatable({
                        freq = freq,
                        goal = pos,
                        pos = pos,
                        vel = 0,
                    }, Spring)
                end
            
                -- Advance the spring simulation by `dt` seconds
                function Spring:step(dt)
                    local f = self.freq*2*math.pi
                    local g = self.goal
                    local p0 = self.pos
                    local v0 = self.vel
            
                    local offset = p0 - g
                    local decay = math.exp(-f*dt)
            
                    local p1 = (offset*(1 + f*dt) + v0*dt)*decay + g
                    local v1 = (v0*(1 - f*dt) - offset*(f*f*dt))*decay
            
                    self.pos = p1
                    self.vel = v1
            
                    return p1
                end
            end
            
            CameraUtils.Spring = Spring
            
            -- map a value from one range to another
            function CameraUtils.map(x, inMin, inMax, outMin, outMax)
                return (x - inMin)*(outMax - outMin)/(inMax - inMin) + outMin
            end
            
            -- From TransparencyController
            function CameraUtils.Round(num, places)
                local decimalPivot = 10^places
                return math.floor(num * decimalPivot + 0.5) / decimalPivot
            end
            
            function CameraUtils.IsFinite(val)
                return val == val and val ~= math.huge and val ~= -math.huge
            end
            
            function CameraUtils.IsFiniteVector3(vec3)
                return CameraUtils.IsFinite(vec3.X) and CameraUtils.IsFinite(vec3.Y) and CameraUtils.IsFinite(vec3.Z)
            end
            
            -- Legacy implementation renamed
            function CameraUtils.GetAngleBetweenXZVectors(v1, v2)
                return math.atan2(v2.X*v1.Z-v2.Z*v1.X, v2.X*v1.X+v2.Z*v1.Z)
            end
            
            function  CameraUtils.RotateVectorByAngleAndRound(camLook, rotateAngle, roundAmount)
                if camLook.Magnitude > 0 then
                    camLook = camLook.unit
                    local currAngle = math.atan2(camLook.z, camLook.x)
                    local newAngle = round((math.atan2(camLook.z, camLook.x) + rotateAngle) / roundAmount) * roundAmount
                    return newAngle - currAngle
                end
                return 0
            end
            
            -- K is a tunable parameter that changes the shape of the S-curve
            -- the larger K is the more straight/linear the curve gets
            local k = 0.35
            local lowerK = 0.8
            local function SCurveTranform(t)
                t = math.clamp(t, -1, 1)
                if t >= 0 then
                    return (k*t) / (k - t + 1)
                end
                return -((lowerK*-t) / (lowerK + t + 1))
            end
            
            local DEADZONE = 0.1
            local function toSCurveSpace(t)
                return (1 + DEADZONE) * (2*math.abs(t) - 1) - DEADZONE
            end
            
            local function fromSCurveSpace(t)
                return t/2 + 0.5
            end
            
            function CameraUtils.GamepadLinearToCurve(thumbstickPosition)
                local function onAxis(axisValue)
                    local sign = 1
                    if axisValue < 0 then
                        sign = -1
                    end
                    local point = fromSCurveSpace(SCurveTranform(toSCurveSpace(math.abs(axisValue))))
                    point = point * sign
                    return math.clamp(point, -1, 1)
                end
                return Vector2.new(onAxis(thumbstickPosition.x), onAxis(thumbstickPosition.y))
            end
            
            -- This function converts 4 different, redundant enumeration types to one standard so the values can be compared
            function CameraUtils.ConvertCameraModeEnumToStandard(enumValue)
                if enumValue == Enum.TouchCameraMovementMode.Default then
                    return Enum.ComputerCameraMovementMode.Follow
                end
            
                if enumValue == Enum.ComputerCameraMovementMode.Default then
                    return Enum.ComputerCameraMovementMode.Classic
                end
            
                if enumValue == Enum.TouchCameraMovementMode.Classic or
                    enumValue == Enum.DevTouchCameraMovementMode.Classic or
                    enumValue == Enum.DevComputerCameraMovementMode.Classic or
                    enumValue == Enum.ComputerCameraMovementMode.Classic then
                    return Enum.ComputerCameraMovementMode.Classic
                end
            
                if enumValue == Enum.TouchCameraMovementMode.Follow or
                    enumValue == Enum.DevTouchCameraMovementMode.Follow or
                    enumValue == Enum.DevComputerCameraMovementMode.Follow or
                    enumValue == Enum.ComputerCameraMovementMode.Follow then
                    return Enum.ComputerCameraMovementMode.Follow
                end
            
                if enumValue == Enum.TouchCameraMovementMode.Orbital or
                    enumValue == Enum.DevTouchCameraMovementMode.Orbital or
                    enumValue == Enum.DevComputerCameraMovementMode.Orbital or
                    enumValue == Enum.ComputerCameraMovementMode.Orbital then
                    return Enum.ComputerCameraMovementMode.Orbital
                end
            
                if FFlagUserCameraToggle then
                    if enumValue == Enum.ComputerCameraMovementMode.CameraToggle or
                        enumValue == Enum.DevComputerCameraMovementMode.CameraToggle then
                        return Enum.ComputerCameraMovementMode.CameraToggle
                    end
                end
            
                -- Note: Only the Dev versions of the Enums have UserChoice as an option
                if enumValue == Enum.DevTouchCameraMovementMode.UserChoice or
                    enumValue == Enum.DevComputerCameraMovementMode.UserChoice then
                    return Enum.DevComputerCameraMovementMode.UserChoice
                end
            
                -- For any unmapped options return Classic camera
                return Enum.ComputerCameraMovementMode.Classic
            end
            
            return CameraUtils
        end
        
        function _CameraModule()
            local CameraModule = {}
            CameraModule.__index = CameraModule
            
            local FFlagUserCameraToggle do
                local success, result = pcall(function()
                    return UserSettings():IsUserFeatureEnabled("UserCameraToggle")
                end)
                FFlagUserCameraToggle = success and result
            end
            
            local FFlagUserRemoveTheCameraApi do
                local success, result = pcall(function()
                    return UserSettings():IsUserFeatureEnabled("UserRemoveTheCameraApi")
                end)
                FFlagUserRemoveTheCameraApi = success and result
            end
            
            -- NOTICE: Player property names do not all match their StarterPlayer equivalents,
            -- with the differences noted in the comments on the right
            local PLAYER_CAMERA_PROPERTIES =
            {
                "CameraMinZoomDistance",
                "CameraMaxZoomDistance",
                "CameraMode",
                "DevCameraOcclusionMode",
                "DevComputerCameraMode",			-- Corresponds to StarterPlayer.DevComputerCameraMovementMode
                "DevTouchCameraMode",				-- Corresponds to StarterPlayer.DevTouchCameraMovementMode
            
                -- Character movement mode
                "DevComputerMovementMode",
                "DevTouchMovementMode",
                "DevEnableMouseLock",				-- Corresponds to StarterPlayer.EnableMouseLockOption
            }
            
            local USER_GAME_SETTINGS_PROPERTIES =
            {
                "ComputerCameraMovementMode",
                "ComputerMovementMode",
                "ControlMode",
                "GamepadCameraSensitivity",
                "MouseSensitivity",
                "RotationType",
                "TouchCameraMovementMode",
                "TouchMovementMode",
            }
            
            --[[ Roblox Services ]]--
            local Players = game:GetService("Players")
            local RunService = game:GetService("RunService")
            local UserInputService = game:GetService("UserInputService")
            local UserGameSettings = UserSettings():GetService("UserGameSettings")
            
            -- Camera math utility library
            local CameraUtils = _CameraUtils()
            
            -- Load Roblox Camera Controller Modules
            local ClassicCamera = _ClassicCamera()
            local OrbitalCamera = _OrbitalCamera()
            local LegacyCamera = _LegacyCamera()
            
            -- Load Roblox Occlusion Modules
            local Invisicam = _Invisicam()
            local Poppercam = _Poppercam()
            
            -- Load the near-field character transparency controller and the mouse lock "shift lock" controller
            local TransparencyController = _TransparencyController()
            local MouseLockController = _MouseLockController()
            
            -- Table of camera controllers that have been instantiated. They are instantiated as they are used.
            local instantiatedCameraControllers = {}
            local instantiatedOcclusionModules = {}
            
            -- Management of which options appear on the Roblox User Settings screen
            do
                local PlayerScripts = Players.LocalPlayer:WaitForChild("PlayerScripts")
            
                PlayerScripts:RegisterTouchCameraMovementMode(Enum.TouchCameraMovementMode.Default)
                PlayerScripts:RegisterTouchCameraMovementMode(Enum.TouchCameraMovementMode.Follow)
                PlayerScripts:RegisterTouchCameraMovementMode(Enum.TouchCameraMovementMode.Classic)
            
                PlayerScripts:RegisterComputerCameraMovementMode(Enum.ComputerCameraMovementMode.Default)
                PlayerScripts:RegisterComputerCameraMovementMode(Enum.ComputerCameraMovementMode.Follow)
                PlayerScripts:RegisterComputerCameraMovementMode(Enum.ComputerCameraMovementMode.Classic)
                if FFlagUserCameraToggle then
                    PlayerScripts:RegisterComputerCameraMovementMode(Enum.ComputerCameraMovementMode.CameraToggle)
                end
            end
            
            CameraModule.FFlagUserCameraToggle = FFlagUserCameraToggle
            
            
            function CameraModule.new()
                local self = setmetatable({},CameraModule)
            
                -- Current active controller instances
                self.activeCameraController = nil
                self.activeOcclusionModule = nil
                self.activeTransparencyController = nil
                self.activeMouseLockController = nil
            
                self.currentComputerCameraMovementMode = nil
            
                -- Connections to events
                self.cameraSubjectChangedConn = nil
                self.cameraTypeChangedConn = nil
            
                -- Adds CharacterAdded and CharacterRemoving event handlers for all current players
                for _,player in pairs(Players:GetPlayers()) do
                    self:OnPlayerAdded(player)
                end
            
                -- Adds CharacterAdded and CharacterRemoving event handlers for all players who join in the future
                Players.PlayerAdded:Connect(function(player)
                    self:OnPlayerAdded(player)
                end)
            
                self.activeTransparencyController = TransparencyController.new()
                self.activeTransparencyController:Enable(true)
            
                if not UserInputService.TouchEnabled then
                    self.activeMouseLockController = MouseLockController.new()
                    local toggleEvent = self.activeMouseLockController:GetBindableToggleEvent()
                    if toggleEvent then
                        toggleEvent:Connect(function()
                            self:OnMouseLockToggled()
                        end)
                    end
                end
            
                self:ActivateCameraController(self:GetCameraControlChoice())
                self:ActivateOcclusionModule(Players.LocalPlayer.DevCameraOcclusionMode)
                self:OnCurrentCameraChanged() -- Does initializations and makes first camera controller
                RunService:BindToRenderStep("cameraRenderUpdate", Enum.RenderPriority.Camera.Value, function(dt) self:Update(dt) end)
            
                -- Connect listeners to camera-related properties
                for _, propertyName in pairs(PLAYER_CAMERA_PROPERTIES) do
                    Players.LocalPlayer:GetPropertyChangedSignal(propertyName):Connect(function()
                        self:OnLocalPlayerCameraPropertyChanged(propertyName)
                    end)
                end
            
                for _, propertyName in pairs(USER_GAME_SETTINGS_PROPERTIES) do
                    UserGameSettings:GetPropertyChangedSignal(propertyName):Connect(function()
                        self:OnUserGameSettingsPropertyChanged(propertyName)
                    end)
                end
                game.Workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
                    self:OnCurrentCameraChanged()
                end)
            
                self.lastInputType = UserInputService:GetLastInputType()
                UserInputService.LastInputTypeChanged:Connect(function(newLastInputType)
                    self.lastInputType = newLastInputType
                end)
            
                return self
            end
            
            function CameraModule:GetCameraMovementModeFromSettings()
                local cameraMode = Players.LocalPlayer.CameraMode
            
                -- Lock First Person trumps all other settings and forces ClassicCamera
                if cameraMode == Enum.CameraMode.LockFirstPerson then
                    return CameraUtils.ConvertCameraModeEnumToStandard(Enum.ComputerCameraMovementMode.Classic)
                end
            
                local devMode, userMode
                if UserInputService.TouchEnabled then
                    devMode = CameraUtils.ConvertCameraModeEnumToStandard(Players.LocalPlayer.DevTouchCameraMode)
                    userMode = CameraUtils.ConvertCameraModeEnumToStandard(UserGameSettings.TouchCameraMovementMode)
                else
                    devMode = CameraUtils.ConvertCameraModeEnumToStandard(Players.LocalPlayer.DevComputerCameraMode)
                    userMode = CameraUtils.ConvertCameraModeEnumToStandard(UserGameSettings.ComputerCameraMovementMode)
                end
            
                if devMode == Enum.DevComputerCameraMovementMode.UserChoice then
                    -- Developer is allowing user choice, so user setting is respected
                    return userMode
                end
            
                return devMode
            end
            
            function CameraModule:ActivateOcclusionModule( occlusionMode )
                local newModuleCreator
                if occlusionMode == Enum.DevCameraOcclusionMode.Zoom then
                    newModuleCreator = Poppercam
                elseif occlusionMode == Enum.DevCameraOcclusionMode.Invisicam then
                    newModuleCreator = Invisicam
                else
                    warn("CameraScript ActivateOcclusionModule called with unsupported mode")
                    return
                end
            
                -- First check to see if there is actually a change. If the module being requested is already
                -- the currently-active solution then just make sure it's enabled and exit early
                if self.activeOcclusionModule and self.activeOcclusionModule:GetOcclusionMode() == occlusionMode then
                    if not self.activeOcclusionModule:GetEnabled() then
                        self.activeOcclusionModule:Enable(true)
                    end
                    return
                end
            
                -- Save a reference to the current active module (may be nil) so that we can disable it if
                -- we are successful in activating its replacement
                local prevOcclusionModule = self.activeOcclusionModule
            
                -- If there is no active module, see if the one we need has already been instantiated
                self.activeOcclusionModule = instantiatedOcclusionModules[newModuleCreator]
            
                -- If the module was not already instantiated and selected above, instantiate it
                if not self.activeOcclusionModule then
                    self.activeOcclusionModule = newModuleCreator.new()
                    if self.activeOcclusionModule then
                        instantiatedOcclusionModules[newModuleCreator] = self.activeOcclusionModule
                    end
                end
            
                -- If we were successful in either selecting or instantiating the module,
                -- enable it if it's not already the currently-active enabled module
                if self.activeOcclusionModule then
                    local newModuleOcclusionMode = self.activeOcclusionModule:GetOcclusionMode()
                    -- Sanity check that the module we selected or instantiated actually supports the desired occlusionMode
                    if newModuleOcclusionMode ~= occlusionMode then
                        warn("CameraScript ActivateOcclusionModule mismatch: ",self.activeOcclusionModule:GetOcclusionMode(),"~=",occlusionMode)
                    end
            
                    -- Deactivate current module if there is one
                    if prevOcclusionModule then
                        -- Sanity check that current module is not being replaced by itself (that should have been handled above)
                        if prevOcclusionModule ~= self.activeOcclusionModule then
                            prevOcclusionModule:Enable(false)
                        else
                            warn("CameraScript ActivateOcclusionModule failure to detect already running correct module")
                        end
                    end
            
                    -- Occlusion modules need to be initialized with information about characters and cameraSubject
                    -- Invisicam needs the LocalPlayer's character
                    -- Poppercam needs all player characters and the camera subject
                    if occlusionMode == Enum.DevCameraOcclusionMode.Invisicam then
                        -- Optimization to only send Invisicam what we know it needs
                        if Players.LocalPlayer.Character then
                            self.activeOcclusionModule:CharacterAdded(Players.LocalPlayer.Character, Players.LocalPlayer )
                        end
                    else
                        -- When Poppercam is enabled, we send it all existing player characters for its raycast ignore list
                        for _, player in pairs(Players:GetPlayers()) do
                            if player and player.Character then
                                self.activeOcclusionModule:CharacterAdded(player.Character, player)
                            end
                        end
                        self.activeOcclusionModule:OnCameraSubjectChanged(game.Workspace.CurrentCamera.CameraSubject)
                    end
            
                    -- Activate new choice
                    self.activeOcclusionModule:Enable(true)
                end
            end
            
            -- When supplied, legacyCameraType is used and cameraMovementMode is ignored (should be nil anyways)
            -- Next, if userCameraCreator is passed in, that is used as the cameraCreator
            function CameraModule:ActivateCameraController(cameraMovementMode, legacyCameraType)
                local newCameraCreator = nil
            
                if legacyCameraType~=nil then
                    --[[
                        This function has been passed a CameraType enum value. Some of these map to the use of
                        the LegacyCamera module, the value "Custom" will be translated to a movementMode enum
                        value based on Dev and User settings, and "Scriptable" will disable the camera controller.
                    --]]
            
                    if legacyCameraType == Enum.CameraType.Scriptable then
                        if self.activeCameraController then
                            self.activeCameraController:Enable(false)
                            self.activeCameraController = nil
                            return
                        end
                    elseif legacyCameraType == Enum.CameraType.Custom then
                        cameraMovementMode = self:GetCameraMovementModeFromSettings()
            
                    elseif legacyCameraType == Enum.CameraType.Track then
                        -- Note: The TrackCamera module was basically an older, less fully-featured
                        -- version of ClassicCamera, no longer actively maintained, but it is re-implemented in
                        -- case a game was dependent on its lack of ClassicCamera's extra functionality.
                        cameraMovementMode = Enum.ComputerCameraMovementMode.Classic
            
                    elseif legacyCameraType == Enum.CameraType.Follow then
                        cameraMovementMode = Enum.ComputerCameraMovementMode.Follow
            
                    elseif legacyCameraType == Enum.CameraType.Orbital then
                        cameraMovementMode = Enum.ComputerCameraMovementMode.Orbital
            
                    elseif legacyCameraType == Enum.CameraType.Attach or
                           legacyCameraType == Enum.CameraType.Watch or
                           legacyCameraType == Enum.CameraType.Fixed then
                        newCameraCreator = LegacyCamera
                    else
                        warn("CameraScript encountered an unhandled Camera.CameraType value: ",legacyCameraType)
                    end
                end
            
                if not newCameraCreator then
                    if cameraMovementMode == Enum.ComputerCameraMovementMode.Classic or
                        cameraMovementMode == Enum.ComputerCameraMovementMode.Follow or
                        cameraMovementMode == Enum.ComputerCameraMovementMode.Default or
                        (FFlagUserCameraToggle and cameraMovementMode == Enum.ComputerCameraMovementMode.CameraToggle) then
                        newCameraCreator = ClassicCamera
                    elseif cameraMovementMode == Enum.ComputerCameraMovementMode.Orbital then
                        newCameraCreator = OrbitalCamera
                    else
                        warn("ActivateCameraController did not select a module.")
                        return
                    end
                end
            
                -- Create the camera control module we need if it does not already exist in instantiatedCameraControllers
                local newCameraController
                if not instantiatedCameraControllers[newCameraCreator] then
                    newCameraController = newCameraCreator.new()
                    instantiatedCameraControllers[newCameraCreator] = newCameraController
                else
                    newCameraController = instantiatedCameraControllers[newCameraCreator]
                end
            
                -- If there is a controller active and it's not the one we need, disable it,
                -- if it is the one we need, make sure it's enabled
                if self.activeCameraController then
                    if self.activeCameraController ~= newCameraController then
                        self.activeCameraController:Enable(false)
                        self.activeCameraController = newCameraController
                        self.activeCameraController:Enable(true)
                    elseif not self.activeCameraController:GetEnabled() then
                        self.activeCameraController:Enable(true)
                    end
                elseif newCameraController ~= nil then
                    self.activeCameraController = newCameraController
                    self.activeCameraController:Enable(true)
                end
            
                if self.activeCameraController then
                    if cameraMovementMode~=nil then
                        self.activeCameraController:SetCameraMovementMode(cameraMovementMode)
                    elseif legacyCameraType~=nil then
                        -- Note that this is only called when legacyCameraType is not a type that
                        -- was convertible to a ComputerCameraMovementMode value, i.e. really only applies to LegacyCamera
                        self.activeCameraController:SetCameraType(legacyCameraType)
                    end
                end
            end
            
            -- Note: The active transparency controller could be made to listen for this event itself.
            function CameraModule:OnCameraSubjectChanged()
                if self.activeTransparencyController then
                    self.activeTransparencyController:SetSubject(game.Workspace.CurrentCamera.CameraSubject)
                end
            
                if self.activeOcclusionModule then
                    self.activeOcclusionModule:OnCameraSubjectChanged(game.Workspace.CurrentCamera.CameraSubject)
                end
            end
            
            function CameraModule:OnCameraTypeChanged(newCameraType)
                if newCameraType == Enum.CameraType.Scriptable then
                    if UserInputService.MouseBehavior == Enum.MouseBehavior.LockCenter then
                        UserInputService.MouseBehavior = Enum.MouseBehavior.Default
                    end
                end
            
                -- Forward the change to ActivateCameraController to handle
                self:ActivateCameraController(nil, newCameraType)
            end
            
            -- Note: Called whenever workspace.CurrentCamera changes, but also on initialization of this script
            function CameraModule:OnCurrentCameraChanged()
                local currentCamera = game.Workspace.CurrentCamera
                if not currentCamera then return end
            
                if self.cameraSubjectChangedConn then
                    self.cameraSubjectChangedConn:Disconnect()
                end
            
                if self.cameraTypeChangedConn then
                    self.cameraTypeChangedConn:Disconnect()
                end
            
                self.cameraSubjectChangedConn = currentCamera:GetPropertyChangedSignal("CameraSubject"):Connect(function()
                    self:OnCameraSubjectChanged(currentCamera.CameraSubject)
                end)
            
                self.cameraTypeChangedConn = currentCamera:GetPropertyChangedSignal("CameraType"):Connect(function()
                    self:OnCameraTypeChanged(currentCamera.CameraType)
                end)
            
                self:OnCameraSubjectChanged(currentCamera.CameraSubject)
                self:OnCameraTypeChanged(currentCamera.CameraType)
            end
            
            function CameraModule:OnLocalPlayerCameraPropertyChanged(propertyName)
                if propertyName == "CameraMode" then
                    -- CameraMode is only used to turn on/off forcing the player into first person view. The
                    -- Note: The case "Classic" is used for all other views and does not correspond only to the ClassicCamera module
                    if Players.LocalPlayer.CameraMode == Enum.CameraMode.LockFirstPerson then
                        -- Locked in first person, use ClassicCamera which supports this
                        if not self.activeCameraController or self.activeCameraController:GetModuleName() ~= "ClassicCamera" then
                            self:ActivateCameraController(CameraUtils.ConvertCameraModeEnumToStandard(Enum.DevComputerCameraMovementMode.Classic))
                        end
            
                        if self.activeCameraController then
                            self.activeCameraController:UpdateForDistancePropertyChange()
                        end
                    elseif Players.LocalPlayer.CameraMode == Enum.CameraMode.Classic then
                        -- Not locked in first person view
                        local cameraMovementMode =self: GetCameraMovementModeFromSettings()
                        self:ActivateCameraController(CameraUtils.ConvertCameraModeEnumToStandard(cameraMovementMode))
                    else
                        warn("Unhandled value for property player.CameraMode: ",Players.LocalPlayer.CameraMode)
                    end
            
                elseif propertyName == "DevComputerCameraMode" or 
                       propertyName == "DevTouchCameraMode" then
                    local cameraMovementMode = self:GetCameraMovementModeFromSettings()
                    self:ActivateCameraController(CameraUtils.ConvertCameraModeEnumToStandard(cameraMovementMode))
            
                elseif propertyName == "DevCameraOcclusionMode" then
                    self:ActivateOcclusionModule(Players.LocalPlayer.DevCameraOcclusionMode)
            
                elseif propertyName == "CameraMinZoomDistance" or propertyName == "CameraMaxZoomDistance" then
                    if self.activeCameraController then
                        self.activeCameraController:UpdateForDistancePropertyChange()
                    end
                elseif propertyName == "DevTouchMovementMode" then
                elseif propertyName == "DevComputerMovementMode" then
                elseif propertyName == "DevEnableMouseLock" then
                    -- This is the enabling/disabling of "Shift Lock" mode, not LockFirstPerson (which is a CameraMode)
                    -- Note: Enabling and disabling of MouseLock mode is normally only a publish-time choice made via
                    -- the corresponding EnableMouseLockOption checkbox of StarterPlayer, and this script does not have
                    -- support for changing the availability of MouseLock at runtime (this would require listening to
                    -- Player.DevEnableMouseLock changes)
                end
            end
            
            function CameraModule:OnUserGameSettingsPropertyChanged(propertyName)
                if propertyName == 	"ComputerCameraMovementMode" then
                    local cameraMovementMode = self:GetCameraMovementModeFromSettings()
                    self:ActivateCameraController(CameraUtils.ConvertCameraModeEnumToStandard(cameraMovementMode))
                end
            end
            
            --[[
                Main RenderStep Update. The camera controller and occlusion module both have opportunities
                to set and modify (respectively) the CFrame and Focus before it is set once on CurrentCamera.
                The camera and occlusion modules should only return CFrames, not set the CFrame property of
                CurrentCamera directly.
            --]]
            function CameraModule:Update(dt)
                if self.activeCameraController then
                    if FFlagUserCameraToggle then
                        self.activeCameraController:UpdateMouseBehavior()
                    end
            
                    local newCameraCFrame, newCameraFocus = self.activeCameraController:Update(dt)
                    self.activeCameraController:ApplyVRTransform()
                    if self.activeOcclusionModule then
                        newCameraCFrame, newCameraFocus = self.activeOcclusionModule:Update(dt, newCameraCFrame, newCameraFocus)
                    end
            
                    -- Here is where the new CFrame and Focus are set for this render frame
                    game.Workspace.CurrentCamera.CFrame = newCameraCFrame
                    game.Workspace.CurrentCamera.Focus = newCameraFocus
            
                    -- Update to character local transparency as needed based on camera-to-subject distance
                    if self.activeTransparencyController then
                        self.activeTransparencyController:Update()
                    end
                end
            end
            
            -- Formerly getCurrentCameraMode, this function resolves developer and user camera control settings to
            -- decide which camera control module should be instantiated. The old method of converting redundant enum types
            function CameraModule:GetCameraControlChoice()
                local player = Players.LocalPlayer
            
                if player then
                    if self.lastInputType == Enum.UserInputType.Touch or UserInputService.TouchEnabled then
                        -- Touch
                        if player.DevTouchCameraMode == Enum.DevTouchCameraMovementMode.UserChoice then
                            return CameraUtils.ConvertCameraModeEnumToStandard( UserGameSettings.TouchCameraMovementMode )
                        else
                            return CameraUtils.ConvertCameraModeEnumToStandard( player.DevTouchCameraMode )
                        end
                    else
                        -- Computer
                        if player.DevComputerCameraMode == Enum.DevComputerCameraMovementMode.UserChoice then
                            local computerMovementMode = CameraUtils.ConvertCameraModeEnumToStandard(UserGameSettings.ComputerCameraMovementMode)
                            return CameraUtils.ConvertCameraModeEnumToStandard(computerMovementMode)
                        else
                            return CameraUtils.ConvertCameraModeEnumToStandard(player.DevComputerCameraMode)
                        end
                    end
                end
            end
            
            function CameraModule:OnCharacterAdded(char, player)
                if self.activeOcclusionModule then
                    self.activeOcclusionModule:CharacterAdded(char, player)
                end
            end
            
            function CameraModule:OnCharacterRemoving(char, player)
                if self.activeOcclusionModule then
                    self.activeOcclusionModule:CharacterRemoving(char, player)
                end
            end
            
            function CameraModule:OnPlayerAdded(player)
                player.CharacterAdded:Connect(function(char)
                    self:OnCharacterAdded(char, player)
                end)
                player.CharacterRemoving:Connect(function(char)
                    self:OnCharacterRemoving(char, player)
                end)
            end
            
            function CameraModule:OnMouseLockToggled()
                if self.activeMouseLockController then
                    local mouseLocked = self.activeMouseLockController:GetIsMouseLocked()
                    local mouseLockOffset = self.activeMouseLockController:GetMouseLockOffset()
                    if self.activeCameraController then
                        self.activeCameraController:SetIsMouseLocked(mouseLocked)
                        self.activeCameraController:SetMouseLockOffset(mouseLockOffset)
                    end
                end
            end
            --begin edit
            local Camera = CameraModule
            local IDENTITYCF = CFrame.new()
            local lastUpCFrame = IDENTITYCF
            
            Camera.UpVector = Vector3.new(0, 1, 0)
            Camera.TransitionRate = 0.15
            Camera.UpCFrame = IDENTITYCF
            
            function Camera:GetUpVector(oldUpVector)
                return oldUpVector
            end
            local function getRotationBetween(u, v, axis)
                local dot, uxv = u:Dot(v), u:Cross(v)
                if (dot < -0.99999) then return CFrame.fromAxisAngle(axis, math.pi) end
                return CFrame.new(0, 0, 0, uxv.x, uxv.y, uxv.z, 1 + dot)
            end
            function Camera:CalculateUpCFrame()
                local oldUpVector = self.UpVector
                local newUpVector = self:GetUpVector(oldUpVector)
                
                local backup = game.Workspace.CurrentCamera.CFrame.RightVector
                local transitionCF = getRotationBetween(oldUpVector, newUpVector, backup)
                local vecSlerpCF = IDENTITYCF:Lerp(transitionCF, self.TransitionRate)
                
                self.UpVector = vecSlerpCF * oldUpVector
                self.UpCFrame = vecSlerpCF * self.UpCFrame
                
                lastUpCFrame = self.UpCFrame
            end
            
            function Camera:Update(dt)
                if self.activeCameraController then
                    if Camera.FFlagUserCameraToggle then
                        self.activeCameraController:UpdateMouseBehavior()
                    end
                    
                    local newCameraCFrame, newCameraFocus = self.activeCameraController:Update(dt)
                    self.activeCameraController:ApplyVRTransform()
                    
                    self:CalculateUpCFrame()
                    self.activeCameraController:UpdateUpCFrame(self.UpCFrame)
                    
                    -- undo shift-lock offset
            
                    local lockOffset = Vector3.new(0, 0, 0)
                    if (self.activeMouseLockController and self.activeMouseLockController:GetIsMouseLocked()) then
                        lockOffset = self.activeMouseLockController:GetMouseLockOffset()
                    end
                    
                    local offset = newCameraFocus:ToObjectSpace(newCameraCFrame)
                    local camRotation = self.UpCFrame * offset
                    newCameraFocus = newCameraFocus - newCameraCFrame:VectorToWorldSpace(lockOffset) + camRotation:VectorToWorldSpace(lockOffset)
                    newCameraCFrame = newCameraFocus * camRotation
                    
                    --local offset = newCameraFocus:Inverse() * newCameraCFrame
                    --newCameraCFrame = newCameraFocus * self.UpCFrame * offset
                    
                    if (self.activeCameraController.lastCameraTransform) then
                        self.activeCameraController.lastCameraTransform = newCameraCFrame
                        self.activeCameraController.lastCameraFocus = newCameraFocus
                    end
                    
                    if self.activeOcclusionModule then
                        newCameraCFrame, newCameraFocus = self.activeOcclusionModule:Update(dt, newCameraCFrame, newCameraFocus)
                    end
            
                    game.Workspace.CurrentCamera.CFrame = newCameraCFrame
                    game.Workspace.CurrentCamera.Focus = newCameraFocus
            
                    if self.activeTransparencyController then
                        self.activeTransparencyController:Update()
                    end
                end
            end
            
            function Camera:IsFirstPerson()
                if self.activeCameraController then
                    return self.activeCameraController:InFirstPerson()
                end
                return false
            end
            
            function Camera:IsMouseLocked()
                if self.activeCameraController then
                    return self.activeCameraController:GetIsMouseLocked()
                end
                return false
            end
            function Camera:IsToggleMode()
                if self.activeCameraController then
                    return self.activeCameraController.isCameraToggle
                end
                return false
            end
            function Camera:IsCamRelative()
                return self:IsMouseLocked() or self:IsFirstPerson()
                --return self:IsToggleMode(), self:IsMouseLocked(), self:IsFirstPerson()
            end
            --
            local Utils = _CameraUtils()
            function Utils.GetAngleBetweenXZVectors(v1, v2)
                local upCFrame = lastUpCFrame
                v1 = upCFrame:VectorToObjectSpace(v1)
                v2 = upCFrame:VectorToObjectSpace(v2)
                return math.atan2(v2.X*v1.Z-v2.Z*v1.X, v2.X*v1.X+v2.Z*v1.Z)
            end
            --end edit
            local cameraModuleObject = CameraModule.new()
            local cameraApi = {}
            return cameraModuleObject
        end
        
        function _ClickToMoveDisplay()
            local ClickToMoveDisplay = {}
            
            local FAILURE_ANIMATION_ID = "rbxassetid://2874840706"
            
            local TrailDotIcon = "rbxasset://textures/ui/traildot.png"
            local EndWaypointIcon = "rbxasset://textures/ui/waypoint.png"
            
            local WaypointsAlwaysOnTop = false
            
            local WAYPOINT_INCLUDE_FACTOR = 2
            local LAST_DOT_DISTANCE = 3
            
            local WAYPOINT_BILLBOARD_SIZE = UDim2.new(0, 1.68 * 25, 0, 2 * 25)
            
            local ENDWAYPOINT_SIZE_OFFSET_MIN = Vector2.new(0, 0.5)
            local ENDWAYPOINT_SIZE_OFFSET_MAX = Vector2.new(0, 1)
            
            local FAIL_WAYPOINT_SIZE_OFFSET_CENTER = Vector2.new(0, 0.5)
            local FAIL_WAYPOINT_SIZE_OFFSET_LEFT = Vector2.new(0.1, 0.5)
            local FAIL_WAYPOINT_SIZE_OFFSET_RIGHT = Vector2.new(-0.1, 0.5)
            
            local FAILURE_TWEEN_LENGTH = 0.125
            local FAILURE_TWEEN_COUNT = 4
            
            local TWEEN_WAYPOINT_THRESHOLD = 5
            
            local TRAIL_DOT_PARENT_NAME = "ClickToMoveDisplay"
            
            local TrailDotSize = Vector2.new(1.5, 1.5)
            
            local TRAIL_DOT_MIN_SCALE = 1
            local TRAIL_DOT_MIN_DISTANCE = 10
            local TRAIL_DOT_MAX_SCALE = 2.5
            local TRAIL_DOT_MAX_DISTANCE = 100
            
            local PlayersService = game:GetService("Players")
            local TweenService = game:GetService("TweenService")
            local RunService = game:GetService("RunService")
            local Workspace = game:GetService("Workspace")
            
            local LocalPlayer = PlayersService.LocalPlayer
            
            local function CreateWaypointTemplates()
                local TrailDotTemplate = Instance.new("Part")
                TrailDotTemplate.Size = Vector3.new(1, 1, 1)
                TrailDotTemplate.Anchored = true
                TrailDotTemplate.CanCollide = false
                TrailDotTemplate.Name = "TrailDot"
                TrailDotTemplate.Transparency = 1
                local TrailDotImage = Instance.new("ImageHandleAdornment")
                TrailDotImage.Name = "TrailDotImage"
                TrailDotImage.Size = TrailDotSize
                TrailDotImage.SizeRelativeOffset = Vector3.new(0, 0, -0.1)
                TrailDotImage.AlwaysOnTop = WaypointsAlwaysOnTop
                TrailDotImage.Image = TrailDotIcon
                TrailDotImage.Adornee = TrailDotTemplate
                TrailDotImage.Parent = TrailDotTemplate
            
                local EndWaypointTemplate = Instance.new("Part")
                EndWaypointTemplate.Size = Vector3.new(2, 2, 2)
                EndWaypointTemplate.Anchored = true
                EndWaypointTemplate.CanCollide = false
                EndWaypointTemplate.Name = "EndWaypoint"
                EndWaypointTemplate.Transparency = 1
                local EndWaypointImage = Instance.new("ImageHandleAdornment")
                EndWaypointImage.Name = "TrailDotImage"
                EndWaypointImage.Size = TrailDotSize
                EndWaypointImage.SizeRelativeOffset = Vector3.new(0, 0, -0.1)
                EndWaypointImage.AlwaysOnTop = WaypointsAlwaysOnTop
                EndWaypointImage.Image = TrailDotIcon
                EndWaypointImage.Adornee = EndWaypointTemplate
                EndWaypointImage.Parent = EndWaypointTemplate
                local EndWaypointBillboard = Instance.new("BillboardGui")
                EndWaypointBillboard.Name = "EndWaypointBillboard"
                EndWaypointBillboard.Size = WAYPOINT_BILLBOARD_SIZE
                EndWaypointBillboard.LightInfluence = 0
                EndWaypointBillboard.SizeOffset = ENDWAYPOINT_SIZE_OFFSET_MIN
                EndWaypointBillboard.AlwaysOnTop = true
                EndWaypointBillboard.Adornee = EndWaypointTemplate
                EndWaypointBillboard.Parent = EndWaypointTemplate
                local EndWaypointImageLabel = Instance.new("ImageLabel")
                EndWaypointImageLabel.Image = EndWaypointIcon
                EndWaypointImageLabel.BackgroundTransparency = 1
                EndWaypointImageLabel.Size = UDim2.new(1, 0, 1, 0)
                EndWaypointImageLabel.Parent = EndWaypointBillboard
            
            
                local FailureWaypointTemplate = Instance.new("Part")
                FailureWaypointTemplate.Size = Vector3.new(2, 2, 2)
                FailureWaypointTemplate.Anchored = true
                FailureWaypointTemplate.CanCollide = false
                FailureWaypointTemplate.Name = "FailureWaypoint"
                FailureWaypointTemplate.Transparency = 1
                local FailureWaypointImage = Instance.new("ImageHandleAdornment")
                FailureWaypointImage.Name = "TrailDotImage"
                FailureWaypointImage.Size = TrailDotSize
                FailureWaypointImage.SizeRelativeOffset = Vector3.new(0, 0, -0.1)
                FailureWaypointImage.AlwaysOnTop = WaypointsAlwaysOnTop
                FailureWaypointImage.Image = TrailDotIcon
                FailureWaypointImage.Adornee = FailureWaypointTemplate
                FailureWaypointImage.Parent = FailureWaypointTemplate
                local FailureWaypointBillboard = Instance.new("BillboardGui")
                FailureWaypointBillboard.Name = "FailureWaypointBillboard"
                FailureWaypointBillboard.Size = WAYPOINT_BILLBOARD_SIZE
                FailureWaypointBillboard.LightInfluence = 0
                FailureWaypointBillboard.SizeOffset = FAIL_WAYPOINT_SIZE_OFFSET_CENTER
                FailureWaypointBillboard.AlwaysOnTop = true
                FailureWaypointBillboard.Adornee = FailureWaypointTemplate
                FailureWaypointBillboard.Parent = FailureWaypointTemplate
                local FailureWaypointFrame = Instance.new("Frame")
                FailureWaypointFrame.BackgroundTransparency = 1
                FailureWaypointFrame.Size = UDim2.new(0, 0, 0, 0)
                FailureWaypointFrame.Position = UDim2.new(0.5, 0, 1, 0)
                FailureWaypointFrame.Parent = FailureWaypointBillboard
                local FailureWaypointImageLabel = Instance.new("ImageLabel")
                FailureWaypointImageLabel.Image = EndWaypointIcon
                FailureWaypointImageLabel.BackgroundTransparency = 1
                FailureWaypointImageLabel.Position = UDim2.new(
                    0, -WAYPOINT_BILLBOARD_SIZE.X.Offset/2, 0, -WAYPOINT_BILLBOARD_SIZE.Y.Offset
                )
                FailureWaypointImageLabel.Size = WAYPOINT_BILLBOARD_SIZE
                FailureWaypointImageLabel.Parent = FailureWaypointFrame
            
                return TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate
            end
            
            local TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate = CreateWaypointTemplates()
            
            local function getTrailDotParent()
                local camera = Workspace.CurrentCamera
                local trailParent = camera:FindFirstChild(TRAIL_DOT_PARENT_NAME)
                if not trailParent then
                    trailParent = Instance.new("Model")
                    trailParent.Name = TRAIL_DOT_PARENT_NAME
                    trailParent.Parent = camera
                end
                return trailParent
            end
            
            local function placePathWaypoint(waypointModel, position)
                local ray = Ray.new(position + Vector3.new(0, 2.5, 0), Vector3.new(0, -10, 0))
                local hitPart, hitPoint, hitNormal = Workspace:FindPartOnRayWithIgnoreList(
                    ray,
                    { Workspace.CurrentCamera, LocalPlayer.Character }
                )
                if hitPart then
                    waypointModel.CFrame = CFrame.new(hitPoint, hitPoint + hitNormal)
                    waypointModel.Parent = getTrailDotParent()
                end
            end
            
            local TrailDot = {}
            TrailDot.__index = TrailDot
            
            function TrailDot:Destroy()
                self.DisplayModel:Destroy()
            end
            
            function TrailDot:NewDisplayModel(position)
                local newDisplayModel = TrailDotTemplate:Clone()
                placePathWaypoint(newDisplayModel, position)
                return newDisplayModel
            end
            
            function TrailDot.new(position, closestWaypoint)
                local self = setmetatable({}, TrailDot)
            
                self.DisplayModel = self:NewDisplayModel(position)
                self.ClosestWayPoint = closestWaypoint
            
                return self
            end
            
            local EndWaypoint = {}
            EndWaypoint.__index = EndWaypoint
            
            function EndWaypoint:Destroy()
                self.Destroyed = true
                self.Tween:Cancel()
                self.DisplayModel:Destroy()
            end
            
            function EndWaypoint:NewDisplayModel(position)
                local newDisplayModel = EndWaypointTemplate:Clone()
                placePathWaypoint(newDisplayModel, position)
                return newDisplayModel
            end
            
            function EndWaypoint:CreateTween()
                local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, -1, true)
                local tween = TweenService:Create(
                    self.DisplayModel.EndWaypointBillboard,
                    tweenInfo,
                    { SizeOffset = ENDWAYPOINT_SIZE_OFFSET_MAX }
                )
                tween:Play()
                return tween
            end
            
            function EndWaypoint:TweenInFrom(originalPosition)
                local currentPositon = self.DisplayModel.Position
                local studsOffset = originalPosition - currentPositon
                self.DisplayModel.EndWaypointBillboard.StudsOffset = Vector3.new(0, studsOffset.Y, 0)
                local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
                local tween = TweenService:Create(
                    self.DisplayModel.EndWaypointBillboard,
                    tweenInfo,
                    { StudsOffset = Vector3.new(0, 0, 0) }
                )
                tween:Play()
                return tween
            end
            
            function EndWaypoint.new(position, closestWaypoint, originalPosition)
                local self = setmetatable({}, EndWaypoint)
            
                self.DisplayModel = self:NewDisplayModel(position)
                self.Destroyed = false
                if originalPosition and (originalPosition - position).magnitude > TWEEN_WAYPOINT_THRESHOLD then
                    self.Tween = self:TweenInFrom(originalPosition)
                    coroutine.wrap(function()
                        self.Tween.Completed:Wait()
                        if not self.Destroyed then
                            self.Tween = self:CreateTween()
                        end
                    end)()
                else
                    self.Tween = self:CreateTween()
                end
                self.ClosestWayPoint = closestWaypoint
            
                return self
            end
            
            local FailureWaypoint = {}
            FailureWaypoint.__index = FailureWaypoint
            
            function FailureWaypoint:Hide()
                self.DisplayModel.Parent = nil
            end
            
            function FailureWaypoint:Destroy()
                self.DisplayModel:Destroy()
            end
            
            function FailureWaypoint:NewDisplayModel(position)
                local newDisplayModel = FailureWaypointTemplate:Clone()
                placePathWaypoint(newDisplayModel, position)
                local ray = Ray.new(position + Vector3.new(0, 2.5, 0), Vector3.new(0, -10, 0))
                local hitPart, hitPoint, hitNormal = Workspace:FindPartOnRayWithIgnoreList(
                    ray, { Workspace.CurrentCamera, LocalPlayer.Character }
                )
                if hitPart then
                    newDisplayModel.CFrame = CFrame.new(hitPoint, hitPoint + hitNormal)
                    newDisplayModel.Parent = getTrailDotParent()
                end
                return newDisplayModel
            end
            
            function FailureWaypoint:RunFailureTween()
                wait(FAILURE_TWEEN_LENGTH) -- Delay one tween length betfore starting tweening
                -- Tween out from center
                local tweenInfo = TweenInfo.new(FAILURE_TWEEN_LENGTH/2, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
                local tweenLeft = TweenService:Create(self.DisplayModel.FailureWaypointBillboard, tweenInfo,
                    { SizeOffset = FAIL_WAYPOINT_SIZE_OFFSET_LEFT })
                tweenLeft:Play()
            
                local tweenLeftRoation = TweenService:Create(self.DisplayModel.FailureWaypointBillboard.Frame, tweenInfo,
                    { Rotation = 10 })
                tweenLeftRoation:Play()
            
                tweenLeft.Completed:wait()
            
                -- Tween back and forth
                tweenInfo = TweenInfo.new(FAILURE_TWEEN_LENGTH, Enum.EasingStyle.Sine, Enum.EasingDirection.Out,
                    FAILURE_TWEEN_COUNT - 1, true)
                local tweenSideToSide = TweenService:Create(self.DisplayModel.FailureWaypointBillboard, tweenInfo,
                    { SizeOffset = FAIL_WAYPOINT_SIZE_OFFSET_RIGHT})
                tweenSideToSide:Play()
            
                -- Tween flash dark and roate left and right
                tweenInfo = TweenInfo.new(FAILURE_TWEEN_LENGTH, Enum.EasingStyle.Sine, Enum.EasingDirection.Out,
                    FAILURE_TWEEN_COUNT - 1, true)
                local tweenFlash = TweenService:Create(self.DisplayModel.FailureWaypointBillboard.Frame.ImageLabel, tweenInfo,
                    { ImageColor3 = Color3.new(0.75, 0.75, 0.75)})
                tweenFlash:Play()
            
                local tweenRotate = TweenService:Create(self.DisplayModel.FailureWaypointBillboard.Frame, tweenInfo,
                    { Rotation = -10 })
                tweenRotate:Play()
            
                tweenSideToSide.Completed:wait()
            
                -- Tween back to center
                tweenInfo = TweenInfo.new(FAILURE_TWEEN_LENGTH/2, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
                local tweenCenter = TweenService:Create(self.DisplayModel.FailureWaypointBillboard, tweenInfo,
                    { SizeOffset = FAIL_WAYPOINT_SIZE_OFFSET_CENTER })
                tweenCenter:Play()
            
                local tweenRoation = TweenService:Create(self.DisplayModel.FailureWaypointBillboard.Frame, tweenInfo,
                    { Rotation = 0 })
                tweenRoation:Play()
            
                tweenCenter.Completed:wait()
            
                wait(FAILURE_TWEEN_LENGTH) -- Delay one tween length betfore removing
            end
            
            function FailureWaypoint.new(position)
                local self = setmetatable({}, FailureWaypoint)
            
                self.DisplayModel = self:NewDisplayModel(position)
            
                return self
            end
            
            local failureAnimation = Instance.new("Animation")
            failureAnimation.AnimationId = FAILURE_ANIMATION_ID
            
            local lastHumanoid = nil
            local lastFailureAnimationTrack = nil
            
            local function getFailureAnimationTrack(myHumanoid)
                if myHumanoid == lastHumanoid then
                    return lastFailureAnimationTrack
                end
                lastFailureAnimationTrack = myHumanoid:LoadAnimation(failureAnimation)
                lastFailureAnimationTrack.Priority = Enum.AnimationPriority.Action
                lastFailureAnimationTrack.Looped = false
                return lastFailureAnimationTrack
            end
            
            local function findPlayerHumanoid()
                local character = LocalPlayer.Character
                if character then
                    return character:FindFirstChildOfClass("Humanoid")
                end
            end
            
            local function createTrailDots(wayPoints, originalEndWaypoint)
                local newTrailDots = {}
                local count = 1
                for i = 1, #wayPoints - 1 do
                    local closeToEnd = (wayPoints[i].Position - wayPoints[#wayPoints].Position).magnitude < LAST_DOT_DISTANCE
                    local includeWaypoint = i % WAYPOINT_INCLUDE_FACTOR == 0 and not closeToEnd
                    if includeWaypoint then
                        local trailDot = TrailDot.new(wayPoints[i].Position, i)
                        newTrailDots[count] = trailDot
                        count = count + 1
                    end
                end
            
                local newEndWaypoint = EndWaypoint.new(wayPoints[#wayPoints].Position, #wayPoints, originalEndWaypoint)
                table.insert(newTrailDots, newEndWaypoint)
            
                local reversedTrailDots = {}
                count = 1
                for i = #newTrailDots, 1, -1 do
                    reversedTrailDots[count] = newTrailDots[i]
                    count = count + 1
                end
                return reversedTrailDots
            end
            
            local function getTrailDotScale(distanceToCamera, defaultSize)
                local rangeLength = TRAIL_DOT_MAX_DISTANCE - TRAIL_DOT_MIN_DISTANCE
                local inRangePoint = math.clamp(distanceToCamera - TRAIL_DOT_MIN_DISTANCE, 0, rangeLength)/rangeLength
                local scale = TRAIL_DOT_MIN_SCALE + (TRAIL_DOT_MAX_SCALE - TRAIL_DOT_MIN_SCALE)*inRangePoint
                return defaultSize * scale
            end
            
            local createPathCount = 0
            -- originalEndWaypoint is optional, causes the waypoint to tween from that position.
            function ClickToMoveDisplay.CreatePathDisplay(wayPoints, originalEndWaypoint)
                createPathCount = createPathCount + 1
                local trailDots = createTrailDots(wayPoints, originalEndWaypoint)
            
                local function removePathBeforePoint(wayPointNumber)
                    -- kill all trailDots before and at wayPointNumber
                    for i = #trailDots, 1, -1 do
                        local trailDot = trailDots[i]
                        if trailDot.ClosestWayPoint <= wayPointNumber then
                            trailDot:Destroy()
                            trailDots[i] = nil
                        else
                            break
                        end
                    end
                end
            
                local reiszeTrailDotsUpdateName = "ClickToMoveResizeTrail" ..createPathCount
                local function resizeTrailDots()
                    if #trailDots == 0 then
                        RunService:UnbindFromRenderStep(reiszeTrailDotsUpdateName)
                        return
                    end
                    local cameraPos = Workspace.CurrentCamera.CFrame.p
                    for i = 1, #trailDots do
                        local trailDotImage = trailDots[i].DisplayModel:FindFirstChild("TrailDotImage")
                        if trailDotImage then
                            local distanceToCamera = (trailDots[i].DisplayModel.Position - cameraPos).magnitude
                            trailDotImage.Size = getTrailDotScale(distanceToCamera, TrailDotSize)
                        end
                    end
                end
                RunService:BindToRenderStep(reiszeTrailDotsUpdateName, Enum.RenderPriority.Camera.Value - 1, resizeTrailDots)
            
                local function removePath()
                    removePathBeforePoint(#wayPoints)
                end
            
                return removePath, removePathBeforePoint
            end
            
            local lastFailureWaypoint = nil
            function ClickToMoveDisplay.DisplayFailureWaypoint(position)
                if lastFailureWaypoint then
                    lastFailureWaypoint:Hide()
                end
                local failureWaypoint = FailureWaypoint.new(position)
                lastFailureWaypoint = failureWaypoint
                coroutine.wrap(function()
                    failureWaypoint:RunFailureTween()
                    failureWaypoint:Destroy()
                    failureWaypoint = nil
                end)()
            end
            
            function ClickToMoveDisplay.CreateEndWaypoint(position)
                return EndWaypoint.new(position)
            end
            
            function ClickToMoveDisplay.PlayFailureAnimation()
                local myHumanoid = findPlayerHumanoid()
                if myHumanoid then
                    local animationTrack = getFailureAnimationTrack(myHumanoid)
                    animationTrack:Play()
                end
            end
            
            function ClickToMoveDisplay.CancelFailureAnimation()
                if lastFailureAnimationTrack ~= nil and lastFailureAnimationTrack.IsPlaying then
                    lastFailureAnimationTrack:Stop()
                end
            end
            
            function ClickToMoveDisplay.SetWaypointTexture(texture)
                TrailDotIcon = texture
                TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate = CreateWaypointTemplates()
            end
            
            function ClickToMoveDisplay.GetWaypointTexture()
                return TrailDotIcon
            end
            
            function ClickToMoveDisplay.SetWaypointRadius(radius)
                TrailDotSize = Vector2.new(radius, radius)
                TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate = CreateWaypointTemplates()
            end
            
            function ClickToMoveDisplay.GetWaypointRadius()
                return TrailDotSize.X
            end
            
            function ClickToMoveDisplay.SetEndWaypointTexture(texture)
                EndWaypointIcon = texture
                TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate = CreateWaypointTemplates()
            end
            
            function ClickToMoveDisplay.GetEndWaypointTexture()
                return EndWaypointIcon
            end
            
            function ClickToMoveDisplay.SetWaypointsAlwaysOnTop(alwaysOnTop)
                WaypointsAlwaysOnTop = alwaysOnTop
                TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate = CreateWaypointTemplates()
            end
            
            function ClickToMoveDisplay.GetWaypointsAlwaysOnTop()
                return WaypointsAlwaysOnTop
            end
            
            return ClickToMoveDisplay
        end
        
        function _BaseCharacterController()
        
            local ZERO_VECTOR3 = Vector3.new(0,0,0)
            
            --[[ The Module ]]--
            local BaseCharacterController = {}
            BaseCharacterController.__index = BaseCharacterController
            
            function BaseCharacterController.new()
                local self = setmetatable({}, BaseCharacterController)
                self.enabled = false
                self.moveVector = ZERO_VECTOR3
                self.moveVectorIsCameraRelative = true
                self.isJumping = false
                return self
            end
            
            function BaseCharacterController:OnRenderStepped(dt)
                -- By default, nothing to do
            end
            
            function BaseCharacterController:GetMoveVector()
                return self.moveVector
            end
            
            function BaseCharacterController:IsMoveVectorCameraRelative()
                return self.moveVectorIsCameraRelative
            end
            
            function BaseCharacterController:GetIsJumping()
                return self.isJumping
            end
            
            -- Override in derived classes to set self.enabled and return boolean indicating
            -- whether Enable/Disable was successful. Return true if controller is already in the requested state.
            function BaseCharacterController:Enable(enable)
                error("BaseCharacterController:Enable must be overridden in derived classes and should not be called.")
                return false
            end
            
            return BaseCharacterController
        end
        
        function _VehicleController()
            local ContextActionService = game:GetService("ContextActionService")
            
            --[[ Constants ]]--
            -- Set this to true if you want to instead use the triggers for the throttle
            local useTriggersForThrottle = true
            -- Also set this to true if you want the thumbstick to not affect throttle, only triggers when a gamepad is conected
            local onlyTriggersForThrottle = false
            local ZERO_VECTOR3 = Vector3.new(0,0,0)
            
            local AUTO_PILOT_DEFAULT_MAX_STEERING_ANGLE = 35
            
            
            -- Note that VehicleController does not derive from BaseCharacterController, it is a special case
            local VehicleController = {}
            VehicleController.__index = VehicleController
            
            function VehicleController.new(CONTROL_ACTION_PRIORITY)
                local self = setmetatable({}, VehicleController)
            
                self.CONTROL_ACTION_PRIORITY = CONTROL_ACTION_PRIORITY
            
                self.enabled = false
                self.vehicleSeat = nil
                self.throttle = 0
                self.steer = 0
            
                self.acceleration = 0
                self.decceleration = 0
                self.turningRight = 0
                self.turningLeft = 0
            
                self.vehicleMoveVector = ZERO_VECTOR3
            
                self.autoPilot = {}
                self.autoPilot.MaxSpeed = 0
                self.autoPilot.MaxSteeringAngle = 0
            
                return self
            end
            
            function VehicleController:BindContextActions()
                if useTriggersForThrottle then
                    ContextActionService:BindActionAtPriority("throttleAccel", (function(actionName, inputState, inputObject)
                        self:OnThrottleAccel(actionName, inputState, inputObject)
                        return Enum.ContextActionResult.Pass
                    end), false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.ButtonR2)
                    ContextActionService:BindActionAtPriority("throttleDeccel", (function(actionName, inputState, inputObject)
                        self:OnThrottleDeccel(actionName, inputState, inputObject)
                        return Enum.ContextActionResult.Pass
                    end), false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.ButtonL2)
                end
                ContextActionService:BindActionAtPriority("arrowSteerRight", (function(actionName, inputState, inputObject)
                    self:OnSteerRight(actionName, inputState, inputObject)
                    return Enum.ContextActionResult.Pass
                end), false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.Right)
                ContextActionService:BindActionAtPriority("arrowSteerLeft", (function(actionName, inputState, inputObject)
                    self:OnSteerLeft(actionName, inputState, inputObject)
                    return Enum.ContextActionResult.Pass
                end), false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.Left)
            end
            
            function VehicleController:Enable(enable, vehicleSeat)
                if enable == self.enabled and vehicleSeat == self.vehicleSeat then
                    return
                end
            
                self.enabled = enable
                self.vehicleMoveVector = ZERO_VECTOR3
            
                if enable then
                    if vehicleSeat then
                        self.vehicleSeat = vehicleSeat
            
                        self:SetupAutoPilot()
                        self:BindContextActions()
                    end
                else
                    if useTriggersForThrottle then
                        ContextActionService:UnbindAction("throttleAccel")
                        ContextActionService:UnbindAction("throttleDeccel")
                    end
                    ContextActionService:UnbindAction("arrowSteerRight")
                    ContextActionService:UnbindAction("arrowSteerLeft")
                    self.vehicleSeat = nil
                end
            end
            
            function VehicleController:OnThrottleAccel(actionName, inputState, inputObject)
                if inputState == Enum.UserInputState.End or inputState == Enum.UserInputState.Cancel then
                    self.acceleration = 0
                else
                    self.acceleration = -1
                end
                self.throttle = self.acceleration + self.decceleration
            end
            
            function VehicleController:OnThrottleDeccel(actionName, inputState, inputObject)
                if inputState == Enum.UserInputState.End or inputState == Enum.UserInputState.Cancel then
                    self.decceleration = 0
                else
                    self.decceleration = 1
                end
                self.throttle = self.acceleration + self.decceleration
            end
            
            function VehicleController:OnSteerRight(actionName, inputState, inputObject)
                if inputState == Enum.UserInputState.End or inputState == Enum.UserInputState.Cancel then
                    self.turningRight = 0
                else
                    self.turningRight = 1
                end
                self.steer = self.turningRight + self.turningLeft
            end
            
            function VehicleController:OnSteerLeft(actionName, inputState, inputObject)
                if inputState == Enum.UserInputState.End or inputState == Enum.UserInputState.Cancel then
                    self.turningLeft = 0
                else
                    self.turningLeft = -1
                end
                self.steer = self.turningRight + self.turningLeft
            end
            
            -- Call this from a function bound to Renderstep with Input Priority
            function VehicleController:Update(moveVector, cameraRelative, usingGamepad)
                if self.vehicleSeat then
                    if cameraRelative then
                        -- This is the default steering mode
                        moveVector = moveVector + Vector3.new(self.steer, 0, self.throttle)
                        if usingGamepad and onlyTriggersForThrottle and useTriggersForThrottle then
                            self.vehicleSeat.ThrottleFloat = -self.throttle
                        else
                            self.vehicleSeat.ThrottleFloat = -moveVector.Z
                        end
                        self.vehicleSeat.SteerFloat = moveVector.X
            
                        return moveVector, true
                    else
                        -- This is the path following mode
                        local localMoveVector = self.vehicleSeat.Occupant.RootPart.CFrame:VectorToObjectSpace(moveVector)
            
                        self.vehicleSeat.ThrottleFloat = self:ComputeThrottle(localMoveVector)
                        self.vehicleSeat.SteerFloat = self:ComputeSteer(localMoveVector)
            
                        return ZERO_VECTOR3, true
                    end
                end
                return moveVector, false
            end
            
            function VehicleController:ComputeThrottle(localMoveVector)
                if localMoveVector ~= ZERO_VECTOR3 then
                    local throttle = -localMoveVector.Z
                    return throttle
                else
                    return 0.0
                end
            end
            
            function VehicleController:ComputeSteer(localMoveVector)
                if localMoveVector ~= ZERO_VECTOR3 then
                    local steerAngle = -math.atan2(-localMoveVector.x, -localMoveVector.z) * (180 / math.pi)
                    return steerAngle / self.autoPilot.MaxSteeringAngle
                else
                    return 0.0
                end
            end
            
            function VehicleController:SetupAutoPilot()
                -- Setup default
                self.autoPilot.MaxSpeed = self.vehicleSeat.MaxSpeed
                self.autoPilot.MaxSteeringAngle = AUTO_PILOT_DEFAULT_MAX_STEERING_ANGLE
            
                -- VehicleSeat should have a MaxSteeringAngle as well.
                -- Or we could look for a child "AutoPilotConfigModule" to find these values
                -- Or allow developer to set them through the API as like the CLickToMove customization API
            end
            
            return VehicleController
        end
        
        function _TouchJump()
            
            local Players = game:GetService("Players")
            local GuiService = game:GetService("GuiService")
            
            --[[ Constants ]]--
            local TOUCH_CONTROL_SHEET = "rbxasset://textures/ui/Input/TouchControlsSheetV2.png"
            
            --[[ The Module ]]--
            local BaseCharacterController = _BaseCharacterController()
            local TouchJump = setmetatable({}, BaseCharacterController)
            TouchJump.__index = TouchJump
            
            function TouchJump.new()
                local self = setmetatable(BaseCharacterController.new(), TouchJump)
            
                self.parentUIFrame = nil
                self.jumpButton = nil
                self.characterAddedConn = nil
                self.humanoidStateEnabledChangedConn = nil
                self.humanoidJumpPowerConn = nil
                self.humanoidParentConn = nil
                self.externallyEnabled = false
                self.jumpPower = 0
                self.jumpStateEnabled = true
                self.isJumping = false
                self.humanoid = nil -- saved reference because property change connections are made using it
            
                return self
            end
            
            function TouchJump:EnableButton(enable)
                if enable then
                    if not self.jumpButton then
                        self:Create()
                    end
                    local humanoid = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
                    if humanoid and self.externallyEnabled then
                        if self.externallyEnabled then
                            if humanoid.JumpPower > 0 then
                                self.jumpButton.Visible = true
                            end
                        end
                    end
                else
                    self.jumpButton.Visible = false
                    self.isJumping = false
                    self.jumpButton.ImageRectOffset = Vector2.new(1, 146)
                end
            end
            
            function TouchJump:UpdateEnabled()
                if self.jumpPower > 0 and self.jumpStateEnabled then
                    self:EnableButton(true)
                else
                    self:EnableButton(false)
                end
            end
            
            function TouchJump:HumanoidChanged(prop)
                local humanoid = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    if prop == "JumpPower" then
                        self.jumpPower =  humanoid.JumpPower
                        self:UpdateEnabled()
                    elseif prop == "Parent" then
                        if not humanoid.Parent then
                            self.humanoidChangeConn:Disconnect()
                        end
                    end
                end
            end
            
            function TouchJump:HumanoidStateEnabledChanged(state, isEnabled)
                if state == Enum.HumanoidStateType.Jumping then
                    self.jumpStateEnabled = isEnabled
                    self:UpdateEnabled()
                end
            end
            
            function TouchJump:CharacterAdded(char)
                if self.humanoidChangeConn then
                    self.humanoidChangeConn:Disconnect()
                    self.humanoidChangeConn = nil
                end
            
                self.humanoid = char:FindFirstChildOfClass("Humanoid")
                while not self.humanoid do
                    char.ChildAdded:wait()
                    self.humanoid = char:FindFirstChildOfClass("Humanoid")
                end
            
                self.humanoidJumpPowerConn = self.humanoid:GetPropertyChangedSignal("JumpPower"):Connect(function()
                    self.jumpPower =  self.humanoid.JumpPower
                    self:UpdateEnabled()
                end)
            
                self.humanoidParentConn = self.humanoid:GetPropertyChangedSignal("Parent"):Connect(function()
                    if not self.humanoid.Parent then
                        self.humanoidJumpPowerConn:Disconnect()
                        self.humanoidJumpPowerConn = nil
                        self.humanoidParentConn:Disconnect()
                        self.humanoidParentConn = nil
                    end
                end)
            
                self.humanoidStateEnabledChangedConn = self.humanoid.StateEnabledChanged:Connect(function(state, enabled)
                    self:HumanoidStateEnabledChanged(state, enabled)
                end)
            
                self.jumpPower = self.humanoid.JumpPower
                self.jumpStateEnabled = self.humanoid:GetStateEnabled(Enum.HumanoidStateType.Jumping)
                self:UpdateEnabled()
            end
            
            function TouchJump:SetupCharacterAddedFunction()
                self.characterAddedConn = Players.LocalPlayer.CharacterAdded:Connect(function(char)
                    self:CharacterAdded(char)
                end)
                if Players.LocalPlayer.Character then
                    self:CharacterAdded(Players.LocalPlayer.Character)
                end
            end
            
            function TouchJump:Enable(enable, parentFrame)
                if parentFrame then
                    self.parentUIFrame = parentFrame
                end
                self.externallyEnabled = enable
                self:EnableButton(enable)
            end
            
            function TouchJump:Create()
                if not self.parentUIFrame then
                    return
                end
            
                if self.jumpButton then
                    self.jumpButton:Destroy()
                    self.jumpButton = nil
                end
            
                local minAxis = math.min(self.parentUIFrame.AbsoluteSize.x, self.parentUIFrame.AbsoluteSize.y)
                local isSmallScreen = minAxis <= 500
                local jumpButtonSize = isSmallScreen and 70 or 120
            
                self.jumpButton = Instance.new("ImageButton")
                self.jumpButton.Name = "JumpButton"
                self.jumpButton.Visible = false
                self.jumpButton.BackgroundTransparency = 1
                self.jumpButton.Image = TOUCH_CONTROL_SHEET
                self.jumpButton.ImageRectOffset = Vector2.new(1, 146)
                self.jumpButton.ImageRectSize = Vector2.new(144, 144)
                self.jumpButton.Size = UDim2.new(0, jumpButtonSize, 0, jumpButtonSize)
            
                self.jumpButton.Position = isSmallScreen and UDim2.new(1, -(jumpButtonSize*1.5-10), 1, -jumpButtonSize - 20) or
                    UDim2.new(1, -(jumpButtonSize*1.5-10), 1, -jumpButtonSize * 1.75)
            
                local touchObject = nil
                self.jumpButton.InputBegan:connect(function(inputObject)
                    --A touch that starts elsewhere on the screen will be sent to a frame's InputBegan event
                    --if it moves over the frame. So we check that this is actually a new touch (inputObject.UserInputState ~= Enum.UserInputState.Begin)
                    if touchObject or inputObject.UserInputType ~= Enum.UserInputType.Touch
                        or inputObject.UserInputState ~= Enum.UserInputState.Begin then
                        return
                    end
            
                    touchObject = inputObject
                    self.jumpButton.ImageRectOffset = Vector2.new(146, 146)
                    self.isJumping = true
                end)
            
                local OnInputEnded = function()
                    touchObject = nil
                    self.isJumping = false
                    self.jumpButton.ImageRectOffset = Vector2.new(1, 146)
                end
            
                self.jumpButton.InputEnded:connect(function(inputObject)
                    if inputObject == touchObject then
                        OnInputEnded()
                    end
                end)
            
                GuiService.MenuOpened:connect(function()
                    if touchObject then
                        OnInputEnded()
                    end
                end)
            
                if not self.characterAddedConn then
                    self:SetupCharacterAddedFunction()
                end
            
                self.jumpButton.Parent = self.parentUIFrame
            end
            
            return TouchJump
        end
        
        function _ClickToMoveController()
            --[[ Roblox Services ]]--
            local UserInputService = game:GetService("UserInputService")
            local PathfindingService = game:GetService("PathfindingService")
            local Players = game:GetService("Players")
            local DebrisService = game:GetService('Debris')
            local StarterGui = game:GetService("StarterGui")
            local Workspace = game:GetService("Workspace")
            local CollectionService = game:GetService("CollectionService")
            local GuiService = game:GetService("GuiService")
            
            --[[ Configuration ]]
            local ShowPath = true
            local PlayFailureAnimation = true
            local UseDirectPath = false
            local UseDirectPathForVehicle = true
            local AgentSizeIncreaseFactor = 1.0
            local UnreachableWaypointTimeout = 8
            
            --[[ Constants ]]--
            local movementKeys = {
                [Enum.KeyCode.W] = true;
                [Enum.KeyCode.A] = true;
                [Enum.KeyCode.S] = true;
                [Enum.KeyCode.D] = true;
                [Enum.KeyCode.Up] = true;
                [Enum.KeyCode.Down] = true;
            }
            
            local FFlagUserNavigationClickToMoveSkipPassedWaypointsSuccess, FFlagUserNavigationClickToMoveSkipPassedWaypointsResult = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNavigationClickToMoveSkipPassedWaypoints") end)
            local FFlagUserNavigationClickToMoveSkipPassedWaypoints = FFlagUserNavigationClickToMoveSkipPassedWaypointsSuccess and FFlagUserNavigationClickToMoveSkipPassedWaypointsResult
            
            local Player = Players.LocalPlayer
            
            local ClickToMoveDisplay = _ClickToMoveDisplay()
            
            local ZERO_VECTOR3 = Vector3.new(0,0,0)
            local ALMOST_ZERO = 0.000001
            
            
            --------------------------UTIL LIBRARY-------------------------------
            local Utility = {}
            do
                local function FindCharacterAncestor(part)
                    if part then
                        local humanoid = part:FindFirstChildOfClass("Humanoid")
                        if humanoid then
                            return part, humanoid
                        else
                            return FindCharacterAncestor(part.Parent)
                        end
                    end
                end
                Utility.FindCharacterAncestor = FindCharacterAncestor
            
                local function Raycast(ray, ignoreNonCollidable, ignoreList)
                    ignoreList = ignoreList or {}
                    local hitPart, hitPos, hitNorm, hitMat = Workspace:FindPartOnRayWithIgnoreList(ray, ignoreList)
                    if hitPart then
                        if ignoreNonCollidable and hitPart.CanCollide == false then
                            -- We always include character parts so a user can click on another character
                            -- to walk to them.
                            local _, humanoid = FindCharacterAncestor(hitPart)
                            if humanoid == nil then
                                table.insert(ignoreList, hitPart)
                                return Raycast(ray, ignoreNonCollidable, ignoreList)
                            end
                        end
                        return hitPart, hitPos, hitNorm, hitMat
                    end
                    return nil, nil
                end
                Utility.Raycast = Raycast
            end
            
            local humanoidCache = {}
            local function findPlayerHumanoid(player)
                local character = player and player.Character
                if character then
                    local resultHumanoid = humanoidCache[player]
                    if resultHumanoid and resultHumanoid.Parent == character then
                        return resultHumanoid
                    else
                        humanoidCache[player] = nil -- Bust Old Cache
                        local humanoid = character:FindFirstChildOfClass("Humanoid")
                        if humanoid then
                            humanoidCache[player] = humanoid
                        end
                        return humanoid
                    end
                end
            end
            
            --------------------------CHARACTER CONTROL-------------------------------
            local CurrentIgnoreList
            local CurrentIgnoreTag = nil
            
            local TaggedInstanceAddedConnection = nil
            local TaggedInstanceRemovedConnection = nil
            
            local function GetCharacter()
                return Player and Player.Character
            end
            
            local function UpdateIgnoreTag(newIgnoreTag)
                if newIgnoreTag == CurrentIgnoreTag then
                    return
                end
                if TaggedInstanceAddedConnection then
                    TaggedInstanceAddedConnection:Disconnect()
                    TaggedInstanceAddedConnection = nil
                end
                if TaggedInstanceRemovedConnection then
                    TaggedInstanceRemovedConnection:Disconnect()
                    TaggedInstanceRemovedConnection = nil
                end
                CurrentIgnoreTag = newIgnoreTag
                CurrentIgnoreList = {GetCharacter()}
                if CurrentIgnoreTag ~= nil then
                    local ignoreParts = CollectionService:GetTagged(CurrentIgnoreTag)
                    for _, ignorePart in ipairs(ignoreParts) do
                        table.insert(CurrentIgnoreList, ignorePart)
                    end
                    TaggedInstanceAddedConnection = CollectionService:GetInstanceAddedSignal(
                        CurrentIgnoreTag):Connect(function(ignorePart)
                        table.insert(CurrentIgnoreList, ignorePart)
                    end)
                    TaggedInstanceRemovedConnection = CollectionService:GetInstanceRemovedSignal(
                        CurrentIgnoreTag):Connect(function(ignorePart)
                        for i = 1, #CurrentIgnoreList do
                            if CurrentIgnoreList[i] == ignorePart then
                                CurrentIgnoreList[i] = CurrentIgnoreList[#CurrentIgnoreList]
                                table.remove(CurrentIgnoreList)
                                break
                            end
                        end
                    end)
                end
            end
            
            local function getIgnoreList()
                if CurrentIgnoreList then
                    return CurrentIgnoreList
                end
                CurrentIgnoreList = {}
                table.insert(CurrentIgnoreList, GetCharacter())
                return CurrentIgnoreList
            end
            
            -----------------------------------PATHER--------------------------------------
            
            local function Pather(endPoint, surfaceNormal, overrideUseDirectPath)
                local this = {}
            
                local directPathForHumanoid
                local directPathForVehicle
                if overrideUseDirectPath ~= nil then
                    directPathForHumanoid = overrideUseDirectPath
                    directPathForVehicle = overrideUseDirectPath
                else
                    directPathForHumanoid = UseDirectPath
                    directPathForVehicle = UseDirectPathForVehicle
                end
            
                this.Cancelled = false
                this.Started = false
            
                this.Finished = Instance.new("BindableEvent")
                this.PathFailed = Instance.new("BindableEvent")
            
                this.PathComputing = false
                this.PathComputed = false
            
                this.OriginalTargetPoint = endPoint
                this.TargetPoint = endPoint
                this.TargetSurfaceNormal = surfaceNormal
            
                this.DiedConn = nil
                this.SeatedConn = nil
                this.BlockedConn = nil
                this.TeleportedConn = nil
            
                this.CurrentPoint = 0
            
                this.HumanoidOffsetFromPath = ZERO_VECTOR3
            
                this.CurrentWaypointPosition = nil
                this.CurrentWaypointPlaneNormal = ZERO_VECTOR3
                this.CurrentWaypointPlaneDistance = 0
                this.CurrentWaypointNeedsJump = false;
            
                this.CurrentHumanoidPosition = ZERO_VECTOR3
                this.CurrentHumanoidVelocity = 0
            
                this.NextActionMoveDirection = ZERO_VECTOR3
                this.NextActionJump = false
            
                this.Timeout = 0
            
                this.Humanoid = findPlayerHumanoid(Player)
                this.OriginPoint = nil
                this.AgentCanFollowPath = false
                this.DirectPath = false
                this.DirectPathRiseFirst = false
            
                local rootPart = this.Humanoid and this.Humanoid.RootPart
                if rootPart then
                    -- Setup origin
                    this.OriginPoint = rootPart.CFrame.p
            
                    -- Setup agent
                    local agentRadius = 2
                    local agentHeight = 5
                    local agentCanJump = true
            
                    local seat = this.Humanoid.SeatPart
                    if seat and seat:IsA("VehicleSeat") then
                        -- Humanoid is seated on a vehicle
                        local vehicle = seat:FindFirstAncestorOfClass("Model")
                        if vehicle then
                            -- Make sure the PrimaryPart is set to the vehicle seat while we compute the extends.
                            local tempPrimaryPart = vehicle.PrimaryPart
                            vehicle.PrimaryPart = seat
            
                            -- For now, only direct path
                            if directPathForVehicle then
                                local extents = vehicle:GetExtentsSize()
                                agentRadius = AgentSizeIncreaseFactor * 0.5 * math.sqrt(extents.X * extents.X + extents.Z * extents.Z)
                                agentHeight = AgentSizeIncreaseFactor * extents.Y
                                agentCanJump = false
                                this.AgentCanFollowPath = true
                                this.DirectPath = directPathForVehicle
                            end
            
                            -- Reset PrimaryPart
                            vehicle.PrimaryPart = tempPrimaryPart
                        end
                    else
                        local extents = GetCharacter():GetExtentsSize()
                        agentRadius = AgentSizeIncreaseFactor * 0.5 * math.sqrt(extents.X * extents.X + extents.Z * extents.Z)
                        agentHeight = AgentSizeIncreaseFactor * extents.Y
                        agentCanJump = (this.Humanoid.JumpPower > 0)
                        this.AgentCanFollowPath = true
                        this.DirectPath = directPathForHumanoid
                        this.DirectPathRiseFirst = this.Humanoid.Sit
                    end
            
                    -- Build path object
                    this.pathResult = PathfindingService:CreatePath({AgentRadius = agentRadius, AgentHeight = agentHeight, AgentCanJump = agentCanJump})
                end
            
                function this:Cleanup()
                    if this.stopTraverseFunc then
                        this.stopTraverseFunc()
                        this.stopTraverseFunc = nil
                    end
            
                    if this.MoveToConn then
                        this.MoveToConn:Disconnect()
                        this.MoveToConn = nil
                    end
            
                    if this.BlockedConn then
                        this.BlockedConn:Disconnect()
                        this.BlockedConn = nil
                    end
            
                    if this.DiedConn then
                        this.DiedConn:Disconnect()
                        this.DiedConn = nil
                    end
            
                    if this.SeatedConn then
                        this.SeatedConn:Disconnect()
                        this.SeatedConn = nil
                    end
            
                    if this.TeleportedConn then
                        this.TeleportedConn:Disconnect()
                        this.TeleportedConn = nil
                    end
            
                    this.Started = false
                end
            
                function this:Cancel()
                    this.Cancelled = true
                    this:Cleanup()
                end
            
                function this:IsActive()
                    return this.AgentCanFollowPath and this.Started and not this.Cancelled
                end
            
                function this:OnPathInterrupted()
                    -- Stop moving
                    this.Cancelled = true
                    this:OnPointReached(false)
                end
            
                function this:ComputePath()
                    if this.OriginPoint then
                        if this.PathComputed or this.PathComputing then return end
                        this.PathComputing = true
                        if this.AgentCanFollowPath then
                            if this.DirectPath then
                                this.pointList = {
                                    PathWaypoint.new(this.OriginPoint, Enum.PathWaypointAction.Walk),
                                    PathWaypoint.new(this.TargetPoint, this.DirectPathRiseFirst and Enum.PathWaypointAction.Jump or Enum.PathWaypointAction.Walk)
                                }
                                this.PathComputed = true
                            else
                                this.pathResult:ComputeAsync(this.OriginPoint, this.TargetPoint)
                                this.pointList = this.pathResult:GetWaypoints()
                                this.BlockedConn = this.pathResult.Blocked:Connect(function(blockedIdx) this:OnPathBlocked(blockedIdx) end)
                                this.PathComputed = this.pathResult.Status == Enum.PathStatus.Success
                            end
                        end
                        this.PathComputing = false
                    end
                end
            
                function this:IsValidPath()
                    this:ComputePath()
                    return this.PathComputed and this.AgentCanFollowPath
                end
            
                this.Recomputing = false
                function this:OnPathBlocked(blockedWaypointIdx)
                    local pathBlocked = blockedWaypointIdx >= this.CurrentPoint
                    if not pathBlocked or this.Recomputing then
                        return
                    end
            
                    this.Recomputing = true
            
                    if this.stopTraverseFunc then
                        this.stopTraverseFunc()
                        this.stopTraverseFunc = nil
                    end
            
                    this.OriginPoint = this.Humanoid.RootPart.CFrame.p
            
                    this.pathResult:ComputeAsync(this.OriginPoint, this.TargetPoint)
                    this.pointList = this.pathResult:GetWaypoints()
                    if #this.pointList > 0 then
                        this.HumanoidOffsetFromPath = this.pointList[1].Position - this.OriginPoint
                    end
                    this.PathComputed = this.pathResult.Status == Enum.PathStatus.Success
            
                    if ShowPath then
                        this.stopTraverseFunc, this.setPointFunc = ClickToMoveDisplay.CreatePathDisplay(this.pointList)
                    end
                    if this.PathComputed then
                        this.CurrentPoint = 1 -- The first waypoint is always the start location. Skip it.
                        this:OnPointReached(true) -- Move to first point
                    else
                        this.PathFailed:Fire()
                        this:Cleanup()
                    end
            
                    this.Recomputing = false
                end
            
                function this:OnRenderStepped(dt)
                    if this.Started and not this.Cancelled then
                        -- Check for Timeout (if a waypoint is not reached within the delay, we fail)
                        this.Timeout = this.Timeout + dt
                        if this.Timeout > UnreachableWaypointTimeout then
                            this:OnPointReached(false)
                            return
                        end
            
                        -- Get Humanoid position and velocity
                        this.CurrentHumanoidPosition = this.Humanoid.RootPart.Position + this.HumanoidOffsetFromPath
                        this.CurrentHumanoidVelocity = this.Humanoid.RootPart.Velocity
            
                        -- Check if it has reached some waypoints
                        while this.Started and this:IsCurrentWaypointReached() do
                            this:OnPointReached(true)
                        end
            
                        -- If still started, update actions
                        if this.Started then
                            -- Move action
                            this.NextActionMoveDirection = this.CurrentWaypointPosition - this.CurrentHumanoidPosition
                            if this.NextActionMoveDirection.Magnitude > ALMOST_ZERO then
                                this.NextActionMoveDirection = this.NextActionMoveDirection.Unit
                            else
                                this.NextActionMoveDirection = ZERO_VECTOR3
                            end
                            -- Jump action
                            if this.CurrentWaypointNeedsJump then
                                this.NextActionJump = true
                                this.CurrentWaypointNeedsJump = false	-- Request jump only once
                            else
                                this.NextActionJump = false
                            end
                        end
                    end
                end
            
                function this:IsCurrentWaypointReached()
                    local reached = false
            
                    -- Check we do have a plane, if not, we consider the waypoint reached
                    if this.CurrentWaypointPlaneNormal ~= ZERO_VECTOR3 then
                        -- Compute distance of Humanoid from destination plane
                        local dist = this.CurrentWaypointPlaneNormal:Dot(this.CurrentHumanoidPosition) - this.CurrentWaypointPlaneDistance
                        -- Compute the component of the Humanoid velocity that is towards the plane
                        local velocity = -this.CurrentWaypointPlaneNormal:Dot(this.CurrentHumanoidVelocity)
                        -- Compute the threshold from the destination plane based on Humanoid velocity
                        local threshold = math.max(1.0, 0.0625 * velocity)
                        -- If we are less then threshold in front of the plane (between 0 and threshold) or if we are behing the plane (less then 0), we consider we reached it
                        reached = dist < threshold
                    else
                        reached = true
                    end
            
                    if reached then
                        this.CurrentWaypointPosition = nil
                        this.CurrentWaypointPlaneNormal	= ZERO_VECTOR3
                        this.CurrentWaypointPlaneDistance = 0
                    end
            
                    return reached
                end
            
                function this:OnPointReached(reached)
            
                    if reached and not this.Cancelled then
                        -- First, destroyed the current displayed waypoint
                        if this.setPointFunc then
                            this.setPointFunc(this.CurrentPoint)
                        end
            
                        local nextWaypointIdx = this.CurrentPoint + 1
            
                        if nextWaypointIdx > #this.pointList then
                            -- End of path reached
                            if this.stopTraverseFunc then
                                this.stopTraverseFunc()
                            end
                            this.Finished:Fire()
                            this:Cleanup()
                        else
                            local currentWaypoint = this.pointList[this.CurrentPoint]
                            local nextWaypoint = this.pointList[nextWaypointIdx]
            
                            -- If airborne, only allow to keep moving
                            -- if nextWaypoint.Action ~= Jump, or path mantains a direction
                            -- Otherwise, wait until the humanoid gets to the ground
                            local currentState = this.Humanoid:GetState()
                            local isInAir = currentState == Enum.HumanoidStateType.FallingDown
                                or currentState == Enum.HumanoidStateType.Freefall
                                or currentState == Enum.HumanoidStateType.Jumping
            
                            if isInAir then
                                local shouldWaitForGround = nextWaypoint.Action == Enum.PathWaypointAction.Jump
                                if not shouldWaitForGround and this.CurrentPoint > 1 then
                                    local prevWaypoint = this.pointList[this.CurrentPoint - 1]
            
                                    local prevDir = currentWaypoint.Position - prevWaypoint.Position
                                    local currDir = nextWaypoint.Position - currentWaypoint.Position
            
                                    local prevDirXZ = Vector2.new(prevDir.x, prevDir.z).Unit
                                    local currDirXZ = Vector2.new(currDir.x, currDir.z).Unit
            
                                    local THRESHOLD_COS = 0.996 -- ~cos(5 degrees)
                                    shouldWaitForGround = prevDirXZ:Dot(currDirXZ) < THRESHOLD_COS
                                end
            
                                if shouldWaitForGround then
                                    this.Humanoid.FreeFalling:Wait()
            
                                    -- Give time to the humanoid's state to change
                                    -- Otherwise, the jump flag in Humanoid
                                    -- will be reset by the state change
                                    wait(0.1)
                                end
                            end
            
                            -- Move to the next point
                            if FFlagUserNavigationClickToMoveSkipPassedWaypoints then
                                this:MoveToNextWayPoint(currentWaypoint, nextWaypoint, nextWaypointIdx)
                            else
                                if this.setPointFunc then
                                    this.setPointFunc(nextWaypointIdx)
                                end
                                if nextWaypoint.Action == Enum.PathWaypointAction.Jump then
                                    this.Humanoid.Jump = true
                                end
                                this.Humanoid:MoveTo(nextWaypoint.Position)
            
                                this.CurrentPoint = nextWaypointIdx
                            end
                        end
                    else
                        this.PathFailed:Fire()
                        this:Cleanup()
                    end
                end
            
                function this:MoveToNextWayPoint(currentWaypoint, nextWaypoint, nextWaypointIdx)
                    -- Build next destination plane
                    -- (plane normal is perpendicular to the y plane and is from next waypoint towards current one (provided the two waypoints are not at the same location))
                    -- (plane location is at next waypoint)
                    this.CurrentWaypointPlaneNormal = currentWaypoint.Position - nextWaypoint.Position
                    this.CurrentWaypointPlaneNormal = Vector3.new(this.CurrentWaypointPlaneNormal.X, 0, this.CurrentWaypointPlaneNormal.Z)
                    if this.CurrentWaypointPlaneNormal.Magnitude > ALMOST_ZERO then
                        this.CurrentWaypointPlaneNormal	= this.CurrentWaypointPlaneNormal.Unit
                        this.CurrentWaypointPlaneDistance = this.CurrentWaypointPlaneNormal:Dot(nextWaypoint.Position)
                    else
                        -- Next waypoint is the same as current waypoint so no plane
                        this.CurrentWaypointPlaneNormal	= ZERO_VECTOR3
                        this.CurrentWaypointPlaneDistance = 0
                    end
            
                    -- Should we jump
                    this.CurrentWaypointNeedsJump = nextWaypoint.Action == Enum.PathWaypointAction.Jump;
            
                    -- Remember next waypoint position
                    this.CurrentWaypointPosition = nextWaypoint.Position
            
                    -- Move to next point
                    this.CurrentPoint = nextWaypointIdx
            
                    -- Finally reset Timeout
                    this.Timeout = 0
                end
            
                function this:Start(overrideShowPath)
                    if not this.AgentCanFollowPath then
                        this.PathFailed:Fire()
                        return
                    end
            
                    if this.Started then return end
                    this.Started = true
            
                    ClickToMoveDisplay.CancelFailureAnimation()
            
                    if ShowPath then
                        if overrideShowPath == nil or overrideShowPath then
                            this.stopTraverseFunc, this.setPointFunc = ClickToMoveDisplay.CreatePathDisplay(this.pointList, this.OriginalTargetPoint)
                        end
                    end
            
                    if #this.pointList > 0 then
                        -- Determine the humanoid offset from the path's first point
                        -- Offset of the first waypoint from the path's origin point
                        this.HumanoidOffsetFromPath = Vector3.new(0, this.pointList[1].Position.Y - this.OriginPoint.Y, 0)
            
                        -- As well as its current position and velocity
                        this.CurrentHumanoidPosition = this.Humanoid.RootPart.Position + this.HumanoidOffsetFromPath
                        this.CurrentHumanoidVelocity = this.Humanoid.RootPart.Velocity
            
                        -- Connect to events
                        this.SeatedConn = this.Humanoid.Seated:Connect(function(isSeated, seat) this:OnPathInterrupted() end)
                        this.DiedConn = this.Humanoid.Died:Connect(function() this:OnPathInterrupted() end)
                        this.TeleportedConn = this.Humanoid.RootPart:GetPropertyChangedSignal("CFrame"):Connect(function() this:OnPathInterrupted() end)
            
                        -- Actually start
                        this.CurrentPoint = 1 -- The first waypoint is always the start location. Skip it.
                        this:OnPointReached(true) -- Move to first point
                    else
                        this.PathFailed:Fire()
                        if this.stopTraverseFunc then
                            this.stopTraverseFunc()
                        end
                    end
                end
            
                --We always raycast to the ground in the case that the user clicked a wall.
                local offsetPoint = this.TargetPoint + this.TargetSurfaceNormal*1.5
                local ray = Ray.new(offsetPoint, Vector3.new(0,-1,0)*50)
                local newHitPart, newHitPos = Workspace:FindPartOnRayWithIgnoreList(ray, getIgnoreList())
                if newHitPart then
                    this.TargetPoint = newHitPos
                end
                this:ComputePath()
            
                return this
            end
            
            -------------------------------------------------------------------------
            
            local function CheckAlive()
                local humanoid = findPlayerHumanoid(Player)
                return humanoid ~= nil and humanoid.Health > 0
            end
            
            local function GetEquippedTool(character)
                if character ~= nil then
                    for _, child in pairs(character:GetChildren()) do
                        if child:IsA('Tool') then
                            return child
                        end
                    end
                end
            end
            
            local ExistingPather = nil
            local ExistingIndicator = nil
            local PathCompleteListener = nil
            local PathFailedListener = nil
            
            local function CleanupPath()
                if ExistingPather then
                    ExistingPather:Cancel()
                    ExistingPather = nil
                end
                if PathCompleteListener then
                    PathCompleteListener:Disconnect()
                    PathCompleteListener = nil
                end
                if PathFailedListener then
                    PathFailedListener:Disconnect()
                    PathFailedListener = nil
                end
                if ExistingIndicator then
                    ExistingIndicator:Destroy()
                end
            end
            
            local function HandleMoveTo(thisPather, hitPt, hitChar, character, overrideShowPath)
                if ExistingPather then
                    CleanupPath()
                end
                ExistingPather = thisPather
                thisPather:Start(overrideShowPath)
            
                PathCompleteListener = thisPather.Finished.Event:Connect(function()
                    CleanupPath()
                    if hitChar then
                        local currentWeapon = GetEquippedTool(character)
                        if currentWeapon then
                            currentWeapon:Activate()
                        end
                    end
                end)
                PathFailedListener = thisPather.PathFailed.Event:Connect(function()
                    CleanupPath()
                    if overrideShowPath == nil or overrideShowPath then
                        local shouldPlayFailureAnim = PlayFailureAnimation and not (ExistingPather and ExistingPather:IsActive())
                        if shouldPlayFailureAnim then
                            ClickToMoveDisplay.PlayFailureAnimation()
                        end
                        ClickToMoveDisplay.DisplayFailureWaypoint(hitPt)
                    end
                end)
            end
            
            local function ShowPathFailedFeedback(hitPt)
                if ExistingPather and ExistingPather:IsActive() then
                    ExistingPather:Cancel()
                end
                if PlayFailureAnimation then
                    ClickToMoveDisplay.PlayFailureAnimation()
                end
                ClickToMoveDisplay.DisplayFailureWaypoint(hitPt)
            end
            
            function OnTap(tapPositions, goToPoint, wasTouchTap)
                -- Good to remember if this is the latest tap event
                local camera = Workspace.CurrentCamera
                local character = Player.Character
            
                if not CheckAlive() then return end
            
                -- This is a path tap position
                if #tapPositions == 1 or goToPoint then
                    if camera then
                        local unitRay = camera:ScreenPointToRay(tapPositions[1].x, tapPositions[1].y)
                        local ray = Ray.new(unitRay.Origin, unitRay.Direction*1000)
            
                        local myHumanoid = findPlayerHumanoid(Player)
                        local hitPart, hitPt, hitNormal = Utility.Raycast(ray, true, getIgnoreList())
            
                        local hitChar, hitHumanoid = Utility.FindCharacterAncestor(hitPart)
                        if wasTouchTap and hitHumanoid and StarterGui:GetCore("AvatarContextMenuEnabled") then
                            local clickedPlayer = Players:GetPlayerFromCharacter(hitHumanoid.Parent)
                            if clickedPlayer then
                                CleanupPath()
                                return
                            end
                        end
                        if goToPoint then
                            hitPt = goToPoint
                            hitChar = nil
                        end
                        if hitPt and character then
                            -- Clean up current path
                            CleanupPath()
                            local thisPather = Pather(hitPt, hitNormal)
                            if thisPather:IsValidPath() then
                                HandleMoveTo(thisPather, hitPt, hitChar, character)
                            else
                                -- Clean up
                                thisPather:Cleanup()
                                -- Feedback here for when we don't have a good path
                                ShowPathFailedFeedback(hitPt)
                            end
                        end
                    end
                elseif #tapPositions >= 2 then
                    if camera then
                        -- Do shoot
                        local currentWeapon = GetEquippedTool(character)
                        if currentWeapon then
                            currentWeapon:Activate()
                        end
                    end
                end
            end
            
            local function DisconnectEvent(event)
                if event then
                    event:Disconnect()
                end
            end
            
            --[[ The ClickToMove Controller Class ]]--
            local KeyboardController = _Keyboard()
            local ClickToMove = setmetatable({}, KeyboardController)
            ClickToMove.__index = ClickToMove
            
            function ClickToMove.new(CONTROL_ACTION_PRIORITY)
                local self = setmetatable(KeyboardController.new(CONTROL_ACTION_PRIORITY), ClickToMove)
            
                self.fingerTouches = {}
                self.numUnsunkTouches = 0
                -- PC simulation
                self.mouse1Down = tick()
                self.mouse1DownPos = Vector2.new()
                self.mouse2DownTime = tick()
                self.mouse2DownPos = Vector2.new()
                self.mouse2UpTime = tick()
            
                self.keyboardMoveVector = ZERO_VECTOR3
            
                self.tapConn = nil
                self.inputBeganConn = nil
                self.inputChangedConn = nil
                self.inputEndedConn = nil
                self.humanoidDiedConn = nil
                self.characterChildAddedConn = nil
                self.onCharacterAddedConn = nil
                self.characterChildRemovedConn = nil
                self.renderSteppedConn = nil
                self.menuOpenedConnection = nil
            
                self.running = false
            
                self.wasdEnabled = false
            
                return self
            end
            
            function ClickToMove:DisconnectEvents()
                DisconnectEvent(self.tapConn)
                DisconnectEvent(self.inputBeganConn)
                DisconnectEvent(self.inputChangedConn)
                DisconnectEvent(self.inputEndedConn)
                DisconnectEvent(self.humanoidDiedConn)
                DisconnectEvent(self.characterChildAddedConn)
                DisconnectEvent(self.onCharacterAddedConn)
                DisconnectEvent(self.renderSteppedConn)
                DisconnectEvent(self.characterChildRemovedConn)
                DisconnectEvent(self.menuOpenedConnection)
            end
            
            function ClickToMove:OnTouchBegan(input, processed)
                if self.fingerTouches[input] == nil and not processed then
                    self.numUnsunkTouches = self.numUnsunkTouches + 1
                end
                self.fingerTouches[input] = processed
            end
            
            function ClickToMove:OnTouchChanged(input, processed)
                if self.fingerTouches[input] == nil then
                    self.fingerTouches[input] = processed
                    if not processed then
                        self.numUnsunkTouches = self.numUnsunkTouches + 1
                    end
                end
            end
            
            function ClickToMove:OnTouchEnded(input, processed)
                if self.fingerTouches[input] ~= nil and self.fingerTouches[input] == false then
                    self.numUnsunkTouches = self.numUnsunkTouches - 1
                end
                self.fingerTouches[input] = nil
            end
            
            
            function ClickToMove:OnCharacterAdded(character)
                self:DisconnectEvents()
            
                self.inputBeganConn = UserInputService.InputBegan:Connect(function(input, processed)
                    if input.UserInputType == Enum.UserInputType.Touch then
                        self:OnTouchBegan(input, processed)
                    end
            
                    -- Cancel path when you use the keyboard controls if wasd is enabled.
                    if self.wasdEnabled and processed == false and input.UserInputType == Enum.UserInputType.Keyboard
                        and movementKeys[input.KeyCode] then
                        CleanupPath()
                        ClickToMoveDisplay.CancelFailureAnimation()
                    end
                    if input.UserInputType == Enum.UserInputType.MouseButton1 then
                        self.mouse1DownTime = tick()
                        self.mouse1DownPos = input.Position
                    end
                    if input.UserInputType == Enum.UserInputType.MouseButton2 then
                        self.mouse2DownTime = tick()
                        self.mouse2DownPos = input.Position
                    end
                end)
            
                self.inputChangedConn = UserInputService.InputChanged:Connect(function(input, processed)
                    if input.UserInputType == Enum.UserInputType.Touch then
                        self:OnTouchChanged(input, processed)
                    end
                end)
            
                self.inputEndedConn = UserInputService.InputEnded:Connect(function(input, processed)
                    if input.UserInputType == Enum.UserInputType.Touch then
                        self:OnTouchEnded(input, processed)
                    end
            
                    if input.UserInputType == Enum.UserInputType.MouseButton2 then
                        self.mouse2UpTime = tick()
                        local currPos = input.Position
                        -- We allow click to move during path following or if there is no keyboard movement
                        local allowed = ExistingPather or self.keyboardMoveVector.Magnitude <= 0
                        if self.mouse2UpTime - self.mouse2DownTime < 0.25 and (currPos - self.mouse2DownPos).magnitude < 5 and allowed then
                            local positions = {currPos}
                            OnTap(positions)
                        end
                    end
                end)
            
                self.tapConn = UserInputService.TouchTap:Connect(function(touchPositions, processed)
                    if not processed then
                        OnTap(touchPositions, nil, true)
                    end
                end)
            
                self.menuOpenedConnection = GuiService.MenuOpened:Connect(function()
                    CleanupPath()
                end)
            
                local function OnCharacterChildAdded(child)
                    if UserInputService.TouchEnabled then
                        if child:IsA('Tool') then
                            child.ManualActivationOnly = true
                        end
                    end
                    if child:IsA('Humanoid') then
                        DisconnectEvent(self.humanoidDiedConn)
                        self.humanoidDiedConn = child.Died:Connect(function()
                            if ExistingIndicator then
                                DebrisService:AddItem(ExistingIndicator.Model, 1)
                            end
                        end)
                    end
                end
            
                self.characterChildAddedConn = character.ChildAdded:Connect(function(child)
                    OnCharacterChildAdded(child)
                end)
                self.characterChildRemovedConn = character.ChildRemoved:Connect(function(child)
                    if UserInputService.TouchEnabled then
                        if child:IsA('Tool') then
                            child.ManualActivationOnly = false
                        end
                    end
                end)
                for _, child in pairs(character:GetChildren()) do
                    OnCharacterChildAdded(child)
                end
            end
            
            function ClickToMove:Start()
                self:Enable(true)
            end
            
            function ClickToMove:Stop()
                self:Enable(false)
            end
            
            function ClickToMove:CleanupPath()
                CleanupPath()
            end
            
            function ClickToMove:Enable(enable, enableWASD, touchJumpController)
                if enable then
                    if not self.running then
                        if Player.Character then -- retro-listen
                            self:OnCharacterAdded(Player.Character)
                        end
                        self.onCharacterAddedConn = Player.CharacterAdded:Connect(function(char)
                            self:OnCharacterAdded(char)
                        end)
                        self.running = true
                    end
                    self.touchJumpController = touchJumpController
                    if self.touchJumpController then
                        self.touchJumpController:Enable(self.jumpEnabled)
                    end
                else
                    if self.running then
                        self:DisconnectEvents()
                        CleanupPath()
                        -- Restore tool activation on shutdown
                        if UserInputService.TouchEnabled then
                            local character = Player.Character
                            if character then
                                for _, child in pairs(character:GetChildren()) do
                                    if child:IsA('Tool') then
                                        child.ManualActivationOnly = false
                                    end
                                end
                            end
                        end
                        self.running = false
                    end
                    if self.touchJumpController and not self.jumpEnabled then
                        self.touchJumpController:Enable(true)
                    end
                    self.touchJumpController = nil
                end
            
                -- Extension for initializing Keyboard input as this class now derives from Keyboard
                if UserInputService.KeyboardEnabled and enable ~= self.enabled then
            
                    self.forwardValue  = 0
                    self.backwardValue = 0
                    self.leftValue = 0
                    self.rightValue = 0
            
                    self.moveVector = ZERO_VECTOR3
            
                    if enable then
                        self:BindContextActions()
                        self:ConnectFocusEventListeners()
                    else
                        self:UnbindContextActions()
                        self:DisconnectFocusEventListeners()
                    end
                end
            
                self.wasdEnabled = enable and enableWASD or false
                self.enabled = enable
            end
            
            function ClickToMove:OnRenderStepped(dt)
                -- Reset jump
                self.isJumping = false
            
                -- Handle Pather
                if ExistingPather then
                    -- Let the Pather update
                    ExistingPather:OnRenderStepped(dt)
            
                    -- If we still have a Pather, set the resulting actions
                    if ExistingPather then
                        -- Setup move (NOT relative to camera)
                        self.moveVector = ExistingPather.NextActionMoveDirection
                        self.moveVectorIsCameraRelative = false
            
                        -- Setup jump (but do NOT prevent the base Keayboard class from requesting jumps as well)
                        if ExistingPather.NextActionJump then
                            self.isJumping = true
                        end
                    else
                        self.moveVector = self.keyboardMoveVector
                        self.moveVectorIsCameraRelative = true
                    end
                else
                    self.moveVector = self.keyboardMoveVector
                    self.moveVectorIsCameraRelative = true
                end
            
                -- Handle Keyboard's jump
                if self.jumpRequested then
                    self.isJumping = true
                end
            end
            
            -- Overrides Keyboard:UpdateMovement(inputState) to conditionally consider self.wasdEnabled and let OnRenderStepped handle the movement
            function ClickToMove:UpdateMovement(inputState)
                if inputState == Enum.UserInputState.Cancel then
                    self.keyboardMoveVector = ZERO_VECTOR3
                elseif self.wasdEnabled then
                    self.keyboardMoveVector = Vector3.new(self.leftValue + self.rightValue, 0, self.forwardValue + self.backwardValue)
                end
            end
            
            -- Overrides Keyboard:UpdateJump() because jump is handled in OnRenderStepped
            function ClickToMove:UpdateJump()
                -- Nothing to do (handled in OnRenderStepped)
            end
            
            --Public developer facing functions
            function ClickToMove:SetShowPath(value)
                ShowPath = value
            end
            
            function ClickToMove:GetShowPath()
                return ShowPath
            end
            
            function ClickToMove:SetWaypointTexture(texture)
                ClickToMoveDisplay.SetWaypointTexture(texture)
            end
            
            function ClickToMove:GetWaypointTexture()
                return ClickToMoveDisplay.GetWaypointTexture()
            end
            
            function ClickToMove:SetWaypointRadius(radius)
                ClickToMoveDisplay.SetWaypointRadius(radius)
            end
            
            function ClickToMove:GetWaypointRadius()
                return ClickToMoveDisplay.GetWaypointRadius()
            end
            
            function ClickToMove:SetEndWaypointTexture(texture)
                ClickToMoveDisplay.SetEndWaypointTexture(texture)
            end
            
            function ClickToMove:GetEndWaypointTexture()
                return ClickToMoveDisplay.GetEndWaypointTexture()
            end
            
            function ClickToMove:SetWaypointsAlwaysOnTop(alwaysOnTop)
                ClickToMoveDisplay.SetWaypointsAlwaysOnTop(alwaysOnTop)
            end
            
            function ClickToMove:GetWaypointsAlwaysOnTop()
                return ClickToMoveDisplay.GetWaypointsAlwaysOnTop()
            end
            
            function ClickToMove:SetFailureAnimationEnabled(enabled)
                PlayFailureAnimation = enabled
            end
            
            function ClickToMove:GetFailureAnimationEnabled()
                return PlayFailureAnimation
            end
            
            function ClickToMove:SetIgnoredPartsTag(tag)
                UpdateIgnoreTag(tag)
            end
            
            function ClickToMove:GetIgnoredPartsTag()
                return CurrentIgnoreTag
            end
            
            function ClickToMove:SetUseDirectPath(directPath)
                UseDirectPath = directPath
            end
            
            function ClickToMove:GetUseDirectPath()
                return UseDirectPath
            end
            
            function ClickToMove:SetAgentSizeIncreaseFactor(increaseFactorPercent)
                AgentSizeIncreaseFactor = 1.0 + (increaseFactorPercent / 100.0)
            end
            
            function ClickToMove:GetAgentSizeIncreaseFactor()
                return (AgentSizeIncreaseFactor - 1.0) * 100.0
            end
            
            function ClickToMove:SetUnreachableWaypointTimeout(timeoutInSec)
                UnreachableWaypointTimeout = timeoutInSec
            end
            
            function ClickToMove:GetUnreachableWaypointTimeout()
                return UnreachableWaypointTimeout
            end
            
            function ClickToMove:SetUserJumpEnabled(jumpEnabled)
                self.jumpEnabled = jumpEnabled
                if self.touchJumpController then
                    self.touchJumpController:Enable(jumpEnabled)
                end
            end
            
            function ClickToMove:GetUserJumpEnabled()
                return self.jumpEnabled
            end
            
            function ClickToMove:MoveTo(position, showPath, useDirectPath)
                local character = Player.Character
                if character == nil then
                    return false
                end
                local thisPather = Pather(position, Vector3.new(0, 1, 0), useDirectPath)
                if thisPather and thisPather:IsValidPath() then
                    HandleMoveTo(thisPather, position, nil, character, showPath)
                    return true
                end
                return false
            end
            
            return ClickToMove
        end
        
        function _TouchThumbstick()
            local Players = game:GetService("Players")
            local GuiService = game:GetService("GuiService")
            local UserInputService = game:GetService("UserInputService")
            --[[ Constants ]]--
            local ZERO_VECTOR3 = Vector3.new(0,0,0)
            local TOUCH_CONTROL_SHEET = "rbxasset://textures/ui/TouchControlsSheet.png"
            --[[ The Module ]]--
            local BaseCharacterController = _BaseCharacterController()
            local TouchThumbstick = setmetatable({}, BaseCharacterController)
            TouchThumbstick.__index = TouchThumbstick
            function TouchThumbstick.new()
                local self = setmetatable(BaseCharacterController.new(), TouchThumbstick)
                
                self.isFollowStick = false
                
                self.thumbstickFrame = nil
                self.moveTouchObject = nil
                self.onTouchMovedConn = nil
                self.onTouchEndedConn = nil
                self.screenPos = nil
                self.stickImage = nil
                self.thumbstickSize = nil -- Float
                
                return self
            end
            function TouchThumbstick:Enable(enable, uiParentFrame)
                if enable == nil then return false end			-- If nil, return false (invalid argument)
                enable = enable and true or false				-- Force anything non-nil to boolean before comparison
                if self.enabled == enable then return true end	-- If no state change, return true indicating already in requested state
                
                self.moveVector = ZERO_VECTOR3
                self.isJumping = false
                
                if enable then
                    -- Enable
                    if not self.thumbstickFrame then
                        self:Create(uiParentFrame)
                    end
                    self.thumbstickFrame.Visible = true
                else 
                    -- Disable
                    self.thumbstickFrame.Visible = false
                    self:OnInputEnded()
                end
                self.enabled = enable
            end
            function TouchThumbstick:OnInputEnded()
                self.thumbstickFrame.Position = self.screenPos
                self.stickImage.Position = UDim2.new(0, self.thumbstickFrame.Size.X.Offset/2 - self.thumbstickSize/4, 0, self.thumbstickFrame.Size.Y.Offset/2 - self.thumbstickSize/4)
                
                self.moveVector = ZERO_VECTOR3
                self.isJumping = false
                self.thumbstickFrame.Position = self.screenPos
                self.moveTouchObject = nil
            end
            function TouchThumbstick:Create(parentFrame)
                
                if self.thumbstickFrame then
                    self.thumbstickFrame:Destroy()
                    self.thumbstickFrame = nil
                    if self.onTouchMovedConn then
                        self.onTouchMovedConn:Disconnect()
                        self.onTouchMovedConn = nil
                    end
                    if self.onTouchEndedConn then
                        self.onTouchEndedConn:Disconnect()
                        self.onTouchEndedConn = nil
                    end
                end
                
                local minAxis = math.min(parentFrame.AbsoluteSize.x, parentFrame.AbsoluteSize.y)
                local isSmallScreen = minAxis <= 500
                self.thumbstickSize = isSmallScreen and 70 or 120
                self.screenPos = isSmallScreen and UDim2.new(0, (self.thumbstickSize/2) - 10, 1, -self.thumbstickSize - 20) or
                    UDim2.new(0, self.thumbstickSize/2, 1, -self.thumbstickSize * 1.75)
                    
                self.thumbstickFrame = Instance.new("Frame")
                self.thumbstickFrame.Name = "ThumbstickFrame"
                self.thumbstickFrame.Active = true
                self.thumbstickFrame.Visible = false
                self.thumbstickFrame.Size = UDim2.new(0, self.thumbstickSize, 0, self.thumbstickSize)
                self.thumbstickFrame.Position = self.screenPos
                self.thumbstickFrame.BackgroundTransparency = 1
                
                local outerImage = Instance.new("ImageLabel")
                outerImage.Name = "OuterImage"
                outerImage.Image = TOUCH_CONTROL_SHEET
                outerImage.ImageRectOffset = Vector2.new()
                outerImage.ImageRectSize = Vector2.new(220, 220)
                outerImage.BackgroundTransparency = 1
                outerImage.Size = UDim2.new(0, self.thumbstickSize, 0, self.thumbstickSize)
                outerImage.Position = UDim2.new(0, 0, 0, 0)
                outerImage.Parent = self.thumbstickFrame
                
                self.stickImage = Instance.new("ImageLabel")
                self.stickImage.Name = "StickImage"
                self.stickImage.Image = TOUCH_CONTROL_SHEET
                self.stickImage.ImageRectOffset = Vector2.new(220, 0)
                self.stickImage.ImageRectSize = Vector2.new(111, 111)
                self.stickImage.BackgroundTransparency = 1
                self.stickImage.Size = UDim2.new(0, self.thumbstickSize/2, 0, self.thumbstickSize/2)
                self.stickImage.Position = UDim2.new(0, self.thumbstickSize/2 - self.thumbstickSize/4, 0, self.thumbstickSize/2 - self.thumbstickSize/4)
                self.stickImage.ZIndex = 2
                self.stickImage.Parent = self.thumbstickFrame
                
                local centerPosition = nil
                local deadZone = 0.05
                
                local function DoMove(direction)
                    
                    local currentMoveVector = direction / (self.thumbstickSize/2)
                    
                    -- Scaled Radial Dead Zone
                    local inputAxisMagnitude = currentMoveVector.magnitude
                    if inputAxisMagnitude < deadZone then
                        currentMoveVector = Vector3.new()
                    else
                        currentMoveVector = currentMoveVector.unit * ((inputAxisMagnitude - deadZone) / (1 - deadZone))
                        -- NOTE: Making currentMoveVector a unit vector will cause the player to instantly go max speed
                        -- must check for zero length vector is using unit
                        currentMoveVector = Vector3.new(currentMoveVector.x, 0, currentMoveVector.y)
                    end
                    
                    self.moveVector = currentMoveVector
                end
                
                local function MoveStick(pos)
                    local relativePosition = Vector2.new(pos.x - centerPosition.x, pos.y - centerPosition.y)
                    local length = relativePosition.magnitude
                    local maxLength = self.thumbstickFrame.AbsoluteSize.x/2
                    if self.isFollowStick and length > maxLength then
                        local offset = relativePosition.unit * maxLength
                        self.thumbstickFrame.Position = UDim2.new(
                            0, pos.x - self.thumbstickFrame.AbsoluteSize.x/2 - offset.x,
                            0, pos.y - self.thumbstickFrame.AbsoluteSize.y/2 - offset.y)
                    else
                        length = math.min(length, maxLength)
                        relativePosition = relativePosition.unit * length
                    end
                    self.stickImage.Position = UDim2.new(0, relativePosition.x + self.stickImage.AbsoluteSize.x/2, 0, relativePosition.y + self.stickImage.AbsoluteSize.y/2)
                end
                
                -- input connections
                self.thumbstickFrame.InputBegan:Connect(function(inputObject)
                    --A touch that starts elsewhere on the screen will be sent to a frame's InputBegan event
                    --if it moves over the frame. So we check that this is actually a new touch (inputObject.UserInputState ~= Enum.UserInputState.Begin)
                    if self.moveTouchObject or inputObject.UserInputType ~= Enum.UserInputType.Touch
                        or inputObject.UserInputState ~= Enum.UserInputState.Begin then
                        return
                    end
                    
                    self.moveTouchObject = inputObject
                    self.thumbstickFrame.Position = UDim2.new(0, inputObject.Position.x - self.thumbstickFrame.Size.X.Offset/2, 0, inputObject.Position.y - self.thumbstickFrame.Size.Y.Offset/2)
                    centerPosition = Vector2.new(self.thumbstickFrame.AbsolutePosition.x + self.thumbstickFrame.AbsoluteSize.x/2,
                        self.thumbstickFrame.AbsolutePosition.y + self.thumbstickFrame.AbsoluteSize.y/2)
                    local direction = Vector2.new(inputObject.Position.x - centerPosition.x, inputObject.Position.y - centerPosition.y)
                end)
                
                self.onTouchMovedConn = UserInputService.TouchMoved:Connect(function(inputObject, isProcessed)
                    if inputObject == self.moveTouchObject then
                        centerPosition = Vector2.new(self.thumbstickFrame.AbsolutePosition.x + self.thumbstickFrame.AbsoluteSize.x/2,
                            self.thumbstickFrame.AbsolutePosition.y + self.thumbstickFrame.AbsoluteSize.y/2)
                        local direction = Vector2.new(inputObject.Position.x - centerPosition.x, inputObject.Position.y - centerPosition.y)
                        DoMove(direction)
                        MoveStick(inputObject.Position)
                    end
                end)
                
                self.onTouchEndedConn = UserInputService.TouchEnded:Connect(function(inputObject, isProcessed)
                    if inputObject == self.moveTouchObject then
                        self:OnInputEnded()
                    end
                end)
                
                GuiService.MenuOpened:Connect(function()
                    if self.moveTouchObject then
                        self:OnInputEnded()
                    end
                end)	
                
                self.thumbstickFrame.Parent = parentFrame
            end
            return TouchThumbstick
        end
        
        function _DynamicThumbstick()
            local ZERO_VECTOR3 = Vector3.new(0,0,0)
            local TOUCH_CONTROLS_SHEET = "rbxasset://textures/ui/Input/TouchControlsSheetV2.png"
            
            local DYNAMIC_THUMBSTICK_ACTION_NAME = "DynamicThumbstickAction"
            local DYNAMIC_THUMBSTICK_ACTION_PRIORITY = Enum.ContextActionPriority.High.Value
            
            local MIDDLE_TRANSPARENCIES = {
                1 - 0.89,
                1 - 0.70,
                1 - 0.60,
                1 - 0.50,
                1 - 0.40,
                1 - 0.30,
                1 - 0.25
            }
            local NUM_MIDDLE_IMAGES = #MIDDLE_TRANSPARENCIES
            
            local FADE_IN_OUT_BACKGROUND = true
            local FADE_IN_OUT_MAX_ALPHA = 0.35
            
            local FADE_IN_OUT_HALF_DURATION_DEFAULT = 0.3
            local FADE_IN_OUT_BALANCE_DEFAULT = 0.5
            local ThumbstickFadeTweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
            
            local Players = game:GetService("Players")
            local GuiService = game:GetService("GuiService")
            local UserInputService = game:GetService("UserInputService")
            local ContextActionService = game:GetService("ContextActionService")
            local RunService = game:GetService("RunService")
            local TweenService = game:GetService("TweenService")
            
            local LocalPlayer = Players.LocalPlayer
            if not LocalPlayer then
                Players:GetPropertyChangedSignal("LocalPlayer"):Wait()
                LocalPlayer = Players.LocalPlayer
            end
            
            --[[ The Module ]]--
            local BaseCharacterController = _BaseCharacterController()
            local DynamicThumbstick = setmetatable({}, BaseCharacterController)
            DynamicThumbstick.__index = DynamicThumbstick
            
            function DynamicThumbstick.new()
                local self = setmetatable(BaseCharacterController.new(), DynamicThumbstick)
            
                self.moveTouchObject = nil
                self.moveTouchLockedIn = false
                self.moveTouchFirstChanged = false
                self.moveTouchStartPosition = nil
            
                self.startImage = nil
                self.endImage = nil
                self.middleImages = {}
            
                self.startImageFadeTween = nil
                self.endImageFadeTween = nil
                self.middleImageFadeTweens = {}
            
                self.isFirstTouch = true
            
                self.thumbstickFrame = nil
            
                self.onRenderSteppedConn = nil
            
                self.fadeInAndOutBalance = FADE_IN_OUT_BALANCE_DEFAULT
                self.fadeInAndOutHalfDuration = FADE_IN_OUT_HALF_DURATION_DEFAULT
                self.hasFadedBackgroundInPortrait = false
                self.hasFadedBackgroundInLandscape = false
            
                self.tweenInAlphaStart = nil
                self.tweenOutAlphaStart = nil
            
                return self
            end
            
            -- Note: Overrides base class GetIsJumping with get-and-clear behavior to do a single jump
            -- rather than sustained jumping. This is only to preserve the current behavior through the refactor.
            function DynamicThumbstick:GetIsJumping()
                local wasJumping = self.isJumping
                self.isJumping = false
                return wasJumping
            end
            
            function DynamicThumbstick:Enable(enable, uiParentFrame)
                if enable == nil then return false end			-- If nil, return false (invalid argument)
                enable = enable and true or false				-- Force anything non-nil to boolean before comparison
                if self.enabled == enable then return true end	-- If no state change, return true indicating already in requested state
            
                if enable then
                    -- Enable
                    if not self.thumbstickFrame then
                        self:Create(uiParentFrame)
                    end
            
                    self:BindContextActions()
                else
                    ContextActionService:UnbindAction(DYNAMIC_THUMBSTICK_ACTION_NAME)
                    -- Disable
                    self:OnInputEnded() -- Cleanup
                end
            
                self.enabled = enable
                self.thumbstickFrame.Visible = enable
            end
            
            -- Was called OnMoveTouchEnded in previous version
            function DynamicThumbstick:OnInputEnded()
                self.moveTouchObject = nil
                self.moveVector = ZERO_VECTOR3
                self:FadeThumbstick(false)
            end
            
            function DynamicThumbstick:FadeThumbstick(visible)
                if not visible and self.moveTouchObject then
                    return
                end
                if self.isFirstTouch then return end
            
                if self.startImageFadeTween then
                    self.startImageFadeTween:Cancel()
                end
                if self.endImageFadeTween then
                    self.endImageFadeTween:Cancel()
                end
                for i = 1, #self.middleImages do
                    if self.middleImageFadeTweens[i] then
                        self.middleImageFadeTweens[i]:Cancel()
                    end
                end
            
                if visible then
                    self.startImageFadeTween = TweenService:Create(self.startImage, ThumbstickFadeTweenInfo, { ImageTransparency = 0 })
                    self.startImageFadeTween:Play()
            
                    self.endImageFadeTween = TweenService:Create(self.endImage, ThumbstickFadeTweenInfo, { ImageTransparency = 0.2 })
                    self.endImageFadeTween:Play()
            
                    for i = 1, #self.middleImages do
                        self.middleImageFadeTweens[i] = TweenService:Create(self.middleImages[i], ThumbstickFadeTweenInfo, { ImageTransparency = MIDDLE_TRANSPARENCIES[i] })
                        self.middleImageFadeTweens[i]:Play()
                    end
                else
                    self.startImageFadeTween = TweenService:Create(self.startImage, ThumbstickFadeTweenInfo, { ImageTransparency = 1 })
                    self.startImageFadeTween:Play()
            
                    self.endImageFadeTween = TweenService:Create(self.endImage, ThumbstickFadeTweenInfo, { ImageTransparency = 1 })
                    self.endImageFadeTween:Play()
            
                    for i = 1, #self.middleImages do
                        self.middleImageFadeTweens[i] = TweenService:Create(self.middleImages[i], ThumbstickFadeTweenInfo, { ImageTransparency = 1 })
                        self.middleImageFadeTweens[i]:Play()
                    end
                end
            end
            
            function DynamicThumbstick:FadeThumbstickFrame(fadeDuration, fadeRatio)
                self.fadeInAndOutHalfDuration = fadeDuration * 0.5
                self.fadeInAndOutBalance = fadeRatio
                self.tweenInAlphaStart = tick()
            end
            
            function DynamicThumbstick:InputInFrame(inputObject)
                local frameCornerTopLeft = self.thumbstickFrame.AbsolutePosition
                local frameCornerBottomRight = frameCornerTopLeft + self.thumbstickFrame.AbsoluteSize
                local inputPosition = inputObject.Position
                if inputPosition.X >= frameCornerTopLeft.X and inputPosition.Y >= frameCornerTopLeft.Y then
                    if inputPosition.X <= frameCornerBottomRight.X and inputPosition.Y <= frameCornerBottomRight.Y then
                        return true
                    end
                end
                return false
            end
            
            function DynamicThumbstick:DoFadeInBackground()
                local playerGui = LocalPlayer:FindFirstChildOfClass("PlayerGui")
                local hasFadedBackgroundInOrientation = false
            
                -- only fade in/out the background once per orientation
                if playerGui then
                    if playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.LandscapeLeft or
                        playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.LandscapeRight then
                            hasFadedBackgroundInOrientation = self.hasFadedBackgroundInLandscape
                            self.hasFadedBackgroundInLandscape = true
                    elseif playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.Portrait then
                            hasFadedBackgroundInOrientation = self.hasFadedBackgroundInPortrait
                            self.hasFadedBackgroundInPortrait = true
                    end
                end
            
                if not hasFadedBackgroundInOrientation then
                    self.fadeInAndOutHalfDuration = FADE_IN_OUT_HALF_DURATION_DEFAULT
                    self.fadeInAndOutBalance = FADE_IN_OUT_BALANCE_DEFAULT
                    self.tweenInAlphaStart = tick()
                end
            end
            
            function DynamicThumbstick:DoMove(direction)
                local currentMoveVector = direction
            
                -- Scaled Radial Dead Zone
                local inputAxisMagnitude = currentMoveVector.magnitude
                if inputAxisMagnitude < self.radiusOfDeadZone then
                    currentMoveVector = ZERO_VECTOR3
                else
                    currentMoveVector = currentMoveVector.unit*(
                        1 - math.max(0, (self.radiusOfMaxSpeed - currentMoveVector.magnitude)/self.radiusOfMaxSpeed)
                    )
                    currentMoveVector = Vector3.new(currentMoveVector.x, 0, currentMoveVector.y)
                end
            
                self.moveVector = currentMoveVector
            end
            
            
            function DynamicThumbstick:LayoutMiddleImages(startPos, endPos)
                local startDist = (self.thumbstickSize / 2) + self.middleSize
                local vector = endPos - startPos
                local distAvailable = vector.magnitude - (self.thumbstickRingSize / 2) - self.middleSize
                local direction = vector.unit
            
                local distNeeded = self.middleSpacing * NUM_MIDDLE_IMAGES
                local spacing = self.middleSpacing
            
                if distNeeded < distAvailable then
                    spacing = distAvailable / NUM_MIDDLE_IMAGES
                end
            
                for i = 1, NUM_MIDDLE_IMAGES do
                    local image = self.middleImages[i]
                    local distWithout = startDist + (spacing * (i - 2))
                    local currentDist = startDist + (spacing * (i - 1))
            
                    if distWithout < distAvailable then
                        local pos = endPos - direction * currentDist
                        local exposedFraction = math.clamp(1 - ((currentDist - distAvailable) / spacing), 0, 1)
            
                        image.Visible = true
                        image.Position = UDim2.new(0, pos.X, 0, pos.Y)
                        image.Size = UDim2.new(0, self.middleSize * exposedFraction, 0, self.middleSize * exposedFraction)
                    else
                        image.Visible = false
                    end
                end
            end
            
            function DynamicThumbstick:MoveStick(pos)
                local vector2StartPosition = Vector2.new(self.moveTouchStartPosition.X, self.moveTouchStartPosition.Y)
                local startPos = vector2StartPosition - self.thumbstickFrame.AbsolutePosition
                local endPos = Vector2.new(pos.X, pos.Y) - self.thumbstickFrame.AbsolutePosition
                self.endImage.Position = UDim2.new(0, endPos.X, 0, endPos.Y)
                self:LayoutMiddleImages(startPos, endPos)
            end
            
            function DynamicThumbstick:BindContextActions()
                local function inputBegan(inputObject)
                    if self.moveTouchObject then
                        return Enum.ContextActionResult.Pass
                    end
            
                    if not self:InputInFrame(inputObject) then
                        return Enum.ContextActionResult.Pass
                    end
            
                    if self.isFirstTouch then
                        self.isFirstTouch = false
                        local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out,0,false,0)
                        TweenService:Create(self.startImage, tweenInfo, {Size = UDim2.new(0, 0, 0, 0)}):Play()
                        TweenService:Create(
                            self.endImage,
                            tweenInfo,
                            {Size = UDim2.new(0, self.thumbstickSize, 0, self.thumbstickSize), ImageColor3 = Color3.new(0,0,0)}
                        ):Play()
                    end
            
                    self.moveTouchLockedIn = false
                    self.moveTouchObject = inputObject
                    self.moveTouchStartPosition = inputObject.Position
                    self.moveTouchFirstChanged = true
            
                    if FADE_IN_OUT_BACKGROUND then
                        self:DoFadeInBackground()
                    end
            
                    return Enum.ContextActionResult.Pass
                end
            
                local function inputChanged(inputObject)
                    if inputObject == self.moveTouchObject then
                        if self.moveTouchFirstChanged then
                            self.moveTouchFirstChanged = false
            
                            local startPosVec2 = Vector2.new(
                                inputObject.Position.X - self.thumbstickFrame.AbsolutePosition.X,
                                inputObject.Position.Y - self.thumbstickFrame.AbsolutePosition.Y
                            )
                            self.startImage.Visible = true
                            self.startImage.Position = UDim2.new(0, startPosVec2.X, 0, startPosVec2.Y)
                            self.endImage.Visible = true
                            self.endImage.Position = self.startImage.Position
            
                            self:FadeThumbstick(true)
                            self:MoveStick(inputObject.Position)
                        end
            
                        self.moveTouchLockedIn = true
            
                        local direction = Vector2.new(
                            inputObject.Position.x - self.moveTouchStartPosition.x,
                            inputObject.Position.y - self.moveTouchStartPosition.y
                        )
                        if math.abs(direction.x) > 0 or math.abs(direction.y) > 0 then
                            self:DoMove(direction)
                            self:MoveStick(inputObject.Position)
                        end
                        return Enum.ContextActionResult.Sink
                    end
                    return Enum.ContextActionResult.Pass
                end
            
                local function inputEnded(inputObject)
                    if inputObject == self.moveTouchObject then
                        self:OnInputEnded()
                        if self.moveTouchLockedIn then
                            return Enum.ContextActionResult.Sink
                        end
                    end
                    return Enum.ContextActionResult.Pass
                end
            
                local function handleInput(actionName, inputState, inputObject)
                    if inputState == Enum.UserInputState.Begin then
                        return inputBegan(inputObject)
                    elseif inputState == Enum.UserInputState.Change then
                        return inputChanged(inputObject)
                    elseif inputState == Enum.UserInputState.End then
                        return inputEnded(inputObject)
                    elseif inputState == Enum.UserInputState.Cancel then
                        self:OnInputEnded()
                    end
                end
            
                ContextActionService:BindActionAtPriority(
                    DYNAMIC_THUMBSTICK_ACTION_NAME,
                    handleInput,
                    false,
                    DYNAMIC_THUMBSTICK_ACTION_PRIORITY,
                    Enum.UserInputType.Touch)
            end
            
            function DynamicThumbstick:Create(parentFrame)
                if self.thumbstickFrame then
                    self.thumbstickFrame:Destroy()
                    self.thumbstickFrame = nil
                    if self.onRenderSteppedConn then
                        self.onRenderSteppedConn:Disconnect()
                        self.onRenderSteppedConn = nil
                    end
                end
            
                self.thumbstickSize = 45
                self.thumbstickRingSize = 20
                self.middleSize = 10
                self.middleSpacing = self.middleSize + 4
                self.radiusOfDeadZone = 2
                self.radiusOfMaxSpeed = 20
            
                local screenSize = parentFrame.AbsoluteSize
                local isBigScreen = math.min(screenSize.x, screenSize.y) > 500
                if isBigScreen then
                    self.thumbstickSize = self.thumbstickSize * 2
                    self.thumbstickRingSize = self.thumbstickRingSize * 2
                    self.middleSize = self.middleSize * 2
                    self.middleSpacing = self.middleSpacing * 2
                    self.radiusOfDeadZone = self.radiusOfDeadZone * 2
                    self.radiusOfMaxSpeed = self.radiusOfMaxSpeed * 2
                end
            
                local function layoutThumbstickFrame(portraitMode)
                    if portraitMode then
                        self.thumbstickFrame.Size = UDim2.new(1, 0, 0.4, 0)
                        self.thumbstickFrame.Position = UDim2.new(0, 0, 0.6, 0)
                    else
                        self.thumbstickFrame.Size = UDim2.new(0.4, 0, 2/3, 0)
                        self.thumbstickFrame.Position = UDim2.new(0, 0, 1/3, 0)
                    end
                end
            
                self.thumbstickFrame = Instance.new("Frame")
                self.thumbstickFrame.BorderSizePixel = 0
                self.thumbstickFrame.Name = "DynamicThumbstickFrame"
                self.thumbstickFrame.Visible = false
                self.thumbstickFrame.BackgroundTransparency = 1.0
                self.thumbstickFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
                self.thumbstickFrame.Active = false
                layoutThumbstickFrame(false)
            
                self.startImage = Instance.new("ImageLabel")
                self.startImage.Name = "ThumbstickStart"
                self.startImage.Visible = true
                self.startImage.BackgroundTransparency = 1
                self.startImage.Image = TOUCH_CONTROLS_SHEET
                self.startImage.ImageRectOffset = Vector2.new(1,1)
                self.startImage.ImageRectSize = Vector2.new(144, 144)
                self.startImage.ImageColor3 = Color3.new(0, 0, 0)
                self.startImage.AnchorPoint = Vector2.new(0.5, 0.5)
                self.startImage.Position = UDim2.new(0, self.thumbstickRingSize * 3.3, 1, -self.thumbstickRingSize  * 2.8)
                self.startImage.Size = UDim2.new(0, self.thumbstickRingSize  * 3.7, 0, self.thumbstickRingSize  * 3.7)
                self.startImage.ZIndex = 10
                self.startImage.Parent = self.thumbstickFrame
            
                self.endImage = Instance.new("ImageLabel")
                self.endImage.Name = "ThumbstickEnd"
                self.endImage.Visible = true
                self.endImage.BackgroundTransparency = 1
                self.endImage.Image = TOUCH_CONTROLS_SHEET
                self.endImage.ImageRectOffset = Vector2.new(1,1)
                self.endImage.ImageRectSize =  Vector2.new(144, 144)
                self.endImage.AnchorPoint = Vector2.new(0.5, 0.5)
                self.endImage.Position = self.startImage.Position
                self.endImage.Size = UDim2.new(0, self.thumbstickSize * 0.8, 0, self.thumbstickSize * 0.8)
                self.endImage.ZIndex = 10
                self.endImage.Parent = self.thumbstickFrame
            
                for i = 1, NUM_MIDDLE_IMAGES do
                    self.middleImages[i] = Instance.new("ImageLabel")
                    self.middleImages[i].Name = "ThumbstickMiddle"
                    self.middleImages[i].Visible = false
                    self.middleImages[i].BackgroundTransparency = 1
                    self.middleImages[i].Image = TOUCH_CONTROLS_SHEET
                    self.middleImages[i].ImageRectOffset = Vector2.new(1,1)
                    self.middleImages[i].ImageRectSize = Vector2.new(144, 144)
                    self.middleImages[i].ImageTransparency = MIDDLE_TRANSPARENCIES[i]
                    self.middleImages[i].AnchorPoint = Vector2.new(0.5, 0.5)
                    self.middleImages[i].ZIndex = 9
                    self.middleImages[i].Parent = self.thumbstickFrame
                end
            
                local CameraChangedConn = nil
                local function onCurrentCameraChanged()
                    if CameraChangedConn then
                        CameraChangedConn:Disconnect()
                        CameraChangedConn = nil
                    end
                    local newCamera = workspace.CurrentCamera
                    if newCamera then
                        local function onViewportSizeChanged()
                            local size = newCamera.ViewportSize
                            local portraitMode = size.X < size.Y
                            layoutThumbstickFrame(portraitMode)
                        end
                        CameraChangedConn = newCamera:GetPropertyChangedSignal("ViewportSize"):Connect(onViewportSizeChanged)
                        onViewportSizeChanged()
                    end
                end
                workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(onCurrentCameraChanged)
                if workspace.CurrentCamera then
                    onCurrentCameraChanged()
                end
            
                self.moveTouchStartPosition = nil
            
                self.startImageFadeTween = nil
                self.endImageFadeTween = nil
                self.middleImageFadeTweens = {}
            
                self.onRenderSteppedConn = RunService.RenderStepped:Connect(function()
                    if self.tweenInAlphaStart ~= nil then
                        local delta = tick() - self.tweenInAlphaStart
                        local fadeInTime = (self.fadeInAndOutHalfDuration * 2 * self.fadeInAndOutBalance)
                        self.thumbstickFrame.BackgroundTransparency = 1 - FADE_IN_OUT_MAX_ALPHA*math.min(delta/fadeInTime, 1)
                        if delta > fadeInTime then
                            self.tweenOutAlphaStart = tick()
                            self.tweenInAlphaStart = nil
                        end
                    elseif self.tweenOutAlphaStart ~= nil then
                        local delta = tick() - self.tweenOutAlphaStart
                        local fadeOutTime = (self.fadeInAndOutHalfDuration * 2) - (self.fadeInAndOutHalfDuration * 2 * self.fadeInAndOutBalance)
                        self.thumbstickFrame.BackgroundTransparency = 1 - FADE_IN_OUT_MAX_ALPHA + FADE_IN_OUT_MAX_ALPHA*math.min(delta/fadeOutTime, 1)
                        if delta > fadeOutTime  then
                            self.tweenOutAlphaStart = nil
                        end
                    end
                end)
            
                self.onTouchEndedConn = UserInputService.TouchEnded:connect(function(inputObject)
                    if inputObject == self.moveTouchObject then
                        self:OnInputEnded()
                    end
                end)
            
                GuiService.MenuOpened:connect(function()
                    if self.moveTouchObject then
                        self:OnInputEnded()
                    end
                end)
            
                local playerGui = LocalPlayer:FindFirstChildOfClass("PlayerGui")
                while not playerGui do
                    LocalPlayer.ChildAdded:wait()
                    playerGui = LocalPlayer:FindFirstChildOfClass("PlayerGui")
                end
            
                local playerGuiChangedConn = nil
                local originalScreenOrientationWasLandscape =	playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.LandscapeLeft or
                                                                playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.LandscapeRight
            
                local function longShowBackground()
                    self.fadeInAndOutHalfDuration = 2.5
                    self.fadeInAndOutBalance = 0.05
                    self.tweenInAlphaStart = tick()
                end
            
                playerGuiChangedConn = playerGui:GetPropertyChangedSignal("CurrentScreenOrientation"):Connect(function()
                    if (originalScreenOrientationWasLandscape and playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.Portrait) or
                        (not originalScreenOrientationWasLandscape and playerGui.CurrentScreenOrientation ~= Enum.ScreenOrientation.Portrait) then
            
                        playerGuiChangedConn:disconnect()
                        longShowBackground()
            
                        if originalScreenOrientationWasLandscape then
                            self.hasFadedBackgroundInPortrait = true
                        else
                            self.hasFadedBackgroundInLandscape = true
                        end
                    end
                end)
            
                self.thumbstickFrame.Parent = parentFrame
            
                if game:IsLoaded() then
                    longShowBackground()
                else
                    coroutine.wrap(function()
                        game.Loaded:Wait()
                        longShowBackground()
                    end)()
                end
            end
            
            return DynamicThumbstick
        end
        
        function _Gamepad()
            local UserInputService = game:GetService("UserInputService")
            local ContextActionService = game:GetService("ContextActionService")
            
            --[[ Constants ]]--
            local ZERO_VECTOR3 = Vector3.new(0,0,0)
            local NONE = Enum.UserInputType.None
            local thumbstickDeadzone = 0.2
            
            --[[ The Module ]]--
            local BaseCharacterController = _BaseCharacterController()
            local Gamepad = setmetatable({}, BaseCharacterController)
            Gamepad.__index = Gamepad
            
            function Gamepad.new(CONTROL_ACTION_PRIORITY)
                local self = setmetatable(BaseCharacterController.new(), Gamepad)
            
                self.CONTROL_ACTION_PRIORITY = CONTROL_ACTION_PRIORITY
            
                self.forwardValue  = 0
                self.backwardValue = 0
                self.leftValue = 0
                self.rightValue = 0
            
                self.activeGamepad = NONE	-- Enum.UserInputType.Gamepad1, 2, 3...
                self.gamepadConnectedConn = nil
                self.gamepadDisconnectedConn = nil
                return self
            end
            
            function Gamepad:Enable(enable)
                if not UserInputService.GamepadEnabled then
                    return false
                end
            
                if enable == self.enabled then
                    -- Module is already in the state being requested. True is returned here since the module will be in the state
                    -- expected by the code that follows the Enable() call. This makes more sense than returning false to indicate
                    -- no action was necessary. False indicates failure to be in requested/expected state.
                    return true
                end
            
                self.forwardValue  = 0
                self.backwardValue = 0
                self.leftValue = 0
                self.rightValue = 0
                self.moveVector = ZERO_VECTOR3
                self.isJumping = false
            
                if enable then
                    self.activeGamepad = self:GetHighestPriorityGamepad()
                    if self.activeGamepad ~= NONE then
                        self:BindContextActions()
                        self:ConnectGamepadConnectionListeners()
                    else
                        -- No connected gamepads, failure to enable
                        return false
                    end
                else
                    self:UnbindContextActions()
                    self:DisconnectGamepadConnectionListeners()
                    self.activeGamepad = NONE
                end
            
                self.enabled = enable
                return true
            end
            
            -- This function selects the lowest number gamepad from the currently-connected gamepad
            -- and sets it as the active gamepad
            function Gamepad:GetHighestPriorityGamepad()
                local connectedGamepads = UserInputService:GetConnectedGamepads()
                local bestGamepad = NONE -- Note that this value is higher than all valid gamepad values
                for _, gamepad in pairs(connectedGamepads) do
                    if gamepad.Value < bestGamepad.Value then
                        bestGamepad = gamepad
                    end
                end
                return bestGamepad
            end
            
            function Gamepad:BindContextActions()
            
                if self.activeGamepad == NONE then
                    -- There must be an active gamepad to set up bindings
                    return false
                end
            
                local handleJumpAction = function(actionName, inputState, inputObject)
                    self.isJumping = (inputState == Enum.UserInputState.Begin)
                    return Enum.ContextActionResult.Sink
                end
            
                local handleThumbstickInput = function(actionName, inputState, inputObject)
            
                    if inputState == Enum.UserInputState.Cancel then
                        self.moveVector = ZERO_VECTOR3
                        return Enum.ContextActionResult.Sink
                    end
            
                    if self.activeGamepad ~= inputObject.UserInputType then
                        return Enum.ContextActionResult.Pass
                    end
                    if inputObject.KeyCode ~= Enum.KeyCode.Thumbstick1 then return end
            
                    if inputObject.Position.magnitude > thumbstickDeadzone then
                        self.moveVector  =  Vector3.new(inputObject.Position.X, 0, -inputObject.Position.Y)
                    else
                        self.moveVector = ZERO_VECTOR3
                    end
                    return Enum.ContextActionResult.Sink
                end
            
                ContextActionService:BindActivate(self.activeGamepad, Enum.KeyCode.ButtonR2)
                ContextActionService:BindActionAtPriority("jumpAction", handleJumpAction, false,
                    self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.ButtonA)
                ContextActionService:BindActionAtPriority("moveThumbstick", handleThumbstickInput, false,
                    self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.Thumbstick1)
            
                return true
            end
            
            function Gamepad:UnbindContextActions()
                if self.activeGamepad ~= NONE then
                    ContextActionService:UnbindActivate(self.activeGamepad, Enum.KeyCode.ButtonR2)
                end
                ContextActionService:UnbindAction("moveThumbstick")
                ContextActionService:UnbindAction("jumpAction")
            end
            
            function Gamepad:OnNewGamepadConnected()
                -- A new gamepad has been connected.
                local bestGamepad = self:GetHighestPriorityGamepad()
            
                if bestGamepad == self.activeGamepad then
                    -- A new gamepad was connected, but our active gamepad is not changing
                    return
                end
            
                if bestGamepad == NONE then
                    -- There should be an active gamepad when GamepadConnected fires, so this should not
                    -- normally be hit. If there is no active gamepad, unbind actions but leave
                    -- the module enabled and continue to listen for a new gamepad connection.
                    warn("Gamepad:OnNewGamepadConnected found no connected gamepads")
                    self:UnbindContextActions()
                    return
                end
            
                if self.activeGamepad ~= NONE then
                    -- Switching from one active gamepad to another
                    self:UnbindContextActions()
                end
            
                self.activeGamepad = bestGamepad
                self:BindContextActions()
            end
            
            function Gamepad:OnCurrentGamepadDisconnected()
                if self.activeGamepad ~= NONE then
                    ContextActionService:UnbindActivate(self.activeGamepad, Enum.KeyCode.ButtonR2)
                end
            
                local bestGamepad = self:GetHighestPriorityGamepad()
            
                if self.activeGamepad ~= NONE and bestGamepad == self.activeGamepad then
                    warn("Gamepad:OnCurrentGamepadDisconnected found the supposedly disconnected gamepad in connectedGamepads.")
                    self:UnbindContextActions()
                    self.activeGamepad = NONE
                    return
                end
            
                if bestGamepad == NONE then
                    -- No active gamepad, unbinding actions but leaving gamepad connection listener active
                    self:UnbindContextActions()
                    self.activeGamepad = NONE
                else
                    -- Set new gamepad as active and bind to tool activation
                    self.activeGamepad = bestGamepad
                    ContextActionService:BindActivate(self.activeGamepad, Enum.KeyCode.ButtonR2)
                end
            end
            
            function Gamepad:ConnectGamepadConnectionListeners()
                self.gamepadConnectedConn = UserInputService.GamepadConnected:Connect(function(gamepadEnum)
                    self:OnNewGamepadConnected()
                end)
            
                self.gamepadDisconnectedConn = UserInputService.GamepadDisconnected:Connect(function(gamepadEnum)
                    if self.activeGamepad == gamepadEnum then
                        self:OnCurrentGamepadDisconnected()
                    end
                end)
            
            end
            
            function Gamepad:DisconnectGamepadConnectionListeners()
                if self.gamepadConnectedConn then
                    self.gamepadConnectedConn:Disconnect()
                    self.gamepadConnectedConn = nil
                end
            
                if self.gamepadDisconnectedConn then
                    self.gamepadDisconnectedConn:Disconnect()
                    self.gamepadDisconnectedConn = nil
                end
            end
            
            return Gamepad
        end
        
        function _Keyboard()
            
            --[[ Roblox Services ]]--
            local UserInputService = game:GetService("UserInputService")
            local ContextActionService = game:GetService("ContextActionService")
            
            --[[ Constants ]]--
            local ZERO_VECTOR3 = Vector3.new(0,0,0)
            
            --[[ The Module ]]--
            local BaseCharacterController = _BaseCharacterController()
            local Keyboard = setmetatable({}, BaseCharacterController)
            Keyboard.__index = Keyboard
            
            function Keyboard.new(CONTROL_ACTION_PRIORITY)
                local self = setmetatable(BaseCharacterController.new(), Keyboard)
            
                self.CONTROL_ACTION_PRIORITY = CONTROL_ACTION_PRIORITY
            
                self.textFocusReleasedConn = nil
                self.textFocusGainedConn = nil
                self.windowFocusReleasedConn = nil
            
                self.forwardValue  = 0
                self.backwardValue = 0
                self.leftValue = 0
                self.rightValue = 0
            
                self.jumpEnabled = true
            
                return self
            end
            
            function Keyboard:Enable(enable)
                if not UserInputService.KeyboardEnabled then
                    return false
                end
            
                if enable == self.enabled then
                    -- Module is already in the state being requested. True is returned here since the module will be in the state
                    -- expected by the code that follows the Enable() call. This makes more sense than returning false to indicate
                    -- no action was necessary. False indicates failure to be in requested/expected state.
                    return true
                end
            
                self.forwardValue  = 0
                self.backwardValue = 0
                self.leftValue = 0
                self.rightValue = 0
                self.moveVector = ZERO_VECTOR3
                self.jumpRequested = false
                self:UpdateJump()
            
                if enable then
                    self:BindContextActions()
                    self:ConnectFocusEventListeners()
                else
                    self:UnbindContextActions()
                    self:DisconnectFocusEventListeners()
                end
            
                self.enabled = enable
                return true
            end
            
            function Keyboard:UpdateMovement(inputState)
                if inputState == Enum.UserInputState.Cancel then
                    self.moveVector = ZERO_VECTOR3
                else
                    self.moveVector = Vector3.new(self.leftValue + self.rightValue, 0, self.forwardValue + self.backwardValue)
                end
            end
            
            function Keyboard:UpdateJump()
                self.isJumping = self.jumpRequested
            end
            
            function Keyboard:BindContextActions()
            
                -- Note: In the previous version of this code, the movement values were not zeroed-out on UserInputState. Cancel, now they are,
                -- which fixes them from getting stuck on.
                -- We return ContextActionResult.Pass here for legacy reasons.
                -- Many games rely on gameProcessedEvent being false on UserInputService.InputBegan for these control actions.
                local handleMoveForward = function(actionName, inputState, inputObject)
                    self.forwardValue = (inputState == Enum.UserInputState.Begin) and -1 or 0
                    self:UpdateMovement(inputState)
                    return Enum.ContextActionResult.Pass
                end
            
                local handleMoveBackward = function(actionName, inputState, inputObject)
                    self.backwardValue = (inputState == Enum.UserInputState.Begin) and 1 or 0
                    self:UpdateMovement(inputState)
                    return Enum.ContextActionResult.Pass
                end
            
                local handleMoveLeft = function(actionName, inputState, inputObject)
                    self.leftValue = (inputState == Enum.UserInputState.Begin) and -1 or 0
                    self:UpdateMovement(inputState)
                    return Enum.ContextActionResult.Pass
                end
            
                local handleMoveRight = function(actionName, inputState, inputObject)
                    self.rightValue = (inputState == Enum.UserInputState.Begin) and 1 or 0
                    self:UpdateMovement(inputState)
                    return Enum.ContextActionResult.Pass
                end
            
                local handleJumpAction = function(actionName, inputState, inputObject)
                    self.jumpRequested = self.jumpEnabled and (inputState == Enum.UserInputState.Begin)
                    self:UpdateJump()
                    return Enum.ContextActionResult.Pass
                end
            
                -- TODO: Revert to KeyCode bindings so that in the future the abstraction layer from actual keys to
                -- movement direction is done in Lua
                ContextActionService:BindActionAtPriority("moveForwardAction", handleMoveForward, false,
                    self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterForward)
                ContextActionService:BindActionAtPriority("moveBackwardAction", handleMoveBackward, false,
                    self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterBackward)
                ContextActionService:BindActionAtPriority("moveLeftAction", handleMoveLeft, false,
                    self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterLeft)
                ContextActionService:BindActionAtPriority("moveRightAction", handleMoveRight, false,
                    self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterRight)
                ContextActionService:BindActionAtPriority("jumpAction", handleJumpAction, false,
                    self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterJump)
            end
            
            function Keyboard:UnbindContextActions()
                ContextActionService:UnbindAction("moveForwardAction")
                ContextActionService:UnbindAction("moveBackwardAction")
                ContextActionService:UnbindAction("moveLeftAction")
                ContextActionService:UnbindAction("moveRightAction")
                ContextActionService:UnbindAction("jumpAction")
            end
            
            function Keyboard:ConnectFocusEventListeners()
                local function onFocusReleased()
                    self.moveVector = ZERO_VECTOR3
                    self.forwardValue  = 0
                    self.backwardValue = 0
                    self.leftValue = 0
                    self.rightValue = 0
                    self.jumpRequested = false
                    self:UpdateJump()
                end
            
                local function onTextFocusGained(textboxFocused)
                    self.jumpRequested = false
                    self:UpdateJump()
                end
            
                self.textFocusReleasedConn = UserInputService.TextBoxFocusReleased:Connect(onFocusReleased)
                self.textFocusGainedConn = UserInputService.TextBoxFocused:Connect(onTextFocusGained)
                self.windowFocusReleasedConn = UserInputService.WindowFocused:Connect(onFocusReleased)
            end
            
            function Keyboard:DisconnectFocusEventListeners()
                if self.textFocusReleasedCon then
                    self.textFocusReleasedCon:Disconnect()
                    self.textFocusReleasedCon = nil
                end
                if self.textFocusGainedConn then
                    self.textFocusGainedConn:Disconnect()
                    self.textFocusGainedConn = nil
                end
                if self.windowFocusReleasedConn then
                    self.windowFocusReleasedConn:Disconnect()
                    self.windowFocusReleasedConn = nil
                end
            end
            
            return Keyboard
        end
        
        function _ControlModule()
            local ControlModule = {}
            ControlModule.__index = ControlModule
            
            --[[ Roblox Services ]]--
            local Players = game:GetService("Players")
            local RunService = game:GetService("RunService")
            local UserInputService = game:GetService("UserInputService")
            local Workspace = game:GetService("Workspace")
            local UserGameSettings = UserSettings():GetService("UserGameSettings")
            
            -- Roblox User Input Control Modules - each returns a new() constructor function used to create controllers as needed
            local Keyboard = _Keyboard()
            local Gamepad = _Gamepad()
            local DynamicThumbstick = _DynamicThumbstick()
            
            local FFlagUserMakeThumbstickDynamic do
                local success, value = pcall(function()
                    return UserSettings():IsUserFeatureEnabled("UserMakeThumbstickDynamic")
                end)
                FFlagUserMakeThumbstickDynamic = success and value
            end
            
            local TouchThumbstick = FFlagUserMakeThumbstickDynamic and DynamicThumbstick or _TouchThumbstick()
            
            -- These controllers handle only walk/run movement, jumping is handled by the
            -- TouchJump controller if any of these are active
            local ClickToMove = _ClickToMoveController()
            local TouchJump = _TouchJump()
            
            local VehicleController = _VehicleController()
            
            local CONTROL_ACTION_PRIORITY = Enum.ContextActionPriority.Default.Value
            
            -- Mapping from movement mode and lastInputType enum values to control modules to avoid huge if elseif switching
            local movementEnumToModuleMap = {
                [Enum.TouchMovementMode.DPad] = DynamicThumbstick,
                [Enum.DevTouchMovementMode.DPad] = DynamicThumbstick,
                [Enum.TouchMovementMode.Thumbpad] = DynamicThumbstick,
                [Enum.DevTouchMovementMode.Thumbpad] = DynamicThumbstick,
                [Enum.TouchMovementMode.Thumbstick] = TouchThumbstick,
                [Enum.DevTouchMovementMode.Thumbstick] = TouchThumbstick,
                [Enum.TouchMovementMode.DynamicThumbstick] = DynamicThumbstick,
                [Enum.DevTouchMovementMode.DynamicThumbstick] = DynamicThumbstick,
                [Enum.TouchMovementMode.ClickToMove] = ClickToMove,
                [Enum.DevTouchMovementMode.ClickToMove] = ClickToMove,
            
                -- Current default
                [Enum.TouchMovementMode.Default] = DynamicThumbstick,
            
                [Enum.ComputerMovementMode.Default] = Keyboard,
                [Enum.ComputerMovementMode.KeyboardMouse] = Keyboard,
                [Enum.DevComputerMovementMode.KeyboardMouse] = Keyboard,
                [Enum.DevComputerMovementMode.Scriptable] = nil,
                [Enum.ComputerMovementMode.ClickToMove] = ClickToMove,
                [Enum.DevComputerMovementMode.ClickToMove] = ClickToMove,
            }
            
            -- Keyboard controller is really keyboard and mouse controller
            local computerInputTypeToModuleMap = {
                [Enum.UserInputType.Keyboard] = Keyboard,
                [Enum.UserInputType.MouseButton1] = Keyboard,
                [Enum.UserInputType.MouseButton2] = Keyboard,
                [Enum.UserInputType.MouseButton3] = Keyboard,
                [Enum.UserInputType.MouseWheel] = Keyboard,
                [Enum.UserInputType.MouseMovement] = Keyboard,
                [Enum.UserInputType.Gamepad1] = Gamepad,
                [Enum.UserInputType.Gamepad2] = Gamepad,
                [Enum.UserInputType.Gamepad3] = Gamepad,
                [Enum.UserInputType.Gamepad4] = Gamepad,
            }
            
            local lastInputType
            
            function ControlModule.new()
                local self = setmetatable({},ControlModule)
            
                -- The Modules above are used to construct controller instances as-needed, and this
                -- table is a map from Module to the instance created from it
                self.controllers = {}
            
                self.activeControlModule = nil	-- Used to prevent unnecessarily expensive checks on each input event
                self.activeController = nil
                self.touchJumpController = nil
                self.moveFunction = Players.LocalPlayer.Move
                self.humanoid = nil
                self.lastInputType = Enum.UserInputType.None
            
                -- For Roblox self.vehicleController
                self.humanoidSeatedConn = nil
                self.vehicleController = nil
            
                self.touchControlFrame = nil
            
                self.vehicleController = VehicleController.new(CONTROL_ACTION_PRIORITY)
            
                Players.LocalPlayer.CharacterAdded:Connect(function(char) self:OnCharacterAdded(char) end)
                Players.LocalPlayer.CharacterRemoving:Connect(function(char) self:OnCharacterRemoving(char) end)
                if Players.LocalPlayer.Character then
                    self:OnCharacterAdded(Players.LocalPlayer.Character)
                end
            
                RunService:BindToRenderStep("ControlScriptRenderstep", Enum.RenderPriority.Input.Value, function(dt)
                    self:OnRenderStepped(dt)
                end)
            
                UserInputService.LastInputTypeChanged:Connect(function(newLastInputType)
                    self:OnLastInputTypeChanged(newLastInputType)
                end)
            
            
                UserGameSettings:GetPropertyChangedSignal("TouchMovementMode"):Connect(function()
                    self:OnTouchMovementModeChange()
                end)
                Players.LocalPlayer:GetPropertyChangedSignal("DevTouchMovementMode"):Connect(function()
                    self:OnTouchMovementModeChange()
                end)
            
                UserGameSettings:GetPropertyChangedSignal("ComputerMovementMode"):Connect(function()
                    self:OnComputerMovementModeChange()
                end)
                Players.LocalPlayer:GetPropertyChangedSignal("DevComputerMovementMode"):Connect(function()
                    self:OnComputerMovementModeChange()
                end)
            
                --[[ Touch Device UI ]]--
                self.playerGui = nil
                self.touchGui = nil
                self.playerGuiAddedConn = nil
            
                if UserInputService.TouchEnabled then
                    self.playerGui = Players.LocalPlayer:FindFirstChildOfClass("PlayerGui")
                    if self.playerGui then
                        self:CreateTouchGuiContainer()
                        self:OnLastInputTypeChanged(UserInputService:GetLastInputType())
                    else
                        self.playerGuiAddedConn = Players.LocalPlayer.ChildAdded:Connect(function(child)
                            if child:IsA("PlayerGui") then
                                self.playerGui = child
                                self:CreateTouchGuiContainer()
                                self.playerGuiAddedConn:Disconnect()
                                self.playerGuiAddedConn = nil
                                self:OnLastInputTypeChanged(UserInputService:GetLastInputType())
                            end
                        end)
                    end
                else
                    self:OnLastInputTypeChanged(UserInputService:GetLastInputType())
                end
            
                return self
            end
            
            -- Convenience function so that calling code does not have to first get the activeController
            -- and then call GetMoveVector on it. When there is no active controller, this function returns
            -- nil so that this case can be distinguished from no current movement (which returns zero vector).
            function ControlModule:GetMoveVector()
                if self.activeController then
                    return self.activeController:GetMoveVector()
                end
                return Vector3.new(0,0,0)
            end
            
            function ControlModule:GetActiveController()
                return self.activeController
            end
            
            function ControlModule:EnableActiveControlModule()
                if self.activeControlModule == ClickToMove then
                    -- For ClickToMove, when it is the player's choice, we also enable the full keyboard controls.
                    -- When the developer is forcing click to move, the most keyboard controls (WASD) are not available, only jump.
                    self.activeController:Enable(
                        true,
                        Players.LocalPlayer.DevComputerMovementMode == Enum.DevComputerMovementMode.UserChoice,
                        self.touchJumpController
                    )
                elseif self.touchControlFrame then
                    self.activeController:Enable(true, self.touchControlFrame)
                else
                    self.activeController:Enable(true)
                end
            end
            
            function ControlModule:Enable(enable)
                if not self.activeController then
                    return
                end
            
                if enable == nil then
                    enable = true
                end
                if enable then
                    self:EnableActiveControlModule()
                else
                    self:Disable()
                end
            end
            
            -- For those who prefer distinct functions
            function ControlModule:Disable()
                if self.activeController then
                    self.activeController:Enable(false)
            
                    if self.moveFunction then
                        self.moveFunction(Players.LocalPlayer, Vector3.new(0,0,0), true)
                    end
                end
            end
            
            
            -- Returns module (possibly nil) and success code to differentiate returning nil due to error vs Scriptable
            function ControlModule:SelectComputerMovementModule()
                if not (UserInputService.KeyboardEnabled or UserInputService.GamepadEnabled) then
                    return nil, false
                end
            
                local computerModule
                local DevMovementMode = Players.LocalPlayer.DevComputerMovementMode
            
                if DevMovementMode == Enum.DevComputerMovementMode.UserChoice then
                    computerModule = computerInputTypeToModuleMap[lastInputType]
                    if UserGameSettings.ComputerMovementMode == Enum.ComputerMovementMode.ClickToMove and computerModule == Keyboard then
                        -- User has ClickToMove set in Settings, prefer ClickToMove controller for keyboard and mouse lastInputTypes
                        computerModule = ClickToMove
                    end
                else
                    -- Developer has selected a mode that must be used.
                    computerModule = movementEnumToModuleMap[DevMovementMode]
            
                    -- computerModule is expected to be nil here only when developer has selected Scriptable
                    if (not computerModule) and DevMovementMode ~= Enum.DevComputerMovementMode.Scriptable then
                        warn("No character control module is associated with DevComputerMovementMode ", DevMovementMode)
                    end
                end
            
                if computerModule then
                    return computerModule, true
                elseif DevMovementMode == Enum.DevComputerMovementMode.Scriptable then
                    -- Special case where nil is returned and we actually want to set self.activeController to nil for Scriptable
                    return nil, true
                else
                    -- This case is for when computerModule is nil because of an error and no suitable control module could
                    -- be found.
                    return nil, false
                end
            end
            
            -- Choose current Touch control module based on settings (user, dev)
            -- Returns module (possibly nil) and success code to differentiate returning nil due to error vs Scriptable
            function ControlModule:SelectTouchModule()
                if not UserInputService.TouchEnabled then
                    return nil, false
                end
                local touchModule
                local DevMovementMode = Players.LocalPlayer.DevTouchMovementMode
                if DevMovementMode == Enum.DevTouchMovementMode.UserChoice then
                    touchModule = movementEnumToModuleMap[UserGameSettings.TouchMovementMode]
                elseif DevMovementMode == Enum.DevTouchMovementMode.Scriptable then
                    return nil, true
                else
                    touchModule = movementEnumToModuleMap[DevMovementMode]
                end
                return touchModule, true
            end
            
            local function calculateRawMoveVector(humanoid, cameraRelativeMoveVector)
                local camera = Workspace.CurrentCamera
                if not camera then
                    return cameraRelativeMoveVector
                end
            
                if humanoid:GetState() == Enum.HumanoidStateType.Swimming then
                    return camera.CFrame:VectorToWorldSpace(cameraRelativeMoveVector)
                end
            
                local c, s
                local _, _, _, R00, R01, R02, _, _, R12, _, _, R22 = camera.CFrame:GetComponents()
                if R12 < 1 and R12 > -1 then
                    -- X and Z components from back vector.
                    c = R22
                    s = R02
                else
                    -- In this case the camera is looking straight up or straight down.
                    -- Use X components from right and up vectors.
                    c = R00
                    s = -R01*math.sign(R12)
                end
                local norm = math.sqrt(c*c + s*s)
                return Vector3.new(
                    (c*cameraRelativeMoveVector.x + s*cameraRelativeMoveVector.z)/norm,
                    0,
                    (c*cameraRelativeMoveVector.z - s*cameraRelativeMoveVector.x)/norm
                )
            end
            
            function ControlModule:OnRenderStepped(dt)
                if self.activeController and self.activeController.enabled and self.humanoid then
                    -- Give the controller a chance to adjust its state
                    self.activeController:OnRenderStepped(dt)
            
                    -- Now retrieve info from the controller
                    local moveVector = self.activeController:GetMoveVector()
                    local cameraRelative = self.activeController:IsMoveVectorCameraRelative()
            
                    local clickToMoveController = self:GetClickToMoveController()
                    if self.activeController ~= clickToMoveController then
                        if moveVector.magnitude > 0 then
                            -- Clean up any developer started MoveTo path
                            clickToMoveController:CleanupPath()
                        else
                            -- Get move vector for developer started MoveTo
                            clickToMoveController:OnRenderStepped(dt)
                            moveVector = clickToMoveController:GetMoveVector()
                            cameraRelative = clickToMoveController:IsMoveVectorCameraRelative()
                        end
                    end
            
                    -- Are we driving a vehicle ?
                    local vehicleConsumedInput = false
                    if self.vehicleController then
                        moveVector, vehicleConsumedInput = self.vehicleController:Update(moveVector, cameraRelative, self.activeControlModule==Gamepad)
                    end
            
                    -- If not, move the player
                    -- Verification of vehicleConsumedInput is commented out to preserve legacy behavior,
                    -- in case some game relies on Humanoid.MoveDirection still being set while in a VehicleSeat
                    --if not vehicleConsumedInput then
                        if cameraRelative then
                            moveVector = calculateRawMoveVector(self.humanoid, moveVector)
                        end
                        self.moveFunction(Players.LocalPlayer, moveVector, false)
                    --end
            
                    -- And make them jump if needed
                    self.humanoid.Jump = self.activeController:GetIsJumping() or (self.touchJumpController and self.touchJumpController:GetIsJumping())
                end
            end
            
            function ControlModule:OnHumanoidSeated(active, currentSeatPart)
                if active then
                    if currentSeatPart and currentSeatPart:IsA("VehicleSeat") then
                        if not self.vehicleController then
                            self.vehicleController = self.vehicleController.new(CONTROL_ACTION_PRIORITY)
                        end
                        self.vehicleController:Enable(true, currentSeatPart)
                    end
                else
                    if self.vehicleController then
                        self.vehicleController:Enable(false, currentSeatPart)
                    end
                end
            end
            
            function ControlModule:OnCharacterAdded(char)
                self.humanoid = char:FindFirstChildOfClass("Humanoid")
                while not self.humanoid do
                    char.ChildAdded:wait()
                    self.humanoid = char:FindFirstChildOfClass("Humanoid")
                end
            
                if self.touchGui then
                    self.touchGui.Enabled = true
                end
            
                if self.humanoidSeatedConn then
                    self.humanoidSeatedConn:Disconnect()
                    self.humanoidSeatedConn = nil
                end
                self.humanoidSeatedConn = self.humanoid.Seated:Connect(function(active, currentSeatPart)
                    self:OnHumanoidSeated(active, currentSeatPart)
                end)
            end
            
            function ControlModule:OnCharacterRemoving(char)
                self.humanoid = nil
            
                if self.touchGui then
                    self.touchGui.Enabled = false
                end
            end
            
            -- Helper function to lazily instantiate a controller if it does not yet exist,
            -- disable the active controller if it is different from the on being switched to,
            -- and then enable the requested controller. The argument to this function must be
            -- a reference to one of the control modules, i.e. Keyboard, Gamepad, etc.
            function ControlModule:SwitchToController(controlModule)
                if not controlModule then
                    if self.activeController then
                        self.activeController:Enable(false)
                    end
                    self.activeController = nil
                    self.activeControlModule = nil
                else
                    if not self.controllers[controlModule] then
                        self.controllers[controlModule] = controlModule.new(CONTROL_ACTION_PRIORITY)
                    end
            
                    if self.activeController ~= self.controllers[controlModule] then
                        if self.activeController then
                            self.activeController:Enable(false)
                        end
                        self.activeController = self.controllers[controlModule]
                        self.activeControlModule = controlModule -- Only used to check if controller switch is necessary
            
                        if self.touchControlFrame and (self.activeControlModule == ClickToMove
                                    or self.activeControlModule == TouchThumbstick
                                    or self.activeControlModule == DynamicThumbstick) then
                            if not self.controllers[TouchJump] then
                                self.controllers[TouchJump] = TouchJump.new()
                            end
                            self.touchJumpController = self.controllers[TouchJump]
                            self.touchJumpController:Enable(true, self.touchControlFrame)
                        else
                            if self.touchJumpController then
                                self.touchJumpController:Enable(false)
                            end
                        end
            
                        self:EnableActiveControlModule()
                    end
                end
            end
            
            function ControlModule:OnLastInputTypeChanged(newLastInputType)
                if lastInputType == newLastInputType then
                    warn("LastInputType Change listener called with current type.")
                end
                lastInputType = newLastInputType
            
                if lastInputType == Enum.UserInputType.Touch then
                    -- TODO: Check if touch module already active
                    local touchModule, success = self:SelectTouchModule()
                    if success then
                        while not self.touchControlFrame do
                            wait()
                        end
                        self:SwitchToController(touchModule)
                    end
                elseif computerInputTypeToModuleMap[lastInputType] ~= nil then
                    local computerModule = self:SelectComputerMovementModule()
                    if computerModule then
                        self:SwitchToController(computerModule)
                    end
                end
            end
            
            -- Called when any relevant values of GameSettings or LocalPlayer change, forcing re-evalulation of
            -- current control scheme
            function ControlModule:OnComputerMovementModeChange()
                local controlModule, success =  self:SelectComputerMovementModule()
                if success then
                    self:SwitchToController(controlModule)
                end
            end
            
            function ControlModule:OnTouchMovementModeChange()
                local touchModule, success = self:SelectTouchModule()
                if success then
                    while not self.touchControlFrame do
                        wait()
                    end
                    self:SwitchToController(touchModule)
                end
            end
            
            function ControlModule:CreateTouchGuiContainer()
                if self.touchGui then self.touchGui:Destroy() end
            
                -- Container for all touch device guis
                self.touchGui = Instance.new("ScreenGui")
                self.touchGui.Name = "TouchGui"
                self.touchGui.ResetOnSpawn = false
                self.touchGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
                self.touchGui.Enabled = self.humanoid ~= nil
            
                self.touchControlFrame = Instance.new("Frame")
                self.touchControlFrame.Name = "TouchControlFrame"
                self.touchControlFrame.Size = UDim2.new(1, 0, 1, 0)
                self.touchControlFrame.BackgroundTransparency = 1
                self.touchControlFrame.Parent = self.touchGui
            
                self.touchGui.Parent = self.playerGui
            end
            
            function ControlModule:GetClickToMoveController()
                if not self.controllers[ClickToMove] then
                    self.controllers[ClickToMove] = ClickToMove.new(CONTROL_ACTION_PRIORITY)
                end
                return self.controllers[ClickToMove]
            end
            
            function ControlModule:IsJumping()
                if self.activeController then
                    return self.activeController:GetIsJumping() or (self.touchJumpController and self.touchJumpController:GetIsJumping())
                end
                return false
            end
            
            return ControlModule.new()
        end
        
        function _PlayerModule()
            local PlayerModule = {}
            PlayerModule.__index = PlayerModule
            function PlayerModule.new()
                local self = setmetatable({},PlayerModule)
                self.cameras = _CameraModule()
                self.controls = _ControlModule()
                return self
            end
            function PlayerModule:GetCameras()
                return self.cameras
            end
            function PlayerModule:GetControls()
                return self.controls
            end
            function PlayerModule:GetClickToMoveController()
                return self.controls:GetClickToMoveController()
            end
            return PlayerModule.new()
        end
        
        function _sounds()
            
            local SetState = Instance.new("BindableEvent",script)
            
            local Players = game:GetService("Players")
            local RunService = game:GetService("RunService")
            
            local SOUND_DATA = {
                Climbing = {
                    SoundId = "rbxasset://sounds/action_footsteps_plastic.mp3",
                    Looped = true,
                },
                Died = {
                    SoundId = "rbxasset://sounds/uuhhh.mp3",
                },
                FreeFalling = {
                    SoundId = "rbxasset://sounds/action_falling.mp3",
                    Looped = true,
                },
                GettingUp = {
                    SoundId = "rbxasset://sounds/action_get_up.mp3",
                },
                Jumping = {
                    SoundId = "rbxasset://sounds/action_jump.mp3",
                },
                Landing = {
                    SoundId = "rbxasset://sounds/action_jump_land.mp3",
                },
                Running = {
                    SoundId = "rbxasset://sounds/action_footsteps_plastic.mp3",
                    Looped = true,
                    Pitch = 1.85,
                },
                Splash = {
                    SoundId = "rbxasset://sounds/impact_water.mp3",
                },
                Swimming = {
                    SoundId = "rbxasset://sounds/action_swim.mp3",
                    Looped = true,
                    Pitch = 1.6,
                },
            }
            
             -- wait for the first of the passed signals to fire
            local function waitForFirst(...)
                local shunt = Instance.new("BindableEvent")
                local slots = {...}
            
                local function fire(...)
                    for i = 1, #slots do
                        slots[i]:Disconnect()
                    end
            
                    return shunt:Fire(...)
                end
            
                for i = 1, #slots do
                    slots[i] = slots[i]:Connect(fire)
                end
            
                return shunt.Event:Wait()
            end
            
            -- map a value from one range to another
            local function map(x, inMin, inMax, outMin, outMax)
                return (x - inMin)*(outMax - outMin)/(inMax - inMin) + outMin
            end
            
            local function playSound(sound)
                sound.TimePosition = 0
                sound.Playing = true
            end
            
            local function stopSound(sound)
                sound.Playing = false
                sound.TimePosition = 0
            end
            
            local function shallowCopy(t)
                local out = {}
                for k, v in pairs(t) do
                    out[k] = v
                end
                return out
            end
            
            local function initializeSoundSystem(player, humanoid, rootPart)
                local sounds = {}
            
                -- initialize sounds
                for name, props in pairs(SOUND_DATA) do
                    local sound = Instance.new("Sound")
                    sound.Name = name
            
                    -- set default values
                    sound.Archivable = false
                    sound.EmitterSize = 5
                    sound.MaxDistance = 150
                    sound.Volume = 0.65
            
                    for propName, propValue in pairs(props) do
                        sound[propName] = propValue
                    end
            
                    sound.Parent = rootPart
                    sounds[name] = sound
                end
            
                local playingLoopedSounds = {}
            
                local function stopPlayingLoopedSounds(except)
                    for sound in pairs(shallowCopy(playingLoopedSounds)) do
                        if sound ~= except then
                            sound.Playing = false
                            playingLoopedSounds[sound] = nil
                        end
                    end
                end
            
                -- state transition callbacks
                local stateTransitions = {
                    [Enum.HumanoidStateType.FallingDown] = function()
                        stopPlayingLoopedSounds()
                    end,
            
                    [Enum.HumanoidStateType.GettingUp] = function()
                        stopPlayingLoopedSounds()
                        playSound(sounds.GettingUp)
                    end,
            
                    [Enum.HumanoidStateType.Jumping] = function()
                        stopPlayingLoopedSounds()
                        playSound(sounds.Jumping)
                    end,
            
                    [Enum.HumanoidStateType.Swimming] = function()
                        local verticalSpeed = math.abs(rootPart.Velocity.Y)
                        if verticalSpeed > 0.1 then
                            sounds.Splash.Volume = math.clamp(map(verticalSpeed, 100, 350, 0.28, 1), 0, 1)
                            playSound(sounds.Splash)
                        end
                        stopPlayingLoopedSounds(sounds.Swimming)
                        sounds.Swimming.Playing = true
                        playingLoopedSounds[sounds.Swimming] = true
                    end,
            
                    [Enum.HumanoidStateType.Freefall] = function()
                        sounds.FreeFalling.Volume = 0
                        stopPlayingLoopedSounds(sounds.FreeFalling)
                        playingLoopedSounds[sounds.FreeFalling] = true
                    end,
            
                    [Enum.HumanoidStateType.Landed] = function()
                        stopPlayingLoopedSounds()
                        local verticalSpeed = math.abs(rootPart.Velocity.Y)
                        if verticalSpeed > 75 then
                            sounds.Landing.Volume = math.clamp(map(verticalSpeed, 50, 100, 0, 1), 0, 1)
                            playSound(sounds.Landing)
                        end
                    end,
            
                    [Enum.HumanoidStateType.Running] = function()
                        stopPlayingLoopedSounds(sounds.Running)
                        sounds.Running.Playing = true
                        playingLoopedSounds[sounds.Running] = true
                    end,
            
                    [Enum.HumanoidStateType.Climbing] = function()
                        local sound = sounds.Climbing
                        if math.abs(rootPart.Velocity.Y) > 0.1 then
                            sound.Playing = true
                            stopPlayingLoopedSounds(sound)
                        else
                            stopPlayingLoopedSounds()
                        end
                        playingLoopedSounds[sound] = true
                    end,
            
                    [Enum.HumanoidStateType.Seated] = function()
                        stopPlayingLoopedSounds()
                    end,
            
                    [Enum.HumanoidStateType.Dead] = function()
                        stopPlayingLoopedSounds()
                        playSound(sounds.Died)
                    end,
                }
            
                -- updaters for looped sounds
                local loopedSoundUpdaters = {
                    [sounds.Climbing] = function(dt, sound, vel)
                        sound.Playing = vel.Magnitude > 0.1
                    end,
            
                    [sounds.FreeFalling] = function(dt, sound, vel)
                        if vel.Magnitude > 75 then
                            sound.Volume = math.clamp(sound.Volume + 0.9*dt, 0, 1)
                        else
                            sound.Volume = 0
                        end
                    end,
            
                    [sounds.Running] = function(dt, sound, vel)
                        sound.Playing = vel.Magnitude > 0.5 and humanoid.MoveDirection.Magnitude > 0.5
                    end,
                }
            
                -- state substitutions to avoid duplicating entries in the state table
                local stateRemap = {
                    [Enum.HumanoidStateType.RunningNoPhysics] = Enum.HumanoidStateType.Running,
                }
            
                local activeState = stateRemap[humanoid:GetState()] or humanoid:GetState()
                local activeConnections = {}
            
                local stateChangedConn = humanoid.StateChanged:Connect(function(_, state)
                    state = stateRemap[state] or state
            
                    if state ~= activeState then
                        local transitionFunc = stateTransitions[state]
            
                        if transitionFunc then
                            transitionFunc()
                        end
            
                        activeState = state
                    end
                end)
                
                local customStateChangedConn = SetState.Event:Connect(function(state)
                    state = stateRemap[state] or state
            
                    if state ~= activeState then
                        local transitionFunc = stateTransitions[state]
            
                        if transitionFunc then
                            transitionFunc()
                        end
            
                        activeState = state
                    end
                end)
            
                local steppedConn = RunService.Stepped:Connect(function(_, worldDt)
                    -- update looped sounds on stepped
                    for sound in pairs(playingLoopedSounds) do
                        local updater = loopedSoundUpdaters[sound]
            
                        if updater then
                            updater(worldDt, sound, rootPart.Velocity)
                        end
                    end
                end)
            
                local humanoidAncestryChangedConn
                local rootPartAncestryChangedConn
                local characterAddedConn
            
                local function terminate()
                    stateChangedConn:Disconnect()
                    customStateChangedConn:Disconnect()
                    steppedConn:Disconnect()
                    humanoidAncestryChangedConn:Disconnect()
                    rootPartAncestryChangedConn:Disconnect()
                    characterAddedConn:Disconnect()
                end
            
                humanoidAncestryChangedConn = humanoid.AncestryChanged:Connect(function(_, parent)
                    if not parent then
                        terminate()
                    end
                end)
            
                rootPartAncestryChangedConn = rootPart.AncestryChanged:Connect(function(_, parent)
                    if not parent then
                        terminate()
                    end
                end)
            
                characterAddedConn = player.CharacterAdded:Connect(terminate)
            end
            
            local function playerAdded(player)
                local function characterAdded(character)
                    -- Avoiding memory leaks in the face of Character/Humanoid/RootPart lifetime has a few complications:
                    -- * character deparenting is a Remove instead of a Destroy, so signals are not cleaned up automatically.
                    -- ** must use a waitForFirst on everything and listen for hierarchy changes.
                    -- * the character might not be in the dm by the time CharacterAdded fires
                    -- ** constantly check consistency with player.Character and abort if CharacterAdded is fired again
                    -- * Humanoid may not exist immediately, and by the time it's inserted the character might be deparented.
                    -- * RootPart probably won't exist immediately.
                    -- ** by the time RootPart is inserted and Humanoid.RootPart is set, the character or the humanoid might be deparented.
            
                    if not character.Parent then
                        waitForFirst(character.AncestryChanged, player.CharacterAdded)
                    end
            
                    if player.Character ~= character or not character.Parent then
                        return
                    end
            
                    local humanoid = character:FindFirstChildOfClass("Humanoid")
                    while character:IsDescendantOf(game) and not humanoid do
                        waitForFirst(character.ChildAdded, character.AncestryChanged, player.CharacterAdded)
                        humanoid = character:FindFirstChildOfClass("Humanoid")
                    end
            
                    if player.Character ~= character or not character:IsDescendantOf(game) then
                        return
                    end
            
                    -- must rely on HumanoidRootPart naming because Humanoid.RootPart does not fire changed signals
                    local rootPart = character:FindFirstChild("HumanoidRootPart")
                    while character:IsDescendantOf(game) and not rootPart do
                        waitForFirst(character.ChildAdded, character.AncestryChanged, humanoid.AncestryChanged, player.CharacterAdded)
                        rootPart = character:FindFirstChild("HumanoidRootPart")
                    end
            
                    if rootPart and humanoid:IsDescendantOf(game) and character:IsDescendantOf(game) and player.Character == character then
                        initializeSoundSystem(player, humanoid, rootPart)
                    end
                end
            
                if player.Character then
                    characterAdded(player.Character)
                end
                player.CharacterAdded:Connect(characterAdded)
            end
            
            Players.PlayerAdded:Connect(playerAdded)
            for _, player in ipairs(Players:GetPlayers()) do
                playerAdded(player)
            end
            return SetState
        end
        
        function _StateTracker()
            local EPSILON = 0.1
            
            local SPEED = {
                ["onRunning"] = true,
                ["onClimbing"] = true 
            }
            
            local INAIR = {
                ["onFreeFall"] = true,
                ["onJumping"] = true
            }
            
            local STATEMAP = {
                ["onRunning"] = Enum.HumanoidStateType.Running,
                ["onJumping"] = Enum.HumanoidStateType.Jumping,
                ["onFreeFall"] = Enum.HumanoidStateType.Freefall
            }
            
            local StateTracker = {}
            StateTracker.__index = StateTracker
            
            function StateTracker.new(humanoid, soundState)
                local self = setmetatable({}, StateTracker)
                
                self.Humanoid = humanoid
                self.HRP = humanoid.RootPart
                
                self.Speed = 0
                self.State = "onRunning"
                self.Jumped = false
                self.JumpTick = tick()
                
                self.SoundState = soundState
                
                self._ChangedEvent = Instance.new("BindableEvent")
                self.Changed = self._ChangedEvent.Event
                
                return self
            end
            
            function StateTracker:Destroy()
                self._ChangedEvent:Destroy()
            end
            
            function StateTracker:RequestedJump()
                self.Jumped = true
                self.JumpTick = tick()
            end
            
            function StateTracker:OnStep(gravityUp, grounded, isMoving)
                local cVelocity = self.HRP.Velocity
                local gVelocity = cVelocity:Dot(gravityUp)
                
                local oldState, oldSpeed = self.State, self.Speed
                
                local newState
                local newSpeed = cVelocity.Magnitude
            
                if (not grounded) then
                    if (gVelocity > 0) then
                        if (self.Jumped) then
                            newState = "onJumping"
                        else
                            newState = "onFreeFall"
                        end
                    else
                        if (self.Jumped) then
                            self.Jumped = false
                        end
                        newState = "onFreeFall"
                    end
                else
                    if (self.Jumped and tick() - self.JumpTick > 0.1) then
                        self.Jumped = false
                    end
                    newSpeed = (cVelocity - gVelocity*gravityUp).Magnitude
                    newState = "onRunning"
                end
                
                newSpeed = isMoving and newSpeed or 0
                
                if (oldState ~= newState or (SPEED[newState] and math.abs(oldSpeed - newSpeed) > EPSILON)) then
                    self.State = newState
                    self.Speed = newSpeed
                    self.SoundState:Fire(STATEMAP[newState])
                    self._ChangedEvent:Fire(self.State, self.Speed)
                end
            end
            
            return StateTracker
        end
        function _InitObjects()
            local model = workspace:FindFirstChild("objects") or game:GetObjects("rbxassetid://5045408489")[1]
            local SPHERE = model:WaitForChild("Sphere")
            local FLOOR = model:WaitForChild("Floor")
            local VFORCE = model:WaitForChild("VectorForce")
            local BGYRO = model:WaitForChild("BodyGyro")
            local function initObjects(self)
                local hrp = self.HRP
                local humanoid = self.Humanoid
                local sphere = SPHERE:Clone()
                sphere.Parent = self.Character
                local floor = FLOOR:Clone()
                floor.Parent = self.Character
                local isR15 = (humanoid.RigType == Enum.HumanoidRigType.R15)
                local height = isR15 and (humanoid.HipHeight + 0.05) or 2
                local weld = Instance.new("Weld")
                weld.C0 = CFrame.new(0, -height, 0.1)
                weld.Part0 = hrp
                weld.Part1 = sphere
                weld.Parent = sphere
                local weld2 = Instance.new("Weld")
                weld2.C0 = CFrame.new(0, -(height + 1.5), 0)
                weld2.Part0 = hrp
                weld2.Part1 = floor
                weld2.Parent = floor
                local gyro = BGYRO:Clone()
                gyro.CFrame = hrp.CFrame
                gyro.Parent = hrp
                local vForce = VFORCE:Clone()
                vForce.Attachment0 = isR15 and hrp:WaitForChild("RootRigAttachment") or hrp:WaitForChild("RootAttachment")
                vForce.Parent = hrp
                return sphere, gyro, vForce, floor
            end
            return initObjects
        end
        local plr = game.Players.LocalPlayer
        local ms = plr:GetMouse()
        local char
        plr.CharacterAdded:Connect(function(c)
            char = c
        end)
        function _R6()
            function r6()
            local Figure = char
            local Torso = Figure:WaitForChild("Torso")
            local RightShoulder = Torso:WaitForChild("Right Shoulder")
            local LeftShoulder = Torso:WaitForChild("Left Shoulder")
            local RightHip = Torso:WaitForChild("Right Hip")
            local LeftHip = Torso:WaitForChild("Left Hip")
            local Neck = Torso:WaitForChild("Neck")
            local Humanoid = Figure:WaitForChild("Humanoid")
            local pose = "Standing"
            local currentAnim = ""
            local currentAnimInstance = nil
            local currentAnimTrack = nil
            local currentAnimKeyframeHandler = nil
            local currentAnimSpeed = 1.0
            local animTable = {}
            local animNames = { 
                idle = 	{	
                            { id = "http://www.roblox.com/asset/?id=180435571", weight = 9 },
                            { id = "http://www.roblox.com/asset/?id=180435792", weight = 1 }
                        },
                walk = 	{ 	
                            { id = "http://www.roblox.com/asset/?id=180426354", weight = 10 } 
                        }, 
                run = 	{
                            { id = "run.xml", weight = 10 } 
                        }, 
                jump = 	{
                            { id = "http://www.roblox.com/asset/?id=125750702", weight = 10 } 
                        }, 
                fall = 	{
                            { id = "http://www.roblox.com/asset/?id=180436148", weight = 10 } 
                        }, 
                climb = {
                            { id = "http://www.roblox.com/asset/?id=180436334", weight = 10 } 
                        }, 
                sit = 	{
                            { id = "http://www.roblox.com/asset/?id=178130996", weight = 10 } 
                        },	
                toolnone = {
                            { id = "http://www.roblox.com/asset/?id=182393478", weight = 10 } 
                        },
                toolslash = {
                            { id = "http://www.roblox.com/asset/?id=129967390", weight = 10 } 
            --				{ id = "slash.xml", weight = 10 } 
                        },
                toollunge = {
                            { id = "http://www.roblox.com/asset/?id=129967478", weight = 10 } 
                        },
                wave = {
                            { id = "http://www.roblox.com/asset/?id=128777973", weight = 10 } 
                        },
                point = {
                            { id = "http://www.roblox.com/asset/?id=128853357", weight = 10 } 
                        },
                dance1 = {
                            { id = "http://www.roblox.com/asset/?id=182435998", weight = 10 }, 
                            { id = "http://www.roblox.com/asset/?id=182491037", weight = 10 }, 
                            { id = "http://www.roblox.com/asset/?id=182491065", weight = 10 } 
                        },
                dance2 = {
                            { id = "http://www.roblox.com/asset/?id=182436842", weight = 10 }, 
                            { id = "http://www.roblox.com/asset/?id=182491248", weight = 10 }, 
                            { id = "http://www.roblox.com/asset/?id=182491277", weight = 10 } 
                        },
                dance3 = {
                            { id = "http://www.roblox.com/asset/?id=182436935", weight = 10 }, 
                            { id = "http://www.roblox.com/asset/?id=182491368", weight = 10 }, 
                            { id = "http://www.roblox.com/asset/?id=182491423", weight = 10 } 
                        },
                laugh = {
                            { id = "http://www.roblox.com/asset/?id=129423131", weight = 10 } 
                        },
                cheer = {
                            { id = "http://www.roblox.com/asset/?id=129423030", weight = 10 } 
                        },
            }
            local dances = {"dance1", "dance2", "dance3"}
            -- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
            local emoteNames = { wave = false, point = false, dance1 = true, dance2 = true, dance3 = true, laugh = false, cheer = false}
            function configureAnimationSet(name, fileList)
                if (animTable[name] ~= nil) then
                    for _, connection in pairs(animTable[name].connections) do
                        connection:disconnect()
                    end
                end
                animTable[name] = {}
                animTable[name].count = 0
                animTable[name].totalWeight = 0	
                animTable[name].connections = {}
                -- check for config values
                local config = script:FindFirstChild(name)
                if (config ~= nil) then
            --		print("Loading anims " .. name)
                    table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
                    table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
                    local idx = 1
                    for _, childPart in pairs(config:GetChildren()) do
                        if (childPart:IsA("Animation")) then
                            table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
                            animTable[name][idx] = {}
                            animTable[name][idx].anim = childPart
                            local weightObject = childPart:FindFirstChild("Weight")
                            if (weightObject == nil) then
                                animTable[name][idx].weight = 1
                            else
                                animTable[name][idx].weight = weightObject.Value
                            end
                            animTable[name].count = animTable[name].count + 1
                            animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
                --			print(name .. " [" .. idx .. "] " .. animTable[name][idx].anim.AnimationId .. " (" .. animTable[name][idx].weight .. ")")
                            idx = idx + 1
                        end
                    end
                end
                -- fallback to defaults
                if (animTable[name].count <= 0) then
                    for idx, anim in pairs(fileList) do
                        animTable[name][idx] = {}
                        animTable[name][idx].anim = Instance.new("Animation")
                        animTable[name][idx].anim.Name = name
                        animTable[name][idx].anim.AnimationId = anim.id
                        animTable[name][idx].weight = anim.weight
                        animTable[name].count = animTable[name].count + 1
                        animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
            --			print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
                    end
                end
            end
            -- Setup animation objects
            function scriptChildModified(child)
                local fileList = animNames[child.Name]
                if (fileList ~= nil) then
                    configureAnimationSet(child.Name, fileList)
                end	
            end
            
            script.ChildAdded:connect(scriptChildModified)
            script.ChildRemoved:connect(scriptChildModified)
            
            
            for name, fileList in pairs(animNames) do 
                configureAnimationSet(name, fileList)
            end	
            
            -- ANIMATION
            
            -- declarations
            local toolAnim = "None"
            local toolAnimTime = 0
            
            local jumpAnimTime = 0
            local jumpAnimDuration = 0.3
            
            local toolTransitionTime = 0.1
            local fallTransitionTime = 0.3
            local jumpMaxLimbVelocity = 0.75
            
            -- functions
            
            function stopAllAnimations()
                local oldAnim = currentAnim
            
                -- return to idle if finishing an emote
                if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
                    oldAnim = "idle"
                end
            
                currentAnim = ""
                currentAnimInstance = nil
                if (currentAnimKeyframeHandler ~= nil) then
                    currentAnimKeyframeHandler:disconnect()
                end
            
                if (currentAnimTrack ~= nil) then
                    currentAnimTrack:Stop()
                    currentAnimTrack:Destroy()
                    currentAnimTrack = nil
                end
                return oldAnim
            end
            
            function setAnimationSpeed(speed)
                if speed ~= currentAnimSpeed then
                    currentAnimSpeed = speed
                    currentAnimTrack:AdjustSpeed(currentAnimSpeed)
                end
            end
            
            function keyFrameReachedFunc(frameName)
                if (frameName == "End") then
            
                    local repeatAnim = currentAnim
                    -- return to idle if finishing an emote
                    if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
                        repeatAnim = "idle"
                    end
                    
                    local animSpeed = currentAnimSpeed
                    playAnimation(repeatAnim, 0.0, Humanoid)
                    setAnimationSpeed(animSpeed)
                end
            end
            
            -- Preload animations
            function playAnimation(animName, transitionTime, humanoid) 
                    
                local roll = math.random(1, animTable[animName].totalWeight) 
                local origRoll = roll
                local idx = 1
                while (roll > animTable[animName][idx].weight) do
                    roll = roll - animTable[animName][idx].weight
                    idx = idx + 1
                end
            --		print(animName .. " " .. idx .. " [" .. origRoll .. "]")
                local anim = animTable[animName][idx].anim
            
                -- switch animation		
                if (anim ~= currentAnimInstance) then
                    
                    if (currentAnimTrack ~= nil) then
                        currentAnimTrack:Stop(transitionTime)
                        currentAnimTrack:Destroy()
                    end
            
                    currentAnimSpeed = 1.0
                
                    -- load it to the humanoid; get AnimationTrack
                    currentAnimTrack = humanoid:LoadAnimation(anim)
                    currentAnimTrack.Priority = Enum.AnimationPriority.Core
                     
                    -- play the animation
                    currentAnimTrack:Play(transitionTime)
                    currentAnim = animName
                    currentAnimInstance = anim
            
                    -- set up keyframe name triggers
                    if (currentAnimKeyframeHandler ~= nil) then
                        currentAnimKeyframeHandler:disconnect()
                    end
                    currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
                    
                end
            
            end
            
            -------------------------------------------------------------------------------------------
            -------------------------------------------------------------------------------------------
            
            local toolAnimName = ""
            local toolAnimTrack = nil
            local toolAnimInstance = nil
            local currentToolAnimKeyframeHandler = nil
            
            function toolKeyFrameReachedFunc(frameName)
                if (frameName == "End") then
            --		print("Keyframe : ".. frameName)	
                    playToolAnimation(toolAnimName, 0.0, Humanoid)
                end
            end
            
            
            function playToolAnimation(animName, transitionTime, humanoid, priority)	 
                    
                    local roll = math.random(1, animTable[animName].totalWeight) 
                    local origRoll = roll
                    local idx = 1
                    while (roll > animTable[animName][idx].weight) do
                        roll = roll - animTable[animName][idx].weight
                        idx = idx + 1
                    end
            --		print(animName .. " * " .. idx .. " [" .. origRoll .. "]")
                    local anim = animTable[animName][idx].anim
            
                    if (toolAnimInstance ~= anim) then
                        
                        if (toolAnimTrack ~= nil) then
                            toolAnimTrack:Stop()
                            toolAnimTrack:Destroy()
                            transitionTime = 0
                        end
                                
                        -- load it to the humanoid; get AnimationTrack
                        toolAnimTrack = humanoid:LoadAnimation(anim)
                        if priority then
                            toolAnimTrack.Priority = priority
                        end
                         
                        -- play the animation
                        toolAnimTrack:Play(transitionTime)
                        toolAnimName = animName
                        toolAnimInstance = anim
            
                        currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
                    end
            end
            
            function stopToolAnimations()
                local oldAnim = toolAnimName
            
                if (currentToolAnimKeyframeHandler ~= nil) then
                    currentToolAnimKeyframeHandler:disconnect()
                end
            
                toolAnimName = ""
                toolAnimInstance = nil
                if (toolAnimTrack ~= nil) then
                    toolAnimTrack:Stop()
                    toolAnimTrack:Destroy()
                    toolAnimTrack = nil
                end
            
            
                return oldAnim
            end
            
            -------------------------------------------------------------------------------------------
            -------------------------------------------------------------------------------------------
            
            
            function onRunning(speed)
                if speed > 0.01 then
                    playAnimation("walk", 0.1, Humanoid)
                    if currentAnimInstance and currentAnimInstance.AnimationId == "http://www.roblox.com/asset/?id=180426354" then
                        setAnimationSpeed(speed / 14.5)
                    end
                    pose = "Running"
                else
                    if emoteNames[currentAnim] == nil then
                        playAnimation("idle", 0.1, Humanoid)
                        pose = "Standing"
                    end
                end
            end
            
            function onDied()
                pose = "Dead"
            end
            
            function onJumping()
                playAnimation("jump", 0.1, Humanoid)
                jumpAnimTime = jumpAnimDuration
                pose = "Jumping"
            end
            
            function onClimbing(speed)
                playAnimation("climb", 0.1, Humanoid)
                setAnimationSpeed(speed / 12.0)
                pose = "Climbing"
            end
            
            function onGettingUp()
                pose = "GettingUp"
            end
            
            function onFreeFall()
                if (jumpAnimTime <= 0) then
                    playAnimation("fall", fallTransitionTime, Humanoid)
                end
                pose = "FreeFall"
            end
            
            function onFallingDown()
                pose = "FallingDown"
            end
            
            function onSeated()
                pose = "Seated"
            end
            
            function onPlatformStanding()
                pose = "PlatformStanding"
            end
            
            function onSwimming(speed)
                if speed > 0 then
                    pose = "Running"
                else
                    pose = "Standing"
                end
            end
            
            function getTool()	
                for _, kid in ipairs(Figure:GetChildren()) do
                    if kid.className == "Tool" then return kid end
                end
                return nil
            end
            
            function getToolAnim(tool)
                for _, c in ipairs(tool:GetChildren()) do
                    if c.Name == "toolanim" and c.className == "StringValue" then
                        return c
                    end
                end
                return nil
            end
            
            function animateTool()
                
                if (toolAnim == "None") then
                    playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
                    return
                end
            
                if (toolAnim == "Slash") then
                    playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
                    return
                end
            
                if (toolAnim == "Lunge") then
                    playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
                    return
                end
            end
            
            function moveSit()
                RightShoulder.MaxVelocity = 0.15
                LeftShoulder.MaxVelocity = 0.15
                RightShoulder:SetDesiredAngle(3.14 /2)
                LeftShoulder:SetDesiredAngle(-3.14 /2)
                RightHip:SetDesiredAngle(3.14 /2)
                LeftHip:SetDesiredAngle(-3.14 /2)
            end
            
            local lastTick = 0
            
            function move(time)
                local amplitude = 1
                local frequency = 1
                  local deltaTime = time - lastTick
                  lastTick = time
            
                local climbFudge = 0
                local setAngles = false
            
                  if (jumpAnimTime > 0) then
                      jumpAnimTime = jumpAnimTime - deltaTime
                  end
            
                if (pose == "FreeFall" and jumpAnimTime <= 0) then
                    playAnimation("fall", fallTransitionTime, Humanoid)
                elseif (pose == "Seated") then
                    playAnimation("sit", 0.5, Humanoid)
                    return
                elseif (pose == "Running") then
                    playAnimation("walk", 0.1, Humanoid)
                elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
            --		print("Wha " .. pose)
                    stopAllAnimations()
                    amplitude = 0.1
                    frequency = 1
                    setAngles = true
                end
            
                if (setAngles) then
                    local desiredAngle = amplitude * math.sin(time * frequency)
            
                    RightShoulder:SetDesiredAngle(desiredAngle + climbFudge)
                    LeftShoulder:SetDesiredAngle(desiredAngle - climbFudge)
                    RightHip:SetDesiredAngle(-desiredAngle)
                    LeftHip:SetDesiredAngle(-desiredAngle)
                end
            
                -- Tool Animation handling
                local tool = getTool()
                if tool and tool:FindFirstChild("Handle") then
                
                    local animStringValueObject = getToolAnim(tool)
            
                    if animStringValueObject then
                        toolAnim = animStringValueObject.Value
                        -- message recieved, delete StringValue
                        animStringValueObject.Parent = nil
                        toolAnimTime = time + .3
                    end
            
                    if time > toolAnimTime then
                        toolAnimTime = 0
                        toolAnim = "None"
                    end
            
                    animateTool()		
                else
                    stopToolAnimations()
                    toolAnim = "None"
                    toolAnimInstance = nil
                    toolAnimTime = 0
                end
            end
            
            
            local events = {}
            local eventHum = Humanoid
            
            local function onUnhook()
                for i = 1, #events do
                    events[i]:Disconnect()
                end
                events = {}
            end
            
            local function onHook()
                onUnhook()
                
                pose = eventHum.Sit and "Seated" or "Standing"
                
                events = {
                    eventHum.Died:connect(onDied),
                    eventHum.Running:connect(onRunning),
                    eventHum.Jumping:connect(onJumping),
                    eventHum.Climbing:connect(onClimbing),
                    eventHum.GettingUp:connect(onGettingUp),
                    eventHum.FreeFalling:connect(onFreeFall),
                    eventHum.FallingDown:connect(onFallingDown),
                    eventHum.Seated:connect(onSeated),
                    eventHum.PlatformStanding:connect(onPlatformStanding),
                    eventHum.Swimming:connect(onSwimming)
                }
            end
            
            
            onHook()
            
            -- setup emote chat hook
            game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
                local emote = ""
                if msg == "/e dance" then
                    emote = dances[math.random(1, #dances)]
                elseif (string.sub(msg, 1, 3) == "/e ") then
                    emote = string.sub(msg, 4)
                elseif (string.sub(msg, 1, 7) == "/emote ") then
                    emote = string.sub(msg, 8)
                end
                
                if (pose == "Standing" and emoteNames[emote] ~= nil) then
                    playAnimation(emote, 0.1, Humanoid)
                end
            
            end)
            
            
            -- main program
            
            -- initialize to idle
            playAnimation("idle", 0.1, Humanoid)
            pose = "Standing"
            
            spawn(function()
                while Figure.Parent ~= nil do
                    local _, time = wait(0.1)
                    move(time)
                end
            end)
            
            return {
                onRunning = onRunning, 
                onDied = onDied, 
                onJumping = onJumping, 
                onClimbing = onClimbing, 
                onGettingUp = onGettingUp, 
                onFreeFall = onFreeFall, 
                onFallingDown = onFallingDown, 
                onSeated = onSeated, 
                onPlatformStanding = onPlatformStanding,
                onHook = onHook,
                onUnhook = onUnhook
            }
            
            end
            return r6()
        end
        
        function _R15()
            local function r15()
                
            local Character = char
            local Humanoid = Character:WaitForChild("Humanoid")
            local pose = "Standing"
            
            local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
            local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue
            local userAnimationSpeedDampeningSuccess, userAnimationSpeedDampeningValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimationSpeedDampening") end)
            local userAnimationSpeedDampening = userAnimationSpeedDampeningSuccess and userAnimationSpeedDampeningValue
            
            local animateScriptEmoteHookFlagExists, animateScriptEmoteHookFlagEnabled = pcall(function()
                return UserSettings():IsUserFeatureEnabled("UserAnimateScriptEmoteHook")
            end)
            local FFlagAnimateScriptEmoteHook = animateScriptEmoteHookFlagExists and animateScriptEmoteHookFlagEnabled
            
            local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
            local HumanoidHipHeight = 2
            
            local EMOTE_TRANSITION_TIME = 0.1
            
            local currentAnim = ""
            local currentAnimInstance = nil
            local currentAnimTrack = nil
            local currentAnimKeyframeHandler = nil
            local currentAnimSpeed = 1.0
            
            local runAnimTrack = nil
            local runAnimKeyframeHandler = nil
            
            local animTable = {}
            local animNames = { 
                idle = 	{	
                            { id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
                            { id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
                            { id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
                        },
                walk = 	{ 	
                            { id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
                        }, 
                run = 	{
                            { id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
                        }, 
                swim = 	{
                            { id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
                        }, 
                swimidle = 	{
                            { id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
                        }, 
                jump = 	{
                            { id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
                        }, 
                fall = 	{
                            { id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
                        }, 
                climb = {
                            { id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
                        }, 
                sit = 	{
                            { id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
                        },	
                toolnone = {
                            { id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
                        },
                toolslash = {
                            { id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
                        },
                toollunge = {
                            { id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
                        },
                wave = {
                            { id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
                        },
                point = {
                            { id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
                        },
                dance = {
                            { id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
                            { id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
                            { id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
                        },
                dance2 = {
                            { id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
                            { id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
                            { id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
                        },
                dance3 = {
                            { id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
                            { id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
                            { id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
                        },
                laugh = {
                            { id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
                        },
                cheer = {
                            { id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
                        },
            }
            
            -- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
            local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}
            
            local PreloadAnimsUserFlag = false
            local PreloadedAnims = {}
            local successPreloadAnim, msgPreloadAnim = pcall(function()
                PreloadAnimsUserFlag = UserSettings():IsUserFeatureEnabled("UserPreloadAnimations")
            end)
            if not successPreloadAnim then
                PreloadAnimsUserFlag = false
            end
            
            math.randomseed(tick())
            
            function findExistingAnimationInSet(set, anim)
                if set == nil or anim == nil then
                    return 0
                end
                
                for idx = 1, set.count, 1 do 
                    if set[idx].anim.AnimationId == anim.AnimationId then
                        return idx
                    end
                end
                
                return 0
            end
            
            function configureAnimationSet(name, fileList)
                if (animTable[name] ~= nil) then
                    for _, connection in pairs(animTable[name].connections) do
                        connection:disconnect()
                    end
                end
                animTable[name] = {}
                animTable[name].count = 0
                animTable[name].totalWeight = 0	
                animTable[name].connections = {}
            
                local allowCustomAnimations = true
            
                local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
                if not success then
                    allowCustomAnimations = true
                end
            
                -- check for config values
                local config = script:FindFirstChild(name)
                if (allowCustomAnimations and config ~= nil) then
                    table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
                    table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
                    
                    local idx = 0
                    for _, childPart in pairs(config:GetChildren()) do
                        if (childPart:IsA("Animation")) then
                            local newWeight = 1
                            local weightObject = childPart:FindFirstChild("Weight")
                            if (weightObject ~= nil) then
                                newWeight = weightObject.Value
                            end
                            animTable[name].count = animTable[name].count + 1
                            idx = animTable[name].count
                            animTable[name][idx] = {}
                            animTable[name][idx].anim = childPart
                            animTable[name][idx].weight = newWeight
                            animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
                            table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
                            table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
                            table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
                        end
                    end
                end
                
                -- fallback to defaults
                if (animTable[name].count <= 0) then
                    for idx, anim in pairs(fileList) do
                        animTable[name][idx] = {}
                        animTable[name][idx].anim = Instance.new("Animation")
                        animTable[name][idx].anim.Name = name
                        animTable[name][idx].anim.AnimationId = anim.id
                        animTable[name][idx].weight = anim.weight
                        animTable[name].count = animTable[name].count + 1
                        animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
                    end
                end
                
                -- preload anims
                if PreloadAnimsUserFlag then
                    for i, animType in pairs(animTable) do
                        for idx = 1, animType.count, 1 do
                            if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
                                Humanoid:LoadAnimation(animType[idx].anim)
                                PreloadedAnims[animType[idx].anim.AnimationId] = true
                            end				
                        end
                    end
                end
            end
            
            ------------------------------------------------------------------------------------------------------------
            
            function configureAnimationSetOld(name, fileList)
                if (animTable[name] ~= nil) then
                    for _, connection in pairs(animTable[name].connections) do
                        connection:disconnect()
                    end
                end
                animTable[name] = {}
                animTable[name].count = 0
                animTable[name].totalWeight = 0	
                animTable[name].connections = {}
            
                local allowCustomAnimations = true
            
                local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
                if not success then
                    allowCustomAnimations = true
                end
            
                -- check for config values
                local config = script:FindFirstChild(name)
                if (allowCustomAnimations and config ~= nil) then
                    table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
                    table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
                    local idx = 1
                    for _, childPart in pairs(config:GetChildren()) do
                        if (childPart:IsA("Animation")) then
                            table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
                            animTable[name][idx] = {}
                            animTable[name][idx].anim = childPart
                            local weightObject = childPart:FindFirstChild("Weight")
                            if (weightObject == nil) then
                                animTable[name][idx].weight = 1
                            else
                                animTable[name][idx].weight = weightObject.Value
                            end
                            animTable[name].count = animTable[name].count + 1
                            animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
                            idx = idx + 1
                        end
                    end
                end
            
                -- fallback to defaults
                if (animTable[name].count <= 0) then
                    for idx, anim in pairs(fileList) do
                        animTable[name][idx] = {}
                        animTable[name][idx].anim = Instance.new("Animation")
                        animTable[name][idx].anim.Name = name
                        animTable[name][idx].anim.AnimationId = anim.id
                        animTable[name][idx].weight = anim.weight
                        animTable[name].count = animTable[name].count + 1
                        animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
                        -- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
                    end
                end
                
                -- preload anims
                if PreloadAnimsUserFlag then
                    for i, animType in pairs(animTable) do
                        for idx = 1, animType.count, 1 do 
                            Humanoid:LoadAnimation(animType[idx].anim)
                        end
                    end
                end
            end
            
            -- Setup animation objects
            function scriptChildModified(child)
                local fileList = animNames[child.Name]
                if (fileList ~= nil) then
                    configureAnimationSet(child.Name, fileList)
                end	
            end
            
            script.ChildAdded:connect(scriptChildModified)
            script.ChildRemoved:connect(scriptChildModified)
            
            
            for name, fileList in pairs(animNames) do 
                configureAnimationSet(name, fileList)
            end	
            
            -- ANIMATION
            
            -- declarations
            local toolAnim = "None"
            local toolAnimTime = 0
            
            local jumpAnimTime = 0
            local jumpAnimDuration = 0.31
            
            local toolTransitionTime = 0.1
            local fallTransitionTime = 0.2
            
            local currentlyPlayingEmote = false
            
            -- functions
            
            function stopAllAnimations()
                local oldAnim = currentAnim
            
                -- return to idle if finishing an emote
                if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
                    oldAnim = "idle"
                end
                
                if FFlagAnimateScriptEmoteHook and currentlyPlayingEmote then
                    oldAnim = "idle"
                    currentlyPlayingEmote = false
                end
            
                currentAnim = ""
                currentAnimInstance = nil
                if (currentAnimKeyframeHandler ~= nil) then
                    currentAnimKeyframeHandler:disconnect()
                end
            
                if (currentAnimTrack ~= nil) then
                    currentAnimTrack:Stop()
                    currentAnimTrack:Destroy()
                    currentAnimTrack = nil
                end
            
                -- clean up walk if there is one
                if (runAnimKeyframeHandler ~= nil) then
                    runAnimKeyframeHandler:disconnect()
                end
                
                if (runAnimTrack ~= nil) then
                    runAnimTrack:Stop()
                    runAnimTrack:Destroy()
                    runAnimTrack = nil
                end
                
                return oldAnim
            end
            
            function getHeightScale()
                if Humanoid then
                    if not Humanoid.AutomaticScalingEnabled then
                        return 1
                    end
                    
                    local scale = Humanoid.HipHeight / HumanoidHipHeight
                    if userAnimationSpeedDampening then
                        if AnimationSpeedDampeningObject == nil then
                            AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
                        end
                        if AnimationSpeedDampeningObject ~= nil then
                            scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
                        end
                    end
                    return scale
                end	
                return 1
            end
            
            local smallButNotZero = 0.0001
            function setRunSpeed(speed)
                local speedScaled = speed * 1.25
                local heightScale = getHeightScale()
                local runSpeed = speedScaled / heightScale
            
                if runSpeed ~= currentAnimSpeed then
                    if runSpeed < 0.33 then
                        currentAnimTrack:AdjustWeight(1.0)		
                        runAnimTrack:AdjustWeight(smallButNotZero)
                    elseif runSpeed < 0.66 then
                        local weight = ((runSpeed - 0.33) / 0.33)
                        currentAnimTrack:AdjustWeight(1.0 - weight + smallButNotZero)
                        runAnimTrack:AdjustWeight(weight + smallButNotZero)
                    else
                        currentAnimTrack:AdjustWeight(smallButNotZero)
                        runAnimTrack:AdjustWeight(1.0)
                    end
                    currentAnimSpeed = runSpeed
                    runAnimTrack:AdjustSpeed(runSpeed)
                    currentAnimTrack:AdjustSpeed(runSpeed)
                end	
            end
            
            function setAnimationSpeed(speed)
                if currentAnim == "walk" then
                        setRunSpeed(speed)
                else
                    if speed ~= currentAnimSpeed then
                        currentAnimSpeed = speed
                        currentAnimTrack:AdjustSpeed(currentAnimSpeed)
                    end
                end
            end
            
            function keyFrameReachedFunc(frameName)
                if (frameName == "End") then
                    if currentAnim == "walk" then
                        if userNoUpdateOnLoop == true then
                            if runAnimTrack.Looped ~= true then
                                runAnimTrack.TimePosition = 0.0
                            end
                            if currentAnimTrack.Looped ~= true then
                                currentAnimTrack.TimePosition = 0.0
                            end
                        else
                            runAnimTrack.TimePosition = 0.0
                            currentAnimTrack.TimePosition = 0.0
                        end
                    else
                        local repeatAnim = currentAnim
                        -- return to idle if finishing an emote
                        if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
                            repeatAnim = "idle"
                        end
                        
                        if FFlagAnimateScriptEmoteHook and currentlyPlayingEmote then
                            if currentAnimTrack.Looped then
                                -- Allow the emote to loop
                                return
                            end
                            
                            repeatAnim = "idle"
                            currentlyPlayingEmote = false
                        end
                        
                        local animSpeed = currentAnimSpeed
                        playAnimation(repeatAnim, 0.15, Humanoid)
                        setAnimationSpeed(animSpeed)
                    end
                end
            end
            
            function rollAnimation(animName)
                local roll = math.random(1, animTable[animName].totalWeight) 
                local origRoll = roll
                local idx = 1
                while (roll > animTable[animName][idx].weight) do
                    roll = roll - animTable[animName][idx].weight
                    idx = idx + 1
                end
                return idx
            end
            
            local function switchToAnim(anim, animName, transitionTime, humanoid)
                -- switch animation		
                if (anim ~= currentAnimInstance) then
                    
                    if (currentAnimTrack ~= nil) then
                        currentAnimTrack:Stop(transitionTime)
                        currentAnimTrack:Destroy()
                    end
            
                    if (runAnimTrack ~= nil) then
                        runAnimTrack:Stop(transitionTime)
                        runAnimTrack:Destroy()
                        if userNoUpdateOnLoop == true then
                            runAnimTrack = nil
                        end
                    end
            
                    currentAnimSpeed = 1.0
                
                    -- load it to the humanoid; get AnimationTrack
                    currentAnimTrack = humanoid:LoadAnimation(anim)
                    currentAnimTrack.Priority = Enum.AnimationPriority.Core
                     
                    -- play the animation
                    currentAnimTrack:Play(transitionTime)
                    currentAnim = animName
                    currentAnimInstance = anim
            
                    -- set up keyframe name triggers
                    if (currentAnimKeyframeHandler ~= nil) then
                        currentAnimKeyframeHandler:disconnect()
                    end
                    currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
                    
                    -- check to see if we need to blend a walk/run animation
                    if animName == "walk" then
                        local runAnimName = "run"
                        local runIdx = rollAnimation(runAnimName)
            
                        runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
                        runAnimTrack.Priority = Enum.AnimationPriority.Core
                        runAnimTrack:Play(transitionTime)		
                        
                        if (runAnimKeyframeHandler ~= nil) then
                            runAnimKeyframeHandler:disconnect()
                        end
                        runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
                    end
                end
            end
            
            function playAnimation(animName, transitionTime, humanoid) 	
                local idx = rollAnimation(animName)
                local anim = animTable[animName][idx].anim
            
                switchToAnim(anim, animName, transitionTime, humanoid)
                currentlyPlayingEmote = false
            end
            
            function playEmote(emoteAnim, transitionTime, humanoid)
                switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
                currentlyPlayingEmote = true
            end
            
            -------------------------------------------------------------------------------------------
            -------------------------------------------------------------------------------------------
            
            local toolAnimName = ""
            local toolAnimTrack = nil
            local toolAnimInstance = nil
            local currentToolAnimKeyframeHandler = nil
            
            function toolKeyFrameReachedFunc(frameName)
                if (frameName == "End") then
                    playToolAnimation(toolAnimName, 0.0, Humanoid)
                end
            end
            
            
            function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
                    local idx = rollAnimation(animName)
                    local anim = animTable[animName][idx].anim
            
                    if (toolAnimInstance ~= anim) then
                        
                        if (toolAnimTrack ~= nil) then
                            toolAnimTrack:Stop()
                            toolAnimTrack:Destroy()
                            transitionTime = 0
                        end
                                
                        -- load it to the humanoid; get AnimationTrack
                        toolAnimTrack = humanoid:LoadAnimation(anim)
                        if priority then
                            toolAnimTrack.Priority = priority
                        end
                         
                        -- play the animation
                        toolAnimTrack:Play(transitionTime)
                        toolAnimName = animName
                        toolAnimInstance = anim
            
                        currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
                    end
            end
            
            function stopToolAnimations()
                local oldAnim = toolAnimName
            
                if (currentToolAnimKeyframeHandler ~= nil) then
                    currentToolAnimKeyframeHandler:disconnect()
                end
            
                toolAnimName = ""
                toolAnimInstance = nil
                if (toolAnimTrack ~= nil) then
                    toolAnimTrack:Stop()
                    toolAnimTrack:Destroy()
                    toolAnimTrack = nil
                end
            
                return oldAnim
            end
            
            -------------------------------------------------------------------------------------------
            -------------------------------------------------------------------------------------------
            -- STATE CHANGE HANDLERS
            
            function onRunning(speed)
                if speed > 0.75 then
                    local scale = 16.0
                    playAnimation("walk", 0.2, Humanoid)
                    setAnimationSpeed(speed / scale)
                    pose = "Running"
                else
                    if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
                        playAnimation("idle", 0.2, Humanoid)
                        pose = "Standing"
                    end
                end
            end
            
            function onDied()
                pose = "Dead"
            end
            
            function onJumping()
                playAnimation("jump", 0.1, Humanoid)
                jumpAnimTime = jumpAnimDuration
                pose = "Jumping"
            end
            
            function onClimbing(speed)
                local scale = 5.0
                playAnimation("climb", 0.1, Humanoid)
                setAnimationSpeed(speed / scale)
                pose = "Climbing"
            end
            
            function onGettingUp()
                pose = "GettingUp"
            end
            
            function onFreeFall()
                if (jumpAnimTime <= 0) then
                    playAnimation("fall", fallTransitionTime, Humanoid)
                end
                pose = "FreeFall"
            end
            
            function onFallingDown()
                pose = "FallingDown"
            end
            
            function onSeated()
                pose = "Seated"
            end
            
            function onPlatformStanding()
                pose = "PlatformStanding"
            end
            
            -------------------------------------------------------------------------------------------
            -------------------------------------------------------------------------------------------
            
            function onSwimming(speed)
                if speed > 1.00 then
                    local scale = 10.0
                    playAnimation("swim", 0.4, Humanoid)
                    setAnimationSpeed(speed / scale)
                    pose = "Swimming"
                else
                    playAnimation("swimidle", 0.4, Humanoid)
                    pose = "Standing"
                end
            end
            
            function animateTool()
                if (toolAnim == "None") then
                    playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
                    return
                end
            
                if (toolAnim == "Slash") then
                    playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
                    return
                end
            
                if (toolAnim == "Lunge") then
                    playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
                    return
                end
            end
            
            function getToolAnim(tool)
                for _, c in ipairs(tool:GetChildren()) do
                    if c.Name == "toolanim" and c.className == "StringValue" then
                        return c
                    end
                end
                return nil
            end
            
            local lastTick = 0
            
            function stepAnimate(currentTime)
                local amplitude = 1
                local frequency = 1
                  local deltaTime = currentTime - lastTick
                  lastTick = currentTime
            
                local climbFudge = 0
                local setAngles = false
            
                  if (jumpAnimTime > 0) then
                      jumpAnimTime = jumpAnimTime - deltaTime
                  end
            
                if (pose == "FreeFall" and jumpAnimTime <= 0) then
                    playAnimation("fall", fallTransitionTime, Humanoid)
                elseif (pose == "Seated") then
                    playAnimation("sit", 0.5, Humanoid)
                    return
                elseif (pose == "Running") then
                    playAnimation("walk", 0.2, Humanoid)
                elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
                    stopAllAnimations()
                    amplitude = 0.1
                    frequency = 1
                    setAngles = true
                end
            
                -- Tool Animation handling
                local tool = Character:FindFirstChildOfClass("Tool")
                if tool and tool:FindFirstChild("Handle") then
                    local animStringValueObject = getToolAnim(tool)
            
                    if animStringValueObject then
                        toolAnim = animStringValueObject.Value
                        -- message recieved, delete StringValue
                        animStringValueObject.Parent = nil
                        toolAnimTime = currentTime + .3
                    end
            
                    if currentTime > toolAnimTime then
                        toolAnimTime = 0
                        toolAnim = "None"
                    end
            
                    animateTool()		
                else
                    stopToolAnimations()
                    toolAnim = "None"
                    toolAnimInstance = nil
                    toolAnimTime = 0
                end
            end
            
            -- connect events
            
            local events = {}
            local eventHum = Humanoid
            
            local function onUnhook()
                for i = 1, #events do
                    events[i]:Disconnect()
                end
                events = {}
            end
            
            local function onHook()
                onUnhook()
                
                pose = eventHum.Sit and "Seated" or "Standing"
                
                events = {
                    eventHum.Died:connect(onDied),
                    eventHum.Running:connect(onRunning),
                    eventHum.Jumping:connect(onJumping),
                    eventHum.Climbing:connect(onClimbing),
                    eventHum.GettingUp:connect(onGettingUp),
                    eventHum.FreeFalling:connect(onFreeFall),
                    eventHum.FallingDown:connect(onFallingDown),
                    eventHum.Seated:connect(onSeated),
                    eventHum.PlatformStanding:connect(onPlatformStanding),
                    eventHum.Swimming:connect(onSwimming)
                }
            end
            
            
            onHook()
            
            -- setup emote chat hook
            game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
                local emote = ""
                if (string.sub(msg, 1, 3) == "/e ") then
                    emote = string.sub(msg, 4)
                elseif (string.sub(msg, 1, 7) == "/emote ") then
                    emote = string.sub(msg, 8)
                end
                
                if (pose == "Standing" and emoteNames[emote] ~= nil) then
                    playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
                end
            end)
            
            --[[ emote bindable hook
            if FFlagAnimateScriptEmoteHook then
                script:WaitForChild("PlayEmote").OnInvoke = function(emote)
                    -- Only play emotes when idling
                    if pose ~= "Standing" then
                        return
                    end
                    if emoteNames[emote] ~= nil then
                        -- Default emotes
                        playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
                        return true
                    elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
                        -- Non-default emotes
                        playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)
                        return true
                    end
                    -- Return false to indicate that the emote could not be played
                    return false
                end
            end
            ]]
            -- initialize to idle
            playAnimation("idle", 0.1, Humanoid)
            pose = "Standing"
            -- loop to handle timed state transitions and tool animations
            spawn(function()
                while Character.Parent ~= nil do
                    local _, currentGameTime = wait(0.1)
                    stepAnimate(currentGameTime)
                end
            end)
            return {
                onRunning = onRunning, 
                onDied = onDied, 
                onJumping = onJumping, 
                onClimbing = onClimbing, 
                onGettingUp = onGettingUp, 
                onFreeFall = onFreeFall, 
                onFallingDown = onFallingDown, 
                onSeated = onSeated, 
                onPlatformStanding = onPlatformStanding,
                onHook = onHook,
                onUnhook = onUnhook
            }
            end
            return r15()
        end
        while true do
            wait(.1)
            if plr.Character ~= nil then
                char = plr.Character
                break
            end
        end
        function _Controller()
            local humanoid = char:WaitForChild("Humanoid")
            local animFuncs = {}
            if (humanoid.RigType == Enum.HumanoidRigType.R6) then
                animFuncs = _R6()
            else
                animFuncs = _R15()
            end
            print("Animation succes")
            return animFuncs
        end
        function _AnimationHandler()
        local AnimationHandler = {}
        AnimationHandler.__index = AnimationHandler
        
        function AnimationHandler.new(humanoid, animate)
            local self = setmetatable({}, AnimationHandler)
            
            self._AnimFuncs = _Controller()
            self.Humanoid = humanoid
            
            return self
        end
        
        function AnimationHandler:EnableDefault(bool)
            if (bool) then
                self._AnimFuncs.onHook()
            else
                self._AnimFuncs.onUnhook()
            end
        end
        
        function AnimationHandler:Run(name, ...)
            self._AnimFuncs[name](...)
        end
        
        return AnimationHandler
        end
        
        function _GravityController()
        
        local ZERO = Vector3.new(0, 0, 0)
        local UNIT_X = Vector3.new(1, 0, 0)
        local UNIT_Y = Vector3.new(0, 1, 0)
        local UNIT_Z = Vector3.new(0, 0, 1)
        local VEC_XY = Vector3.new(1, 0, 1)
        
        local IDENTITYCF = CFrame.new()
        
        local JUMPMODIFIER = 1.2
        local TRANSITION = 0.15
        local WALKF = 200 / 3
        
        local UIS = game:GetService("UserInputService")
        local RUNSERVICE = game:GetService("RunService")
        
        local InitObjects = _InitObjects()
        local AnimationHandler = _AnimationHandler()
        local StateTracker = _StateTracker()
        
        -- Class
        
        local GravityController = {}
        GravityController.__index = GravityController
        
        -- Private Functions
        
        local function getRotationBetween(u, v, axis)
            local dot, uxv = u:Dot(v), u:Cross(v)
            if (dot < -0.99999) then return CFrame.fromAxisAngle(axis, math.pi) end
            return CFrame.new(0, 0, 0, uxv.x, uxv.y, uxv.z, 1 + dot)
        end
        
        local function lookAt(pos, forward, up)
            local r = forward:Cross(up)
            local u = r:Cross(forward)
            return CFrame.fromMatrix(pos, r.Unit, u.Unit)
        end
        
        local function getMass(array)
            local mass = 0
            for _, part in next, array do
                if (part:IsA("BasePart")) then
                    mass = mass + part:GetMass()
                end
            end
            return mass
        end
        
        -- Public Constructor
        local ExecutedPlayerModule = _PlayerModule()
        local ExecutedSounds = _sounds()
        function GravityController.new(player)
            local self = setmetatable({}, GravityController)
        
            --[[ Camera
            local loaded = player.PlayerScripts:WaitForChild("PlayerScriptsLoader"):WaitForChild("Loaded")
            if (not loaded.Value) then
                --loaded.Changed:Wait()
            end
            ]]
            local playerModule = ExecutedPlayerModule
            self.Controls = playerModule:GetControls()
            self.Camera = playerModule:GetCameras()
            
            -- Player and character
            self.Player = player
            self.Character = player.Character
            self.Humanoid = player.Character:WaitForChild("Humanoid")
            self.HRP = player.Character:WaitForChild("HumanoidRootPart")
            
            -- Animation
            self.AnimationHandler = AnimationHandler.new(self.Humanoid, self.Character:WaitForChild("Animate"))
            self.AnimationHandler:EnableDefault(false)
            local ssss = game:GetService("Players").LocalPlayer.PlayerScripts:FindFirstChild("SetState") or Instance.new("BindableEvent",game:GetService("Players").LocalPlayer.PlayerScripts)
            local soundState = ExecutedSounds
            ssss.Name = "SetState"
            
            self.StateTracker = StateTracker.new(self.Humanoid, soundState)
            self.StateTracker.Changed:Connect(function(name, speed)
                self.AnimationHandler:Run(name, speed)
            end)
            
            -- Collider and forces
            local collider, gyro, vForce, floor = InitObjects(self)
            
            floor.Touched:Connect(function() end)
            collider.Touched:Connect(function() end)
            
            self.Collider = collider
            self.VForce = vForce
            self.Gyro = gyro
            self.Floor = floor
            
            -- Attachment to parts
            self.LastPart = workspace.Terrain
            self.LastPartCFrame = IDENTITYCF
            
            -- Gravity properties
            self.GravityUp = UNIT_Y
            self.Ignores = {self.Character}
            
            function self.Camera.GetUpVector(this, oldUpVector)
                return self.GravityUp
            end
            
            -- Events etc
            self.Humanoid.PlatformStand = true
            
            self.CharacterMass = getMass(self.Character:GetDescendants())
            self.Character.AncestryChanged:Connect(function() self.CharacterMass = getMass(self.Character:GetDescendants()) end)
            
            self.JumpCon = RUNSERVICE.RenderStepped:Connect(function(dt) 
                if (self.Controls:IsJumping()) then
                    self:OnJumpRequest()
                end
            end)
            
            self.DeathCon = self.Humanoid.Died:Connect(function() self:Destroy() end)
            self.SeatCon = self.Humanoid.Seated:Connect(function(active) if (active) then self:Destroy() end end)
            self.HeartCon = RUNSERVICE.Heartbeat:Connect(function(dt) self:OnHeartbeatStep(dt) end)
            RUNSERVICE:BindToRenderStep("GravityStep", Enum.RenderPriority.Input.Value + 1, function(dt) self:OnGravityStep(dt) end)
            
            
            return self
        end
        
        -- Public Methods
        
        function GravityController:Destroy()
            self.JumpCon:Disconnect()
            self.DeathCon:Disconnect()
            self.SeatCon:Disconnect()
            self.HeartCon:Disconnect()
            
            RUNSERVICE:UnbindFromRenderStep("GravityStep")
            
            self.Collider:Destroy()
            self.VForce:Destroy()
            self.Gyro:Destroy()
            self.StateTracker:Destroy()
            
            self.Humanoid.PlatformStand = false
            self.AnimationHandler:EnableDefault(true)
            
            self.GravityUp = UNIT_Y
        end
        
        function GravityController:GetGravityUp(oldGravity)
            return oldGravity
        end
        
        function GravityController:IsGrounded(isJumpCheck)
            if (not isJumpCheck) then
                local parts = self.Floor:GetTouchingParts()
                for _, part in next, parts do
                    if (not part:IsDescendantOf(self.Character)) then
                        return true
                    end
                end
            else
                if (self.StateTracker.Jumped) then
                    return false
                end
            
                -- 1. check we are touching something with the collider
                local valid = {}
                local parts = self.Collider:GetTouchingParts()
                for _, part in next, parts do
                    if (not part:IsDescendantOf(self.Character)) then
                        table.insert(valid, part)
                    end
                end
                
                if (#valid > 0) then
                    -- 2. do a decently long downwards raycast
                    local max = math.cos(self.Humanoid.MaxSlopeAngle)
                    local ray = Ray.new(self.Collider.Position, -10 * self.GravityUp)
                    local hit, pos, normal = workspace:FindPartOnRayWithWhitelist(ray, valid, true)
                    
                    -- 3. use slope to decide on jump
                    if (hit and max <= self.GravityUp:Dot(normal)) then
                        return true
                    end
                end
            end
            return false
        end
        
        function GravityController:OnJumpRequest()
            if (not self.StateTracker.Jumped and self:IsGrounded(true)) then
                local hrpVel = self.HRP.Velocity
                self.HRP.Velocity = hrpVel + self.GravityUp*self.Humanoid.JumpPower*JUMPMODIFIER
                self.StateTracker:RequestedJump()
            end
        end
        
        function GravityController:GetMoveVector()
            return self.Controls:GetMoveVector()
        end
        
        function GravityController:OnHeartbeatStep(dt)
            local ray = Ray.new(self.Collider.Position, -1.1*self.GravityUp)
            local hit, pos, normal = workspace:FindPartOnRayWithIgnoreList(ray, self.Ignores)
            local lastPart = self.LastPart
            
            if (hit and lastPart and lastPart == hit) then
                local offset = self.LastPartCFrame:ToObjectSpace(self.HRP.CFrame)
                self.HRP.CFrame = hit.CFrame:ToWorldSpace(offset)
            end
            
            self.LastPart = hit
            self.LastPartCFrame = hit and hit.CFrame
        end
        
        function GravityController:OnGravityStep(dt)
            -- update gravity up vector
            local oldGravity = self.GravityUp
            local newGravity = self:GetGravityUp(oldGravity)
            
            local rotation = getRotationBetween(oldGravity, newGravity, workspace.CurrentCamera.CFrame.RightVector)
            rotation = IDENTITYCF:Lerp(rotation, TRANSITION)
            
            self.GravityUp = rotation * oldGravity
            
            -- get world move vector
            local camCF = workspace.CurrentCamera.CFrame
            local fDot = camCF.LookVector:Dot(newGravity)
            local cForward = math.abs(fDot) > 0.5 and -math.sign(fDot)*camCF.UpVector or camCF.LookVector
            
            local left = cForward:Cross(-newGravity).Unit
            local forward = -left:Cross(newGravity).Unit
            
            local move = self:GetMoveVector()
            local worldMove = forward*move.z - left*move.x
            worldMove = worldMove:Dot(worldMove) > 1 and worldMove.Unit or worldMove
            
            local isInputMoving = worldMove:Dot(worldMove) > 0
            
            -- get the desired character cframe
            local hrpCFLook = self.HRP.CFrame.LookVector
            local charF = hrpCFLook:Dot(forward)*forward + hrpCFLook:Dot(left)*left
            local charR = charF:Cross(newGravity).Unit
            local newCharCF = CFrame.fromMatrix(ZERO, charR, newGravity, -charF)
            
            local newCharRotation = IDENTITYCF
            if (isInputMoving) then
                newCharRotation = IDENTITYCF:Lerp(getRotationBetween(charF, worldMove, newGravity), 0.7)	
            end
            
            -- calculate forces
            local g = workspace.Gravity
            local gForce = g * self.CharacterMass * (UNIT_Y - newGravity)
            
            local cVelocity = self.HRP.Velocity
            local tVelocity = self.Humanoid.WalkSpeed * worldMove
            local gVelocity = cVelocity:Dot(newGravity)*newGravity
            local hVelocity = cVelocity - gVelocity
            
            if (hVelocity:Dot(hVelocity) < 1) then
                hVelocity = ZERO
            end
            
            local dVelocity = tVelocity - hVelocity
            local walkForceM = math.min(10000, WALKF * self.CharacterMass * dVelocity.Magnitude / (dt*60))
            local walkForce = walkForceM > 0 and dVelocity.Unit*walkForceM or ZERO
            
            -- mouse lock
            local charRotation = newCharRotation * newCharCF
            
            if (self.Camera:IsCamRelative()) then
                local lv = workspace.CurrentCamera.CFrame.LookVector
                local hlv = lv - charRotation.UpVector:Dot(lv)*charRotation.UpVector
                charRotation = lookAt(ZERO, hlv, charRotation.UpVector)
            end
            
            -- get state
            self.StateTracker:OnStep(self.GravityUp, self:IsGrounded(), isInputMoving)
        
            -- update values
            self.VForce.Force = walkForce + gForce
            self.Gyro.CFrame = charRotation
        end
        return GravityController
        end
        function _Draw3D()
            local module = {}
            
            -- Style Guide
            
            module.StyleGuide = {
                Point = {
                    Thickness = 0.5;
                    Color = Color3.new(0, 1, 0);
                },
                
                Line = {
                    Thickness = 0.1;
                    Color = Color3.new(1, 1, 0);
                },
                
                Ray = {
                    Thickness = 0.1;
                    Color = Color3.new(1, 0, 1);
                },
                
                Triangle = {
                    Thickness = 0.05;
                };
                
                CFrame = {
                    Thickness = 0.1;
                    RightColor3 = Color3.new(1, 0, 0);
                    UpColor3 = Color3.new(0, 1, 0);
                    BackColor3 = Color3.new(0, 0, 1);
                    PartProperties = {
                        Material = Enum.Material.SmoothPlastic;
                    };
                }
            }
            
            -- CONSTANTS
            
            local WEDGE = Instance.new("WedgePart")
            WEDGE.Material = Enum.Material.SmoothPlastic
            WEDGE.Anchored = true
            WEDGE.CanCollide = false
            
            local PART = Instance.new("Part")
            PART.Size = Vector3.new(0.1, 0.1, 0.1)
            PART.Anchored = true
            PART.CanCollide = false
            PART.TopSurface = Enum.SurfaceType.Smooth
            PART.BottomSurface = Enum.SurfaceType.Smooth
            PART.Material = Enum.Material.SmoothPlastic
            
            -- Functions
            
            local function draw(properties, style)
                local part = PART:Clone()
                for k, v in next, properties do
                    part[k] = v
                end
                if (style) then
                    for k, v in next, style do
                        if (k ~= "Thickness") then
                            part[k] = v
                        end
                    end
                end
                return part
            end
            
            function module.Draw(parent, properties)
                properties.Parent = parent
                return draw(properties, nil)
            end
            
            function module.Point(parent, cf_v3)
                local thickness = module.StyleGuide.Point.Thickness
                return draw({
                    Size = Vector3.new(thickness, thickness, thickness);
                    CFrame = (typeof(cf_v3) == "CFrame" and cf_v3 or CFrame.new(cf_v3));
                    Parent = parent;
                }, module.StyleGuide.Point)
            end
            
            function module.Line(parent, a, b)
                local thickness = module.StyleGuide.Line.Thickness
                return draw({
                    CFrame = CFrame.new((a + b)/2, b);
                    Size = Vector3.new(thickness, thickness, (b - a).Magnitude);
                    Parent = parent;
                }, module.StyleGuide.Line)
            end
            
            function module.Ray(parent, origin, direction)
                local thickness = module.StyleGuide.Ray.Thickness
                return draw({
                    CFrame = CFrame.new(origin + direction/2, origin + direction);
                    Size = Vector3.new(thickness, thickness, direction.Magnitude);
                    Parent = parent;
                }, module.StyleGuide.Ray)
            end
            
            function module.Triangle(parent, a, b, c)
                local ab, ac, bc = b - a, c - a, c - b
                local abd, acd, bcd = ab:Dot(ab), ac:Dot(ac), bc:Dot(bc)
                
                if (abd > acd and abd > bcd) then
                    c, a = a, c
                elseif (acd > bcd and acd > abd) then
                    a, b = b, a
                end
                
                ab, ac, bc = b - a, c - a, c - b
                
                local right = ac:Cross(ab).Unit
                local up = bc:Cross(right).Unit
                local back = bc.Unit
                
                local height = math.abs(ab:Dot(up))
                local width1 = math.abs(ab:Dot(back))
                local width2 = math.abs(ac:Dot(back))
                
                local thickness = module.StyleGuide.Triangle.Thickness
                
                local w1 = WEDGE:Clone()
                w1.Size = Vector3.new(thickness, height, width1)
                w1.CFrame = CFrame.fromMatrix((a + b)/2, right, up, back)
                w1.Parent = parent
                
                local w2 = WEDGE:Clone()
                w2.Size = Vector3.new(thickness, height, width2)
                w2.CFrame = CFrame.fromMatrix((a + c)/2, -right, up, -back)
                w2.Parent = parent
                
                for k, v in next, module.StyleGuide.Triangle do
                    if (k ~= "Thickness") then
                        w1[k] = v
                        w2[k] = v
                    end
                end
                
                return w1, w2
            end
            
            function module.CFrame(parent, cf)
                local origin = cf.Position
                local r = cf.RightVector
                local u = cf.UpVector
                local b = -cf.LookVector
                
                local thickness = module.StyleGuide.CFrame.Thickness
                
                local right = draw({
                    CFrame = CFrame.new(origin + r/2, origin + r);
                    Size = Vector3.new(thickness, thickness, r.Magnitude);
                    Color = module.StyleGuide.CFrame.RightColor3;
                    Parent = parent;
                }, module.StyleGuide.CFrame.PartProperties)
                
                local up = draw({
                    CFrame = CFrame.new(origin + u/2, origin + u);
                    Size = Vector3.new(thickness, thickness, r.Magnitude);
                    Color = module.StyleGuide.CFrame.UpColor3;
                    Parent = parent;
                }, module.StyleGuide.CFrame.PartProperties)
                
                local back = draw({
                    CFrame = CFrame.new(origin + b/2, origin + b);
                    Size = Vector3.new(thickness, thickness, u.Magnitude);
                    Color = module.StyleGuide.CFrame.BackColor3;
                    Parent = parent;
                }, module.StyleGuide.CFrame.PartProperties)
                
                return right, up, back
            end
            
            -- Return
            
            return module
        end
        function _Draw2D()
            local module = {}
            
            -- Style Guide
            
            module.StyleGuide = {
                Point = {
                    BorderSizePixel = 0;
                    Size = UDim2.new(0, 4, 0, 4);
                    BorderColor3 = Color3.new(0, 0, 0);
                    BackgroundColor3 = Color3.new(0, 1, 0);
                },
                
                Line = {
                    Thickness = 1;
                    BorderSizePixel = 0;
                    BorderColor3 = Color3.new(0, 0, 0);
                    BackgroundColor3 = Color3.new(0, 1, 0);
                },
                
                Ray = {
                    Thickness = 1;
                    BorderSizePixel = 0;
                    BorderColor3 = Color3.new(0, 0, 0);
                    BackgroundColor3 = Color3.new(0, 1, 0);
                },
                
                Triangle = {
                    ImageTransparency = 0;
                    ImageColor3 = Color3.new(0, 1, 0);
                }
            }
            
            -- CONSTANTS
            
            local HALF = Vector2.new(0.5, 0.5)
            
            local RIGHT = "rbxassetid://2798177521"
            local LEFT = "rbxassetid://2798177955"
            
            local IMG = Instance.new("ImageLabel")
            IMG.BackgroundTransparency = 1
            IMG.AnchorPoint = HALF
            IMG.BorderSizePixel = 0
            
            local FRAME = Instance.new("Frame")
            FRAME.BorderSizePixel = 0
            FRAME.Size = UDim2.new(0, 0, 0, 0)
            FRAME.BackgroundColor3 = Color3.new(1, 1, 1)
            
            -- Functions
            
            function draw(properties, style)
                local frame = FRAME:Clone()
                for k, v in next, properties do
                    frame[k] = v
                end
                if (style) then
                    for k, v in next, style do
                        if (k ~= "Thickness") then
                            frame[k] = v
                        end
                    end
                end
                return frame
            end
            
            function module.Draw(parent, properties)
                properties.Parent = parent
                return draw(properties, nil)
            end
            
            function module.Point(parent, v2)
                return draw({
                    AnchorPoint = HALF;
                    Position = UDim2.new(0, v2.x, 0, v2.y);
                    Parent = parent;
                }, module.StyleGuide.Point)
            end
            
            function module.Line(parent, a, b)
                local v = (b - a)
                local m = (a + b)/2
                
                return draw({
                    AnchorPoint = HALF;
                    Position = UDim2.new(0, m.x, 0, m.y);
                    Size = UDim2.new(0, module.StyleGuide.Line.Thickness, 0, v.magnitude);
                    Rotation = math.deg(math.atan2(v.y, v.x)) - 90;
                    BackgroundColor3 = Color3.new(1, 1, 0);
                    Parent = parent;
                }, module.StyleGuide.Line)
            end
            
            function module.Ray(parent, origin, direction)
                local a, b = origin, origin + direction
                local v = (b - a)
                local m = (a + b)/2
                
                return draw({
                    AnchorPoint = HALF;
                    Position = UDim2.new(0, m.x, 0, m.y);
                    Size = UDim2.new(0, module.StyleGuide.Ray.Thickness, 0, v.magnitude);
                    Rotation = math.deg(math.atan2(v.y, v.x)) - 90;
                    Parent = parent;
                }, module.StyleGuide.Ray)
            end
            
            function module.Triangle(parent, a, b, c)
                local ab, ac, bc = b - a, c - a, c - b
                local abd, acd, bcd = ab:Dot(ab), ac:Dot(ac), bc:Dot(bc)
                
                if (abd > acd and abd > bcd) then
                    c, a = a, c
                elseif (acd > bcd and acd > abd) then
                    a, b = b, a
                end
                
                ab, ac, bc = b - a, c - a, c - b
                
                local unit = bc.unit
                local height = unit:Cross(ab)
                local flip = (height >= 0)
                local theta = math.deg(math.atan2(unit.y, unit.x)) + (flip and 0 or 180)
                
                local m1 = (a + b)/2
                local m2 = (a + c)/2
                
                local w1 = IMG:Clone()
                w1.Image = flip and RIGHT or LEFT
                w1.AnchorPoint = HALF
                w1.Size = UDim2.new(0, math.abs(unit:Dot(ab)), 0, height)
                w1.Position = UDim2.new(0, m1.x, 0, m1.y)
                w1.Rotation = theta
                w1.Parent = parent
                
                local w2 = IMG:Clone()
                w2.Image = flip and LEFT or RIGHT
                w2.AnchorPoint = HALF
                w2.Size = UDim2.new(0, math.abs(unit:Dot(ac)), 0, height)
                w2.Position = UDim2.new(0, m2.x, 0, m2.y)
                w2.Rotation = theta
                w2.Parent = parent
                
                for k, v in next, module.StyleGuide.Triangle do
                    w1[k] = v
                    w2[k] = v
                end
                
                return w1, w2
            end
            
            -- Return
            
            return module
        end
        function _DrawClass()
            local Draw2DModule = _Draw2D()
            local Draw3DModule = _Draw3D()
            
            --
            
            local DrawClass = {}
            local DrawClassStorage = setmetatable({}, {__mode = "k"})
            DrawClass.__index = DrawClass
            
            function DrawClass.new(parent)
                local self = setmetatable({}, DrawClass)
                
                self.Parent = parent
                DrawClassStorage[self] = {}
                
                self.Draw3D = {}
                for key, func in next, Draw3DModule do
                    self.Draw3D[key] = function(...)
                        local returns = {func(self.Parent, ...)}
                        for i = 1, #returns do
                            table.insert(DrawClassStorage[self], returns[i])
                        end
                        return unpack(returns)
                    end
                end
                
                self.Draw2D = {}
                for key, func in next, Draw2DModule do
                    self.Draw2D[key] = function(...)
                        local returns = {func(self.Parent, ...)}
                        for i = 1, #returns do
                            table.insert(DrawClassStorage[self], returns[i])
                        end
                        return unpack(returns)
                    end
                end
                
                return self
            end
            
            --
            
            function DrawClass:Clear()
                local t = DrawClassStorage[self]
                while (#t > 0) do
                    local part = table.remove(t)
                    if (part) then
                        part:Destroy()
                    end
                end
                DrawClassStorage[self] = {}
            end
            
            --
            
            return DrawClass
        end
        
        
        --END TEST
        
        local PLAYERS = game:GetService("Players")
        
        local GravityController = _GravityController()
        local Controller = GravityController.new(PLAYERS.LocalPlayer)
        
        local DrawClass = _DrawClass()
        
        local PI2 = math.pi*2
        local ZERO = Vector3.new(0, 0, 0)
        
        local LOWER_RADIUS_OFFSET = 3 
        local NUM_DOWN_RAYS = 24
        local ODD_DOWN_RAY_START_RADIUS = 3	
        local EVEN_DOWN_RAY_START_RADIUS = 2
        local ODD_DOWN_RAY_END_RADIUS = 1.66666
        local EVEN_DOWN_RAY_END_RADIUS = 1
        
        local NUM_FEELER_RAYS = 9
        local FEELER_LENGTH = 2
        local FEELER_START_OFFSET = 2
        local FEELER_RADIUS = 3.5
        local FEELER_APEX_OFFSET = 1
        local FEELER_WEIGHTING = 8
        
        function GetGravityUp(self, oldGravityUp)
            local ignoreList = {}
            for i, player in next, PLAYERS:GetPlayers() do
                ignoreList[i] = player.Character
            end
            
            -- get the normal
            
            local hrpCF = self.HRP.CFrame
            local isR15 = (self.Humanoid.RigType == Enum.HumanoidRigType.R15)
            
            local origin = isR15 and hrpCF.p or hrpCF.p + 0.35*oldGravityUp
            local radialVector = math.abs(hrpCF.LookVector:Dot(oldGravityUp)) < 0.999 and hrpCF.LookVector:Cross(oldGravityUp) or hrpCF.RightVector:Cross(oldGravityUp)
            
            local centerRayLength = 25
            local centerRay = Ray.new(origin, -centerRayLength * oldGravityUp)
            local centerHit, centerHitPoint, centerHitNormal = workspace:FindPartOnRayWithIgnoreList(centerRay, ignoreList)
            
            --[[disable
            DrawClass:Clear()
            DrawClass.Draw3D.Ray(centerRay.Origin, centerRay.Direction)
            ]]
            local downHitCount = 0
            local totalHitCount = 0
            local centerRayHitCount = 0
            local evenRayHitCount = 0
            local oddRayHitCount = 0
            
            local mainDownNormal = ZERO
            if (centerHit) then
                mainDownNormal = centerHitNormal
                centerRayHitCount = 0
            end
            
            local downRaySum = ZERO
            for i = 1, NUM_DOWN_RAYS do
                local dtheta = PI2 * ((i-1)/NUM_DOWN_RAYS)
                
                local angleWeight = 0.25 + 0.75 * math.abs(math.cos(dtheta))
                local isEvenRay = (i%2 == 0)
                local startRadius = isEvenRay and EVEN_DOWN_RAY_START_RADIUS or ODD_DOWN_RAY_START_RADIUS	
                local endRadius = isEvenRay and EVEN_DOWN_RAY_END_RADIUS or ODD_DOWN_RAY_END_RADIUS
                local downRayLength = centerRayLength
                
                local offset = CFrame.fromAxisAngle(oldGravityUp, dtheta) * radialVector
                local dir = (LOWER_RADIUS_OFFSET * -oldGravityUp + (endRadius - startRadius) * offset)
                local ray = Ray.new(origin + startRadius * offset, downRayLength * dir.unit)
                local hit, hitPoint, hitNormal = workspace:FindPartOnRayWithIgnoreList(ray, ignoreList)
                --[[disable
                DrawClass.Draw3D.Ray(ray.Origin, ray.Direction)
                ]]
                if (hit) then
                    downRaySum = downRaySum + angleWeight * hitNormal
                    downHitCount = downHitCount + 1
                    if isEvenRay then
                        evenRayHitCount = evenRayHitCount + 1					
                    else
                        oddRayHitCount = oddRayHitCount + 1
                    end
                end
            end
            
            local feelerHitCount = 0	
            local feelerNormalSum = ZERO
            
            for i = 1, NUM_FEELER_RAYS do
                local dtheta = 2 * math.pi * ((i-1)/NUM_FEELER_RAYS)
                local angleWeight =  0.25 + 0.75 * math.abs(math.cos(dtheta))	
                local offset = CFrame.fromAxisAngle(oldGravityUp, dtheta) * radialVector
                local dir = (FEELER_RADIUS * offset + LOWER_RADIUS_OFFSET * -oldGravityUp).unit
                local feelerOrigin = origin - FEELER_APEX_OFFSET * -oldGravityUp + FEELER_START_OFFSET * dir
                local ray = Ray.new(feelerOrigin, FEELER_LENGTH * dir)
                local hit, hitPoint, hitNormal = workspace:FindPartOnRayWithIgnoreList(ray, ignoreList)
                --[[disable
                DrawClass.Draw3D.Ray(ray.Origin, ray.Direction)
                ]]
                if (hit) then
                    feelerNormalSum = feelerNormalSum + FEELER_WEIGHTING * angleWeight * hitNormal --* hitDistSqInv
                    feelerHitCount = feelerHitCount + 1
                end
            end
            
            if (centerRayHitCount + downHitCount + feelerHitCount > 0) then
                local normalSum = mainDownNormal + downRaySum + feelerNormalSum
                if (normalSum ~= ZERO) then
                    return normalSum.unit
                end
            end
            
            return oldGravityUp
        end
        
        Controller.GetGravityUp = GetGravityUp
        
        -- E is toggle
        game:GetService("ContextActionService"):BindAction("Toggle", function(action, state, input)
            if not (state == Enum.UserInputState.Begin) then
                return
            end
            
            if (Controller) then
                Controller:Destroy()
                Controller = nil
            else
                Controller = GravityController.new(PLAYERS.LocalPlayer)
                Controller.GetGravityUp = GetGravityUp
            end
        end, false, Enum.KeyCode.Z)
        print("end")
end)

Section:NewButton("Work At A Pizza Place", "Cheating time!", function()
    -- updated by zade#1337 originally made by serilKilla
    -- working as of 18/01/2023
    getupvalues = getupvalues or debug.getupvalues
    setupvalue = setupvalue or debug.setupvalue
    if not (getrawmetatable and getupvalues and setupvalue and (getreg or debug.getregistry)) then
        local h = Instance.new("Hint",workspace)
        h.Text = "Incompatible exploit."
        wait(3)
        h:Destroy()
        return
    end
    local settings = {refill_at=0, refill_end=60, deliver_at=24, stay_in_kitchen=true}
    local doCashier,doBoxer,doCook,doSupplier,doDelivery = true,true,true,false,true
    if readfile then
        pcall(function()
            local new = game:GetService("HttpService"):JSONDecode(readfile("PizzaFarm.txt"))
            --corruption?
            local doOverwrite=false
            for k,v in pairs(new) do
                if settings[k]==nil then
                    doOverwrite=true
                    new[k]=nil
                end
            end
            for k,v in pairs(settings) do
                if new[k]==nil then
                    doOverwrite=true
                    new[k]=v
                end
            end
            --use input
            if doOverwrite then
                warn("Settings overwritten")
                writefile("PizzaFarm.txt",game:GetService("HttpService"):JSONEncode(new))
            end
            settings = new
        end)
    end

    if getconnections then
        for _,c in next,getconnections(game:GetService("ScriptContext").Error) do
            c:Disable()
        end
    end

    local player = game:GetService("Players").LocalPlayer
    local ffc = game.FindFirstChild
    local RNG = Random.new()
    local network
    local character,root,humanoid
    do
        local reg = (getreg or debug.getregistry)()
        for i=1,#reg do
            local f = reg[i]
            if type(f)=="function" then
                for k,v in next,getupvalues(f) do
                    if typeof(v)=="Instance" then
                        if v.Name=="CashOut" then
                            setupvalue(f,k,{MouseButton1Click={wait=function()end,Wait=function()end}})
                        elseif v.Name=="StickerName" then
                            setupvalue(f,k,nil)
                        end
                    end
                end
                if tostring(getfenv(f).script) == "Music" then
                    local consts = getconstants(f)
                    local loc=false
                    for ci,c in next,consts do
                        if c == "location changed" then
                            loc=true
                        elseif loc and c == "SendData" then
                            setconstant(f,ci,"ExplodeString")
                            break
                        end
                    end
                end
            elseif type(f)=="table" and rawget(f,"FireServer") and rawget(f,"BindEvents") then
                network = f
            end
        end
    end
    assert(network,"failed to find network")
    --//gui
    Create = function(class,parent,props)
        local new = Instance.new(class)
        for k,v in next,props do
            new[k]=v
        end
        new.Parent = parent
        return new
    end
    gui=Create("ScreenGui",game.CoreGui,{Name="Farm", ZIndexBehavior="Sibling"})
    main=Create("Frame",gui,{Name="main", Draggable=true, Active=true, Size=UDim2.new(0,350,0,100), Position=UDim2.new(.335,0,0.02,0), BackgroundColor3=Color3.new(0.098,0.098,0.098)})
    topbar=Create("Frame",main,{Name="topbar", Size=UDim2.new(1,0,0.15,0), BackgroundColor3=Color3.new(0.255,0.255,0.255)})
    closeBtn=Create("TextButton",topbar,{Name="closeBtn", TextWrapped=true, Size=UDim2.new(0.03,0,1,0), TextColor3=Color3.new(1,1,1), Text="X", BackgroundTransparency=1, 
        Font="GothamSemibold", Position=UDim2.new(0.96,0,0,0), TextSize=14, TextScaled=true, BackgroundColor3=Color3.new(1,1,1)})
    titleLbl=Create("TextLabel",topbar,{Name="titleLbl", TextWrapped=true, Size=UDim2.new(0.5,0,1,0), Text="Pizza Factory", TextSize=14, Font="GothamSemibold", 
        BackgroundTransparency=1, Position=UDim2.new(0.25,0,0,0), TextColor3=Color3.new(1,1,1), BackgroundColor3=Color3.new(1,1,1)})
    saveBtn=Create("ImageButton",topbar,{Name="saveBtn", Image="rbxassetid://55687833", Size=UDim2.new(0.05,0,1,0), Position=UDim2.new(0.01,0,0,0), BackgroundTransparency=1, BackgroundColor3=Color3.new(), Visible=writefile~=nil})
    settings_1=Create("Frame",main,{Name="settings", BackgroundTransparency=1, Size=UDim2.new(0.97,0,0.75,0), Position=UDim2.new(0.025,0,0.2,0), BackgroundColor3=Color3.new(1,1,1)})
    Layout=Create("UIGridLayout",settings_1,{VerticalAlignment="Center", SortOrder="LayoutOrder", HorizontalAlignment="Center", CellPadding=UDim2.new(0.01,0,0.1,0), CellSize=UDim2.new(0.325,0,0.26,0)})
    cashier=Create("Frame",settings_1,{Name="cashier", LayoutOrder=4, BackgroundTransparency=1, Size=UDim2.new(0,100,0,100), BackgroundColor3=Color3.new(1,1,1)})
    Label=Create("TextLabel",cashier,{TextWrapped=true, Size=UDim2.new(0.6,0,1,0), Text="Cashier", TextSize=14, TextXAlignment="Left", Font="SourceSans", 
        BackgroundTransparency=1, Position=UDim2.new(0.4,0,0,0), TextColor3=Color3.new(1,1,1), TextScaled=true, BackgroundColor3=Color3.new(1,1,1)})
    cashierBtn=Create("ImageButton",cashier,{Name="cashierBtn", ImageTransparency=1, BorderSizePixel=0, Size=UDim2.new(0.38,0,1,0), BackgroundColor3=Color3.new(0.392,0.392,0.392)})
    cashierSlider=Create("Frame",cashierBtn,{Name="slider", Size=UDim2.new(0.5,-4,1,-4), Position=UDim2.new(doCashier and 0.5 or 0,2,0,2), BorderSizePixel=0, BackgroundColor3=Color3.new(0.784,0.784,0.784)})
    kitchen=Create("Frame",settings_1,{Name="kitchen", LayoutOrder=9, BackgroundTransparency=1, Size=UDim2.new(0,100,0,100), BackgroundColor3=Color3.new(1,1,1)})
    Label_2=Create("TextLabel",kitchen,{TextWrapped=true, Size=UDim2.new(0.6,0,1,0), Text="Deliver At:", TextSize=14, TextXAlignment="Right", Font="SourceSans", 
        BackgroundTransparency=1, TextColor3=Color3.new(1,1,1), TextScaled=true, BackgroundColor3=Color3.new(1,1,1)})
    deliverAtBox=Create("TextBox",kitchen,{Name="deliverAtBox", TextWrapped=true, Size=UDim2.new(0.25,0,1,0), Text=tostring(settings.deliver_at), TextSize=50, TextColor3=Color3.new(), 
        Font="Code", Position=UDim2.new(0.62,0,0,0), TextScaled=true, BackgroundColor3=Color3.new(0.784,0.784,0.784)})
    refillEnd=Create("Frame",settings_1,{Name="refillEnd", LayoutOrder=8, BackgroundTransparency=1, Size=UDim2.new(0,100,0,100), BackgroundColor3=Color3.new(1,1,1)})
    refillEndBox=Create("TextBox",refillEnd,{Name="refillEndBox", TextWrapped=true, Size=UDim2.new(0.25,0,1,0), Text=tostring(settings.refill_end), TextSize=50, TextColor3=Color3.new(), 
        Font="Code", Position=UDim2.new(0.62,0,0,0), TextScaled=true, BackgroundColor3=Color3.new(0.784,0.784,0.784)})
    Label_3=Create("TextLabel",refillEnd,{TextWrapped=true, Size=UDim2.new(0.6,0,1,0), Text="Refill End:", TextSize=14, TextXAlignment="Right", Font="SourceSans", 
        BackgroundTransparency=1, TextColor3=Color3.new(1,1,1), TextScaled=true, BackgroundColor3=Color3.new(1,1,1)})
    refillAt=Create("Frame",settings_1,{Name="refillAt", LayoutOrder=7, BackgroundTransparency=1, Size=UDim2.new(0,100,0,100), BackgroundColor3=Color3.new(1,1,1)})
    Label_4=Create("TextLabel",refillAt,{TextWrapped=true, Size=UDim2.new(0.5,0,1,0), Text="Refill At:", TextSize=14, TextXAlignment="Right", Font="SourceSans", 
        BackgroundTransparency=1, TextColor3=Color3.new(1,1,1), TextScaled=true, BackgroundColor3=Color3.new(1,1,1)})
    refillAtBox=Create("TextBox",refillAt,{Name="refillAtBox", TextWrapped=true, Size=UDim2.new(0.25,0,1,0), Text=tostring(settings.refill_at), TextSize=50, TextColor3=Color3.new(), 
        Font="Code", Position=UDim2.new(0.52,0,0,0), TextScaled=true, BackgroundColor3=Color3.new(0.784,0.784,0.784)})
    supplier=Create("Frame",settings_1,{Name="supplier", LayoutOrder=6, BackgroundTransparency=1, Size=UDim2.new(0,100,0,100), BackgroundColor3=Color3.new(1,1,1)})
    Label_5=Create("TextLabel",supplier,{TextWrapped=true, Size=UDim2.new(0.6,0,1,0), Text="Supplier", TextSize=14, TextXAlignment="Left", Font="SourceSans", 
        BackgroundTransparency=1, Position=UDim2.new(0.4,0,0,0), TextColor3=Color3.new(1,1,1), TextScaled=true, BackgroundColor3=Color3.new(1,1,1)})
    supplierBtn=Create("ImageButton",supplier,{Name="supplierBtn", ImageTransparency=1, BorderSizePixel=0, Size=UDim2.new(0.38,0,1,0), BackgroundColor3=Color3.new(0.392,0.392,0.392)})
    supplierSlider=Create("Frame",supplierBtn,{Name="slider", Size=UDim2.new(0.5,-4,1,-4), Position=UDim2.new(doSupplier and 0.5 or 0,2,0,2), BorderSizePixel=0, BackgroundColor3=Color3.new(0.784,0.784,0.784)})
    delivery=Create("Frame",settings_1,{Name="delivery", LayoutOrder=5, BackgroundTransparency=1, Size=UDim2.new(0,100,0,100), BackgroundColor3=Color3.new(1,1,1)})
    Label_6=Create("TextLabel",delivery,{TextWrapped=true, Size=UDim2.new(0.6,0,1,0), Text="Delivery", TextSize=14, TextXAlignment="Left", Font="SourceSans", 
        BackgroundTransparency=1, Position=UDim2.new(0.4,0,0,0), TextColor3=Color3.new(1,1,1), TextScaled=true, BackgroundColor3=Color3.new(1,1,1)})
    deliveryBtn=Create("ImageButton",delivery,{Name="deliveryBtn", ImageTransparency=1, BorderSizePixel=0, Size=UDim2.new(0.38,0,1,0), BackgroundColor3=Color3.new(0.392,0.392,0.392)})
    deliverySlider=Create("Frame",deliveryBtn,{Name="slider", Size=UDim2.new(0.5,-4,1,-4), Position=UDim2.new(doDelivery and 0.5 or 0,2,0,2), BorderSizePixel=0, BackgroundColor3=Color3.new(0.784,0.784,0.784)})
    boxer=Create("Frame",settings_1,{Name="boxer", LayoutOrder=2, BackgroundTransparency=1, Size=UDim2.new(0,100,0,100), BackgroundColor3=Color3.new(1,1,1)})
    boxerLbl=Create("TextLabel",boxer,{TextWrapped=true, Size=UDim2.new(0.6,0,1,0), Text="Boxer", TextSize=14, TextXAlignment="Left", Font="SourceSans", 
        BackgroundTransparency=1, Position=UDim2.new(0.4,0,0,0), TextColor3=Color3.new(1,1,1), TextScaled=true, BackgroundColor3=Color3.new(1,1,1)})
    boxerBtn=Create("ImageButton",boxer,{Name="boxerBtn", ImageTransparency=1, BorderSizePixel=0, Size=UDim2.new(0.38,0,1,0), BackgroundColor3=Color3.new(0.392,0.392,0.392)})
    boxerSlider=Create("Frame",boxerBtn,{Name="slider", Size=UDim2.new(0.5,-4,1,-4), Position=UDim2.new(doBoxer and 0.5 or 0,2,0,2), BorderSizePixel=0, BackgroundColor3=Color3.new(0.784,0.784,0.784)})
    cook=Create("Frame",settings_1,{Name="cook", LayoutOrder=3, BackgroundTransparency=1, Size=UDim2.new(0,100,0,100), BackgroundColor3=Color3.new(1,1,1)})
    cookLbl=Create("TextLabel",cook,{TextWrapped=true, Size=UDim2.new(0.6,0,1,0), Text="Cook", TextSize=14, TextXAlignment="Left", Font="SourceSans", 
        BackgroundTransparency=1, Position=UDim2.new(0.4,0,0,0), TextColor3=Color3.new(1,1,1), TextScaled=true, BackgroundColor3=Color3.new(1,1,1)})
    cookBtn=Create("ImageButton",cook,{Name="cookBtn", ImageTransparency=1, BorderSizePixel=0, Size=UDim2.new(0.38,0,1,0), BackgroundColor3=Color3.new(0.392,0.392,0.392)})
    cookSlider=Create("Frame",cookBtn,{Name="slider", Size=UDim2.new(0.5,-4,1,-4), Position=UDim2.new(doCook and 0.5 or 0,2,0,2), BorderSizePixel=0, BackgroundColor3=Color3.new(0.784,0.784,0.784)})
    toggleAll=Create("Frame",settings_1,{Name="toggleAll", LayoutOrder=1, BackgroundTransparency=1, Size=UDim2.new(0,100,0,100), BackgroundColor3=Color3.new(1,1,1)})
    switch=Create("Frame",toggleAll,{Name="switch", BackgroundTransparency=1, Size=UDim2.new(0.75,0,1,0), BackgroundColor3=Color3.new(1,1,1)})
    allOffBtn=Create("ImageButton",switch,{Name="allOffBtn", ImageTransparency=1, BorderSizePixel=0, Size=UDim2.new(0.5,0,1,0), BackgroundColor3=Color3.new(0.235,0.235,0.235)})
    allOnBtn=Create("ImageButton",switch,{Name="allOnBtn", ImageTransparency=1, BorderSizePixel=0, Size=UDim2.new(0.5,0,1,0), Position=UDim2.new(0.5,0,0,0), BackgroundColor3=Color3.new(0.333,0.333,0.333)})
    toggleAllSlider=Create("Frame",switch,{Name="slider", Size=UDim2.new(0.1,0,1,4), Position=UDim2.new(0.45,0,0,-2), BorderSizePixel=0, BackgroundColor3=Color3.new(0.784,0.784,0.784)})
    messageLbl=Create("TextLabel",topbar,{Name="messageLbl", Size=UDim2.new(0.5,0,1,0), Text="Saved.", TextSize=14, Font="GothamSemibold", BackgroundTransparency=1, 
        Position=UDim2.new(0.07,0,0,0), TextColor3=Color3.new(1,1,1), Visible=false, TextXAlignment="Left"})
    camframe=Create("Frame",gui,{Name="camframe", BackgroundTransparency=1, Size=UDim2.new(0,120,0,40), Position=UDim2.new(0.5,-320,0,-38), BackgroundColor3=Color3.new(0.118,0.118,0.118)})
    rightCamBtn=Create("ImageButton",camframe,{Name="rightCamBtn", Image="rbxassetid://144168163", Size=UDim2.new(0.333,0,1,0), Rotation=180, Position=UDim2.new(0.666,0,0,0), BackgroundTransparency=1, 
        BackgroundColor3=Color3.new(1,1,1)})
    leftCamBtn=Create("ImageButton",camframe,{Name="leftCamBtn", Image="rbxassetid://144168163", Size=UDim2.new(0.333,0,1,0), BackgroundTransparency=1, BackgroundColor3=Color3.new(1,1,1)})
    centerCamBtn=Create("ImageButton",camframe,{Name="centerCamBtn", Image="rbxassetid://58282192", Size=UDim2.new(0.333,0,1,0), Position=UDim2.new(0.333,0,0,0), BackgroundTransparency=1, BackgroundColor3=Color3.new(1,1,1)})
    creditLbl=Create("TextLabel",main,{Position=UDim2.new(0,0,1,5),Size=UDim2.new(0,100,0,15),BackgroundTransparency=1,TextColor3=Color3.new(1,1,1),Text="by sirelKilla",TextScaled=true,TextStrokeTransparency=.8})

    local function toggleCashier(bool)
        if bool~=nil then
            doCashier=bool
        else
            doCashier = not doCashier
        end
        cashierSlider:TweenPosition(UDim2.new(doCashier and 0.5 or 0,2,0,2),nil,"Sine",0.1,true)
    end
    local function toggleCook(bool)
        if bool~=nil then
            doCook=bool
        else
            doCook = not doCook
        end
        cookSlider:TweenPosition(UDim2.new(doCook and 0.5 or 0,2,0,2),nil,"Sine",0.1,true)
    end
    local function toggleBoxer(bool)
        if bool~=nil then
            doBoxer=bool
        else
            doBoxer = not doBoxer
        end
        boxerSlider:TweenPosition(UDim2.new(doBoxer and 0.5 or 0,2,0,2),nil,"Sine",0.1,true)
    end
    local function toggleDelivery(bool)
        if bool~=nil then
            doDelivery=bool
        else
            doDelivery = not doDelivery
        end
        deliverySlider:TweenPosition(UDim2.new(doDelivery and 0.5 or 0,2,0,2),nil,"Sine",0.1,true)
    end
    local function toggleSupplier(bool)
        if bool~=nil then
            doSupplier=bool
        else
            doSupplier = not doSupplier
        end
        supplierSlider:TweenPosition(UDim2.new(doSupplier and 0.5 or 0,2,0,2),nil,"Sine",0.1,true)
    end
    cashierBtn.MouseButton1Click:Connect(toggleCashier)
    cookBtn.MouseButton1Click:Connect(toggleCook)
    boxerBtn.MouseButton1Click:Connect(toggleBoxer)
    deliveryBtn.MouseButton1Click:Connect(toggleDelivery)
    allOffBtn.InputBegan:Connect(function()
        if game:GetService("UserInputService"):IsMouseButtonPressed(Enum.UserInputType.MouseButton1) then
            toggleCashier(false)
            toggleCook(false)
            toggleBoxer(false)
            toggleDelivery(false)
            toggleSupplier(false)
            toggleAllSlider:TweenPosition(UDim2.new(0,0,0,-2),nil,"Sine",0.1,true)
            wait(1)
            if toggleAllSlider.Position.X.Scale<.01 then
                toggleAllSlider:TweenPosition(UDim2.new(0.45,0,0,-2),nil,"Sine",0.1,true)
            end
        end
    end)
    allOnBtn.InputBegan:Connect(function()
        if game:GetService("UserInputService"):IsMouseButtonPressed(Enum.UserInputType.MouseButton1) then
            toggleCashier(true)
            toggleCook(true)
            toggleBoxer(true)
            toggleDelivery(true)
            toggleSupplier(true)
            toggleAllSlider:TweenPosition(UDim2.new(0.9,0,0,-2),nil,"Sine",0.1,true)
            wait(1)
            if toggleAllSlider.Position.X.Scale>.88 then
                toggleAllSlider:TweenPosition(UDim2.new(0.45,0,0,-2),nil,"Sine",0.1,true)
            end
        end
    end)
    local oldRefillAt=refillAtBox.Text
    refillAtBox:GetPropertyChangedSignal("Text"):Connect(function()
        if #refillAtBox.Text>2 or refillAtBox.Text:match("%D") then
            refillAtBox.Text = oldRefillAt
        end
        oldRefillAt = refillAtBox.Text
    end)
    refillAtBox.FocusLost:Connect(function()
        if tonumber(refillAtBox.Text) then
            settings.refill_at=tonumber(refillAtBox.Text)
        end
        refillAtBox.Text=tostring(settings.refill_at)
    end)
    local oldRefillEnd=refillEndBox.Text
    refillEndBox:GetPropertyChangedSignal("Text"):Connect(function()
        if #refillEndBox.Text>2 or refillEndBox.Text:match("%D") then
            refillEndBox.Text = oldRefillEnd
        end
        oldRefillEnd = refillEndBox.Text
    end)
    refillEndBox.FocusLost:Connect(function()
        if tonumber(refillEndBox.Text) then
            settings.refill_end=tonumber(refillEndBox.Text)
        end
        refillEndBox.Text=tostring(settings.refill_end)
    end)
    local oldDeliverAt=deliverAtBox.Text
    deliverAtBox:GetPropertyChangedSignal("Text"):Connect(function()
        if #deliverAtBox.Text>2 or deliverAtBox.Text:match("%D") then
            deliverAtBox.Text = oldDeliverAt
        end
        oldDeliverAt = deliverAtBox.Text
    end)
    deliverAtBox.FocusLost:Connect(function()
        if tonumber(deliverAtBox.Text) then
            settings.deliver_at=tonumber(deliverAtBox.Text)
        end
        deliverAtBox.Text=tostring(settings.deliver_at)
    end)
    closeBtn.MouseButton1Click:Connect(function()
        gui:Destroy()
        doCashier,doBoxer,doCook,doSupplier,doDelivery = false,false,false,false,false
    end)
    closeBtn.MouseEnter:Connect(function() closeBtn.TextColor3=Color3.new(.9,0,0) end)
    closeBtn.MouseLeave:Connect(function() closeBtn.TextColor3=Color3.new(1,1,1) end)
    saveBtn.MouseButton1Click:Connect(function()
        if writefile and messageLbl.Visible==false then
            writefile("PizzaFarm.txt",game:GetService("HttpService"):JSONEncode(settings))
            messageLbl.Visible=true
            wait(2)
            messageLbl.Visible=false
        end
    end)
    local cameraArray = {CFrame.new(23,14,65,0.629,0.386,-0.674,-0,0.867,0.497,0.777,-0.313,0.545),CFrame.new(39,15,83,-0.571,0.392,-0.720,-0,0.878,0.478,0.820,0.273,-0.502),CFrame.new(40,20,-38,-0.801,-0.229,0.552,-0,0.923,0.384,-0.598,0.307,-0.739),CFrame.new(51,15,-25,-0.707,0.338,-0.620,0,0.878,0.478,0.707,0.338,-0.620),CFrame.new(47,12,21,0.026,0.323,-0.945,-0,0.946,0.323,0.999,-0.008,0.024)}
    local cameraIndex = 0
    centerCamBtn.MouseButton1Click:Connect(function()
        cameraIndex = 0
        workspace.CurrentCamera.CameraType = "Custom"
    end)
    leftCamBtn.MouseButton1Click:Connect(function()
        cameraIndex = cameraIndex - 1
        if cameraIndex < 0 then
            cameraIndex = #cameraArray
        end
        if cameraIndex == 0 then
            workspace.CurrentCamera.CameraType="Custom"
        else
            local cf = cameraArray[cameraIndex]
            workspace.CurrentCamera.CameraType="Scriptable"
            workspace.CurrentCamera:Interpolate(cf,cf+cf.lookVector*10,0.5)
        end
    end)
    rightCamBtn.MouseButton1Click:Connect(function()
        cameraIndex = cameraIndex + 1
        if cameraIndex > #cameraArray then
            cameraIndex = 0
            workspace.CurrentCamera.CameraType="Custom"
        else
            local cf = cameraArray[cameraIndex]
            workspace.CurrentCamera.CameraType="Scriptable"
            workspace.CurrentCamera:Interpolate(cf,cf+cf.lookVector*10,0.5)
        end
    end)

    --//subroutines
    --local supplyCounts = {TomatoSauce=99,Cheese=99,Sausage=99,Pepperoni=99,Dough=99,Box=99,Dew=99}
    --for name in pairs(supplyCounts) do
        --local lbl = workspace.SupplyCounters[name=="Dew" and "CounterMountainDew" or "Counter"..name].a.SG.Counter
        --supplyCounts[name]=tonumber(lbl.Text)
        --lbl.Changed:Connect(function()
            --supplyCounts[name]=tonumber(lbl.Text)
        --end)
    --end

    local function FindFirstCustomer()
        local children = workspace.Customers:GetChildren()
        for i=1,#children do
            local c = children[i]
            if ffc(c,"Head") and ffc(c,"Humanoid") and c.Head.CFrame.Z<102 and ffc(c.Head,"Dialog") and ffc(c.Head.Dialog,"Correct") and ((c.Humanoid.SeatPart and c.Humanoid.SeatPart.Anchored) or (c.Humanoid.SeatPart==nil and (c.Head.Velocity.Z^2)^.5<.0001)) then
                local dialog = c.Head.Dialog.Correct.ResponseDialog or ''
                local order = "MountainDew"
                if dialog:sub(-8)=="instead." then
                    dialog = dialog:sub(-30)
                end
                if dialog:find("pepperoni",1,true) then
                    order = "PepperoniPizza"
                elseif dialog:find("sausage",1,true) then
                    order = "SausagePizza"
                elseif dialog:find("cheese",1,true) then
                    order = "CheesePizza"
                end
                return c,order
            end
        end
    end

    local boxPtick=0
    local boxDtick=0
    local function FindBoxes()
        local c,o,f
        local children = workspace.AllBox:GetChildren()
        for i=1,#children do
            local b = children[i]
            if ffc(b,"HasPizzaInside") or ffc(b,"Pizza") then
                if c==nil and b.Name=="BoxClosed" and b.Anchored==false and not b.HasPizzaInside.Value then
                    c=b
                elseif o==nil and b.Name=="BoxOpen" and b.Anchored==false and not b.Pizza.Value then
                    o=b
                elseif f==nil and (b.Name=="BoxOpen" and b.Pizza.Value) or (b.Name=="BoxClosed" and b.HasPizzaInside.Value) then
                    f=b
                end
                if c and o and f then
                    return c,o,f
                end
            end
        end
        return c,o,f
    end
    local function FindBoxingFoods()
        local p,d
        local children = workspace.BoxingRoom:GetChildren()
        for i=1,#children do
            local f = children[i]
            if not f.Anchored then
                if p==nil and f.Name=="Pizza" then
                    p=f
                elseif d==nil and f.Name=="Dew" then
                    d=f
                end
                if p and d then
                    return p,d
                end
            end
        end
        return p,d
    end

    local orderDict={["3540529228"]="Cheese",["3540530535"]="Sausage",["3540529917"]="Pepperoni",["2512571151"]="Dew",["2512441325"]="Dew"}
    local cookingDict = {Cheese=0,Sausage=0,Pepperoni=0,Dew=0}
    local cookPtick=0
    local cookDtick=0
    local cookWarned=false
    local boxerWarned=false
    local function getOrders()
        local orders={}
        local tempCookingDict = {}
        for i,v in pairs(cookingDict) do tempCookingDict[i]=v end
        local children = workspace.Orders:GetChildren()
        for i=1,#children do
            local o = orderDict[children[i].SG.ImageLabel.Image:match("%d+$")]
            if o then
                if tempCookingDict[o]>0 then
                    --ignores oven pizzas, so new orders are priority
                    tempCookingDict[o]=tempCookingDict[o]-1
                --elseif (o=="Dew" and #workspace.AllMountainDew:GetChildren()>0) or (supplyCounts[o]>0 and supplyCounts.TomatoSauce>0 and supplyCounts.Cheese>0) then
                    --need supplies
                    orders[#orders+1]=o
                end
            end
        end
        return orders
    end
    local function FindFirstDew()
        local children = workspace.AllMountainDew:GetChildren()
        for i=1,#children do
            local d = children[i]
            if (ffc(d,"IsBurned")==nil or d.IsBurned.Value==false) and not d.Anchored then
                return d
            end
        end
    end
    local function FindBadDew()
        local children = workspace.AllMountainDew:GetChildren()
        for i=1,#children do
            local d = children[i]
            if (ffc(d,"IsBurned")==nil or d.IsBurned.Value==false) and d.Position.X > 53 and d.Position.Z > 50 and not d.Anchored then
                return d
            end
        end
    end
    local function FindDoughAndWithout(str)
        local goodraw,p,raw,trash
        local children = workspace.AllDough:GetChildren()
        for i = #children, 2, -1 do --shuffle
            local j = RNG:NextInteger(1, i)
            children[j], children[i] = children[i], children[j]
        end
        for i=1,#children do
            local d = children[i]
            if d.Anchored==false and #d:GetChildren()>9 then
                if d.IsBurned.Value or d.HasBugs.Value or d.Cold.Value or (d.BrickColor.Name=="Bright orange" and ffc(d,"XBillboard")) then
                    if trash==nil and d.Position.Y > 0 and ((d.Position*Vector3.new(1,0,1))-Vector3.new(47.90, 0, 72.49)).Magnitude > 1 then
                        trash=d
                    end
                elseif p==nil and d.BrickColor.Name=="Bright orange" then
                    p=d
                elseif goodraw==nil and d.Position.X<55 and d.BrickColor.Name=="Brick yellow" and ((str and not ffc(d.SG.Frame,str)) or (str==nil and ffc(d.SG.Frame,"Sausage")==nil and ffc(d.SG.Frame,"Pepperoni")==nil)) then
                    --prefers flat
                    if d.Mesh.Scale.Y<1.1 then
                        goodraw=d
                    else
                        raw=d
                    end
                end
                if goodraw and p and trash then
                    return goodraw,p,trash
                end
            end
        end
        return goodraw or raw,p,trash
    end
    local function getOvenNear(pos)
        local children = workspace.Ovens:GetChildren()
        for i=1,#children do
            if ffc(children[i],"Bottom") and (children[i].Bottom.Position-pos).magnitude < 1.5 then
                return children[i]
            end
        end
    end
    local function getDoughNear(pos)
        local children = workspace.AllDough:GetChildren()
        for i=1,#children do
            if (children[i].Position-pos).magnitude < 1.5 then
                return children[i]
            end
        end
    end
    local function isFullyOpen(oven)
        return oven.IsOpen.Value==true and (oven.Door.Meter.RotVelocity.Z^2)^.5<.0001
    end

    local bcolorToSupply = {["Dark orange"]="Sausage",["Bright blue"]="Pepperoni",["Bright yellow"]="Cheese",["Bright red"]="TomatoSauce",["Dark green"]="Dew",["Brick yellow"]="Dough",["Light stone grey"]="Box",["Really black"]="Dew"}
    local supplyButtons = {}
    for i,v in ipairs(workspace.SupplyButtons:GetChildren()) do
        supplyButtons[i] = v.Unpressed
    end
    table.sort(supplyButtons,function(a,b) return a.Position.X < b.Position.X end)
    local delTick = 0
    local function FindAllDeliveryTools(parent)
        local t = {}
        local children = parent:GetChildren()
        for i=1,#children do
            local v = children[i]
            if v.ClassName=="Tool" and v.Name:match("^%u%d$") and ffc(v,"Handle") and ffc(v,"House") and (parent~=workspace or (v.Handle.Position-Vector3.new(54.45, 4.02, -16.56)).Magnitude < 30) then
                t[#t+1] = v
            end
        end
        return t
    end
    local function getHousePart(address)
        local houses = workspace.Houses:GetChildren()
        for i=1,#houses do
            local h = houses[i]
            if ffc(h,"Address") and h.Address.Value==address and ffc(h,"GivePizza",true) then
                return ffc(h,"GivePizza",true)
            end
        end
    end
    local function onCharacterAdded(char)
        if not char then return end
        character=char
        root = character:WaitForChild("HumanoidRootPart")
        humanoid = character:WaitForChild("Humanoid")
        humanoid:SetStateEnabled("FallingDown",false)
    end
    onCharacterAdded(player.Character or player.CharacterAdded:Wait())
    player.CharacterAdded:Connect(onCharacterAdded)

    local function smoothTP2(cf)
        local cf0 = (cf-cf.p) + root.Position + Vector3.new(0,4,0)
        local diff = cf.p - root.Position
        local oldg = workspace.Gravity
        workspace.Gravity = 0
        for i=0,diff.Magnitude,0.9 do
            humanoid.Sit=false
            root.CFrame = cf0 + diff.Unit * i
            root.Velocity,root.RotVelocity=Vector3.new(),Vector3.new()
            wait()
        end
        root.CFrame = cf
        workspace.Gravity = oldg
    end
    local function smoothTP(cf)
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = cf
    end
    for _,o in ipairs(workspace.Ovens:GetChildren()) do
        if ffc(o,"Bottom") then
            o.Bottom.CanTouch = false
        end
    end
    local function tryCook()
        for zz=1,18 do
            local order = getOrders()[1]
            local topping
            if order=="Pepperoni" or order=="Sausage" then topping=order end
            local cookD = FindFirstDew()
            local badD = FindBadDew()
            local raw,cookP,trash
            if topping then
                --pepperoni order avoids sausage dough and vice verca
                raw,cookP,trash = FindDoughAndWithout(topping=="Pepperoni" and "Sausage" or "Pepperoni")
            else
                raw,cookP,trash = FindDoughAndWithout()
            end
            local ovens = workspace.Ovens:GetChildren()
            for i=#ovens,1,-1 do
                if #ovens[i]:GetChildren() < 10 then
                    table.remove(ovens,i)
                end
            end
            for i = #ovens, 2, -1 do --shuffle
                local j = RNG:NextInteger(1, i)
                ovens[j], ovens[i] = ovens[i], ovens[j]
            end
            if doCook then
                local didsomething=false
                --move final pizza
                if cookP and tick()-cookPtick>0.8 then
                    local oven = getOvenNear(cookP.Position)
                    if oven==nil or oven.IsOpen.Value then
                        cookPtick=tick()
                        didsomething=true
                        if (root.Position-Vector3.new(36.64, 3.80, 54.11)).magnitude>9 then  smoothTP(CFrame.new(36.64, 3.80, 54.11)) wait(.1) end
                        network:FireServer("UpdateProperty", cookP, "CFrame", CFrame.new(RNG:NextNumber(56,57),4.1,38))
                    end
                end
                if order then
                    if order=="Dew" and cookD and tick()-cookDtick>0.8 then
                        --move dew if ordered
                        cookDtick=tick()
                        didsomething=true
                        if (root.Position-Vector3.new(36.64, 3.80, 54.11)).magnitude>9 then  smoothTP(CFrame.new(36.64, 3.80, 54.11)) wait(.1) end
                        network:FireServer("UpdateProperty", cookD, "CFrame", CFrame.new(53,4.68,36.5))
                    elseif order~="Dew" and raw and raw.Parent and supplyCounts[order]>0 and supplyCounts.TomatoSauce>0 and supplyCounts.Cheese>0 then
                        --make pizza
                        if raw.Mesh.Scale.Y>1.5 then
                            if (root.Position-Vector3.new(36.64, 3.80, 54.11)).magnitude>9 then  smoothTP(CFrame.new(36.64, 3.80, 54.11)) wait(.1) end
                            didsomething=true
                            network:FireServer("UpdateProperty", raw, "CFrame", CFrame.new(RNG:NextNumber(29.6,44.6),3.7,RNG:NextNumber(42.5,48.5)))
                            wait()
                            network:FireServer("SquishDough", raw)
                        else
                            --make sure it will have an oven
                            local oven
                            for _,o in ipairs(ovens) do
                                if isFullyOpen(o) then
                                    local other = getDoughNear(o.Bottom.Position)
                                    if other==nil or not (other.BrickColor.Name=="Bright orange" and ffc(other.SG.Frame,"TomatoSauce") and ffc(other.SG.Frame,"MeltedCheese")) then
                                        if other then
                                            --replace mistaken dough
                                            didsomething=true
                                            if (root.Position-Vector3.new(36.64, 3.80, 54.11)).magnitude>9 then  smoothTP(CFrame.new(36.64, 3.80, 54.11)) wait(.1) end
                                            network:FireServer("UpdateProperty", other, "CFrame", CFrame.new(RNG:NextNumber(29.6,44.6),3.7,RNG:NextNumber(42.5,48.5)))
                                            wait()
                                        end
                                        oven=o
                                        break
                                    end
                                end
                            end
                            if oven and raw.Parent==workspace.AllDough then
                                --make
                                if (root.Position-Vector3.new(36.64, 3.80, 54.11)).magnitude>9 then  smoothTP(CFrame.new(36.64, 3.80, 54.11)) wait(.1) end
                                didsomething=true
                                network:FireServer("AddIngredientToPizza", raw,"TomatoSauce")
                                network:FireServer("AddIngredientToPizza", raw,"Cheese")
                                network:FireServer("AddIngredientToPizza", raw,topping)
                                network:FireServer("UpdateProperty", raw, "CFrame", oven.Bottom.CFrame+Vector3.new(0,0.7,0))
                                oven.Door.ClickDetector.Detector:FireServer()
                                --mark as cooking
                                cookingDict[order]=cookingDict[order]+1
                                local revoked=false
                                spawn(function()
                                    raw.AncestryChanged:Wait()
                                    if not revoked then
                                        cookingDict[order]=cookingDict[order]-1
                                        revoked=true
                                    end
                                end)
                                delay(40, function()
                                    if not revoked then
                                        cookingDict[order]=cookingDict[order]-1
                                        revoked=true
                                    end
                                end)
                            end
                        end
                    end
                end
                --open unnecessarily closed ovens
                for _,o in ipairs(ovens) do
                    local bar = o.Door.Meter.SurfaceGui.ProgressBar.Bar
                    if o.IsOpen.Value==false and (o.IsCooking.Value==false or (Vector3.new(bar.ImageColor3.r,bar.ImageColor3.g,bar.ImageColor3.b)-Vector3.new(.871,.518,.224)).magnitude>.1) then
                        didsomething=true
                        if (root.Position-Vector3.new(36.64, 3.80, 54.11)).magnitude>9 then  smoothTP(CFrame.new(36.64, 3.80, 54.11)) wait(.1) end
                        o.Door.ClickDetector.Detector:FireServer()
                        break
                    end
                end
                --trash
                if badD then
                    didsomething=true
                    if (root.Position-Vector3.new(36.64, 3.80, 54.11)).magnitude>9 then  smoothTP(CFrame.new(36.64, 3.80, 54.11)) wait(.1) end
                    network:FireServer("UpdateProperty", badD, "CFrame", CFrame.new(RNG:NextNumber(28,30), 1.7, RNG:NextNumber(55,57)))
                end
                if trash and (trash.IsBurned.Value==false or getOvenNear(trash.Position)==nil or getOvenNear(trash.Position).IsOpen.Value) then
                    --closed oven breaks if you take burnt out of it
                    didsomething=true
                    if (root.Position-Vector3.new(36.64, 3.80, 54.11)).magnitude>9 then  smoothTP(CFrame.new(36.64, 3.80, 54.11)) wait(.1) end
                    network:FireServer("UpdateProperty", trash, "CFrame", CFrame.new(47.90, 7.00, 72.49, 1, 0, -0, 0, 0, 1, 0, -1, 0))
                end
                if didsomething then wait(0.5) else break end
            else
                break
            end
        end
    end
    wait(1)
    --//main loop
    while gui.Parent do
        wait(0.9)
        humanoid.Sit=false
        if RNG:NextInteger(1,20)==1 then
            game:GetService("VirtualInputManager"):SendKeyEvent(true,"Z",false,game)
            wait()
            game:GetService("VirtualInputManager"):SendKeyEvent(false,"Z",false,game)
        end
        for zz=1,3 do
            local c,order = FindFirstCustomer()
            if doCashier and c and order then
                local reg = 3
                if c.Head.Position.X < 50 then
                    reg = 2
                elseif c.Head.Position.X < 70 then
                    reg = 1
                end
                if (root.Position-Vector3.new(50.30, 3.80, 83.24)).magnitude>9 then smoothTP(CFrame.new(50.30, 3.80, 83.24)) wait(.1) end
                network:FireServer("OrderComplete", c, order, workspace["Register"..reg])
                wait(0.3)
            else
                break
            end
        end
        tryCook()
        for zz=1,7 do
            if doBoxer then
                local didsomething = false
                local boxP,boxD = FindBoxingFoods()
                local closedBox,openBox,fullBox = FindBoxes()
                if boxD and tick()-boxDtick>0.8 then
                    boxDtick=tick()
                    didsomething=true
                    if (root.Position-Vector3.new(58.74, 3.80, 12.400)).magnitude>9 then  smoothTP(CFrame.new(58.74, 3.80, 12.40))wait(.1) continue end
                    network:FireServer("UpdateProperty", boxD, "CFrame", CFrame.new(63,4.9,-1,-1,0,0,0,1,0,0,0,-1))
                end
                if fullBox then
                    if fullBox.Name=="BoxOpen" then
                        didsomething=true
                        if (root.Position-Vector3.new(58.74, 3.80, 12.400)).magnitude>9 then  smoothTP(CFrame.new(58.74, 3.80, 12.40))wait(.1) continue end
                        network:FireServer("CloseBox", fullBox)
                        --will be moved next loop
                    elseif tick()-boxPtick>0.8 then
                        didsomething=true
                        if (root.Position-Vector3.new(58.74, 3.80, 12.400)).magnitude>9 then  smoothTP(CFrame.new(58.74, 3.80, 12.40))wait(.1) continue end
                        network:FireServer("UpdateProperty", fullBox, "CFrame", CFrame.new(68.2,4.4,RNG:NextNumber(-3,-2),-1,0,0,0,1,0,0,0,-1))
                        boxPtick=tick()
                    end
                end
                if closedBox and not openBox then
                    didsomething=true
                    if (root.Position-Vector3.new(58.74, 3.80, 12.400)).magnitude>9 then  smoothTP(CFrame.new(58.74, 3.80, 12.40))wait(.1) continue end
                    network:FireServer("UpdateProperty", closedBox, "CFrame", CFrame.new(RNG:NextNumber(62.5,70.5),3.5,RNG:NextNumber(11,25)))
                    wait()
                    network:FireServer("OpenBox", closedBox)
                end
                if openBox and boxP then
                    didsomething=true
                    if (root.Position-Vector3.new(58.74, 3.80, 12.400)).magnitude>9 then  smoothTP(CFrame.new(58.74, 3.80, 12.40))wait(.1) continue end
                    network:FireServer("UpdateProperty", boxP, "Anchored", true)
                    network:FireServer("UpdateProperty", openBox, "Anchored", true)
                    wait()
                    network:FireServer("UpdateProperty", boxP, "CFrame", openBox.CFrame+Vector3.new(0,-2,0))
                    wait()
                    network:FireServer("AssignPizzaToBox", openBox, boxP)
                end
                if didsomething then wait(0.5) else break end
            else
                break
            end
        end
        if doDelivery then
            local wstools = FindAllDeliveryTools(workspace)
            if #wstools > 1 or (wstools[1] and ffc(wstools[1].Handle,"X10")) then
                --get tools
                if (root.Position-Vector3.new(54.45, 4.02, -15)).magnitude>9 then smoothTP(CFrame.new(54.45, 4.02, -15)) wait(.1) end
                for i=1,#wstools do
                    if wstools[i].Parent == workspace then
                        humanoid:EquipTool(wstools[i])
                        wait()
                    end
                end
                wait(0.3)
                local t = FindAllDeliveryTools(character)
                for i=1,#t do
                    t[i].Parent = player.Backpack
                end
                wait(0.1)
                if ffc(character,"RightHand") and ffc(character.RightHand,"RightGrip") then
                    character.RightHand.RightGrip:Destroy()
                end
            end
            local bptools = FindAllDeliveryTools(player.Backpack)
            if #bptools >= settings.deliver_at and #bptools > 0 and tick()-delTick > 30 then
                --deliver to houses
                table.sort(bptools,function(a,b)
                    a,b=tostring(a),tostring(b)
                    if (a:sub(1,1)=="B" and b:sub(1,1)=="B") then
                        return a < b
                    end
                    return a > b
                end)
                local fatass=false
                for i=1,#bptools do
                    if not doDelivery then
                        break
                    end
                    humanoid.Sit=false
                    local tool = bptools[i]
                    local giver = getHousePart(tool.Name)
                    local ogp = giver.Position
                    if giver then
                        if (giver.Position-root.Position).Magnitude > 9 then
                            smoothTP(giver.CFrame+Vector3.new(0,7,0))
                            if giver.Parent==nil or (giver.Position-ogp).Magnitude>1 then
                                giver = getHousePart(tool.Name) or giver
                                smoothTP(giver.CFrame+Vector3.new(0,7,0))
                            end
                            pcall(function() tool.Parent = character end)
                            wait(1.2)
                            local t = FindAllDeliveryTools(character)
                            for i=1,#t do
                                if t[i] ~= tool then
                                    t[i].Parent = player.Backpack
                                end
                            end
                            wait(2)
                            fatass=false
                        else
                            if fatass then
                                wait(0.2)
                            else
                                wait(0.7)
                            end
                            pcall(function() tool.Parent = character end)
                            wait()
                            fatass=true
                        end
                    end
                end
                delTick = tick()
            end
        end
        tryCook()
        if doSupplier then
            local refill=false
            for s,c in pairs(supplyCounts) do
                if c <= settings.refill_at then
                    refill=true
                    break
                end
            end
            if refill then
                local oldcf = root.CFrame
                local waiting = false
                local waitingTick = 0
                local lastBox
                while doSupplier do
                    --check if refill is done otherwise hit buttons
                    local fulfilled=true
                    local boxes = workspace.AllSupplyBoxes:GetChildren()
                    for yy=1,2 do
                    local needtp=true
                    local realc = 0
                    for _,btn in ipairs(supplyButtons) do
                        local s = bcolorToSupply[btn.BrickColor.Name]
                        if supplyCounts[s] < settings.refill_end then
                            local count = 0
                            if #boxes > 30 then
                                for i=1,#boxes do
                                    local box = boxes[i]
                                    if bcolorToSupply[box.BrickColor.Name]==s and box.Anchored==false and box.Position.Z < -940 then
                                        count=count+1
                                    end
                                end
                            end
                            if count < 2 then
                                if needtp then
                                    needtp=false
                                    smoothTP(btn.CFrame + Vector3.new(0,3,2.5))
                                    wait(0.1)
                                end
                                if not doSupplier then break end
                                root.CFrame = btn.CFrame + Vector3.new(0,3,0)
                                wait(0.1)
                                realc=realc+1
                            end
                            fulfilled=false
                        end
                    end
                    wait(0.2)
                    if yy == 1 and realc < 3 then
                        wait(0.6)
                    end
                    end
                    if fulfilled or not (doSupplier) then
                        break
                    end
                    smoothTP(CFrame.new(8,12.4,-1020))
                    if not doSupplier then break end
                    --check if can finish waiting for boxes to move
                    if waiting and (lastBox.Position.X>42 or tick()-waitingTick>6) then
                        waiting=false
                        if lastBox.Position.X<42 then
                            --clear boxes if stuck
                            smoothTP(CFrame.new(20.5,8,-35))
                            wait(0.1)
                            local boxes = workspace.AllSupplyBoxes:GetChildren()
                            for i=1,#boxes do
                                local box = boxes[i]
                                if box.Anchored==false and box.Position.Z>-55 then
                                    network:FireServer("UpdateProperty", box, "CFrame", CFrame.new(RNG:NextNumber(0,40),RNG:NextNumber(-10,-30),-70))
                                    wait()
                                end
                            end
                            wait(0.1)
                        end
                    end
                    if not waiting then
                        --move boxes
                        if root.Position.Z > -900 then smoothTP(CFrame.new(8,12.4,-1020)) end
                        wait(0.1)
                        lastBox=nil
                        local j=0
                        local boxes = workspace.AllSupplyBoxes:GetChildren()
                        for i=1,#boxes do
                            local box = boxes[i]
                            if box.Anchored==false and box.Position.Z < -940 and bcolorToSupply[box.BrickColor.Name] and supplyCounts[bcolorToSupply[box.BrickColor.Name]]<settings.refill_end then
                                box.CFrame = CFrame.new(38-4.3*math.floor(j/2),5,-7-5*(j%2))
                                network:FireServer("UpdateProperty", box, "CFrame", box.CFrame)
                                lastBox=box
                                j=j+1
                                if j>13 then break end
                            end
                        end
                        if lastBox then
                            waiting=true
                            waitingTick=tick()
                        end
                    end
                end
                --smoothTP(oldcf)
            end
        end
    end
end)

Section:NewButton("Zyrex Hub", "-", function()
    _G.Toggle_GUI = Enum.KeyCode.RightControl

    loadstring(game:HttpGet(("https://raw.githubusercontent.com/NotZyrex/Zyrex-Hub/master/Main.lua"), true))();
end)

Section:NewButton("Sniper [BETA]", "Cheating time!", function()
    _, Protected_by_MoonSecV2, Discord = 'discord.gg/gQEH2uZxUk'


 ,nil,nil;(function() _msec=(function(o,l,b)local q=l[(126+-0x52)];local V=b[o[(148645/0xd9)]][o[(-45+0x2fe)]];local c=(0x4f-75)/(((0x2e3e20/124)/188)-128)local m=((397+(-0x49+22))/173)-(60-0x3b)local v=b[o[(468-0x11f)]][o[(16560/0x48)]];local C=(128/((11611-0x16db)/45))+(81+-0x4f)local M=b[o[(-0x7a+703)]][o[(0x1cf8c/(0x175-241))]]local f=(280/0x8c)-(((0x19d-230)-0x82)/0x35)local p=(((0x148a-(0x153d-2763))/34)+-0x4a)local K=((0x14b8/((0x788-1018)/0x23))/102)local n=((-34+((0x2b74/27)-252))/0x3f)local P=(0x136/(0x148-((-107+0x191)+-0x79)))local a=(330/((65055-(0xfe9a-32628))/0xc5))local B=(100+(-24794/((0x39b4-7435)/29)))local x=(0x276/(24360/((1492224/0xc9)/64)))local e=(64-(11712/((44586-0x572a)/0x74)))local H=(-0x17+((8372-(0x10740/16))/160))local d=(0x7e-((49860/(412-0xe8))-154))local F=(0x1ef/(199+(((0x2721/159)+-0x67)+6)))local L=((0xb26b/((12604/0x2e)-0xc7))/203)local D=((((390-0xf1)+-0x46)+-125)+0x32)local _=((160-((-0x1f+(0x167+-29))-0xba))-0x2b)local u=((726-((48765+-0x7b)/121))/0x51)local t=((148+((-0x53+-52)+27))+-36)local i=(828/(((-0x3c+17)+0x246)-0x14c))local U=((0xb1-(-0x57+(10252/0x2c)))-0x1b)local G=o[(-112+(0x4129e/186))];local J=b[o[(16290/0x5a)]][o[(-0x31+527)]];local Y=b[(function(o)return type(o):sub(1,1)..'\101\116'end)('oblLpBhp')..'\109\101'..('\116\97'or'LKKPLLom')..o[(1266-0x2ad)]];local A=b[o[(1204-0x26f)]][o[(227487/0xf7)]];local S=(68/0x22)-(0x5c-(((-0x6c+20)+0x3cd0)/172))local N=(-0x7e+(((0x33+-116)+0xa)+183))-(0x2d+-43)local y=b[o[((72474-0x8db2)/200)]][o[(-0x64+460)]];local O=function(o,b)return o..b end local s=(0x27+-35)*(-0x21+(7585/(38745/0xbd)))local Q=b[o[(2451-0x4f7)]];local k=(-107+0x6d)*((441+(-0x68+19))-228)local j=(0x43f+-63)*(242/(-34+((0x179+-102)+-0x78)))local T=(0x7a-(0x1d88/(0x106-154)))local w=((0x55+(0x1d+-55))-57)*(130-0x80)local r=b[o[(2239-0x483)]]or b[o[(-47+(0x556-738))]][o[(2239-0x483)]];local h=((-121+(0x9cc2bf/247))/0xa2)local o=b[o[(0x23d1e/114)]];local g=(function(O)local k,l=1,0x10 local b={j={},v={}}local h=-f local o=l+m while true do b[O:sub(o,(function()o=k+o return o-m end)())]=(function()h=h+f return h end)()if h==(s-f)then h=""l=S break end end local h=#O while o<h+m do b.v[l]=O:sub(o,(function()o=k+o return o-m end)())l=l+f if l%c==S then l=N A(b.j,(y((b[b.v[N]]*s)+b[b.v[f]])))end end return M(b.j)end)("..:::MoonSec::..bBfFlLkKoOpPhHmMObHPobKoKbhhkbLoLblolbKooFkolhBoBbbobbMoKbFKfbmpHOhohbPoHpmOPhOooPLhfFfbMOOlkbLoLblolbFoKMkoBBffBbbobbllFHbOOhpkOokploBlMoKbpKOoOboopMPPOPKKfmfhBPlhlpFoFbfoLLlhFmMPmhHMPPkOKkLMOKHfhbPoPbmOHLoHlkMpPflkflHLOKLpLblolbFoFbfokhLobfbmbbMoMbhbfmofPomPLpPhPkpopbOofKOOkhpkfHbHllLmLblolbkBMbpPkFKHHKfobhMoMbmoBpBpmPpMpooPlHlbFkBlmphHMFKhKbkokbplOFKkLkbbFkfofbBoMMKMmpkbhPHlfOHOHbhohbBOkOhOpbOoObmMHmhBpbokFbbomPbMmFHoPhObKbLplfmLMHmhhHKfOokpkFMmfoMPHmohpbKfFHfHHoKmKbkokbhbmMPBFlOkKokffbBoBbbobbMoBhfofoHoHbhohbPoFbmombMHOpooobKoPBplkFfFHmOHFoBHHLOmPmBhBbbobblkfbbhmlKlHbhohbPoPbpoMlHopfoHobKoKbhFObKBLPFlhBFmFbfofbKplPbMhOohklPmmoHoHbhofbMHHlPFpBLfFFBmbMofKbkokbOOPMPBplOfolLfkpLLLBllbkMoMbmoOBlOOpooBmokHbpmpbOoObmFlFKFOMoKflfmLklolbFobHkPLHBhMkkFPpMPMbmombfFBlmhfkPmPbpopbpMlbHOmLhfpbFHkpLoLblooLOfoPBHfpFffobpbBHppOMombHoHbBLMMKOKLLOBHmHpPoBMoMFhMOMkPfkMfbblbFoFbfofbBoflloobMoMbmombHoBbBmbbkFPBpopbOobbFfobKoKbkokbLoLoooHmFmFbfofbOlhkOfkHolBOBfoPmBHbhohbbbHfKKHmPooKFFHKOoBpkokbLoLblohboBKbKBflBoBbbokBbPhoKFKmHmHbhohbBOBpohbFOOmOLHolKoKbkohBKhBPPbhmFoFbfofbBoBblPlbHhMLmombHofKMpHohFpFKmppOoObooHFPkookPLpFPBOMbHLpmOkfmfbBoBbFpMOplpmLBMpkkHbhohbPoPbpoHHHoofomobKoKboohklkokhOPlMmFbfofbBoBbboFLFolKMfmbHoHbbOmMpmkpBPhKOKLbBlhoLpKbkokbLoLbloomKoMkfofbBoBbbohblpFbpmmbHoHbhohbPomlmoffOmObooobhLHoomPlBhMplPlhFoFbfokhfoHooLHMPpKffOhoKKfFhpkhPmPbpopbhmkmkOHpmHFLKpkOLoLbloKLkhLmbOBhMPHPPkOLfkMkmombHoPfFlKKPmobPFkKpFObooobhPpmOFkBfBbbHPKmKLFMBpPmffBbbobbfHflBkHfhlpfOFkolmfHhkpbOoObooobFohkpoOPLmLblolbKMkpFMMKhmpBOkbbMoMbmombLoBKboHfPMPbpopbmkhlPFoLkllHFLhkLmLblolbPpOFKMofpMBlhfbkMoMbmooFLMPPoLMhFPMppmpbOoObPHPlpkkFLbFBmoLklolbFoopkPlOfbbLHmbFbFMbmombfPMkhFKOfBmopPFkBLhKopFpofKbkokbOmKmKfllffBlMBhlplObBObBMoMbmoFMKkHkhohbPoPFfLBofBfbbmfPKhKbkokbPppFobKLOblLfofbBoLPlbfpMpmkhOOPlLLmFmmkMmhoOhKMlOkhFBfMmhmfkpkbLoLblolbFooLkolHBmBbbobbkbbfplFFHHKhphHkPoPbpoHKHOPkOPkhlpFPbhmPoKPmObKPlMmKMlMkHkPLKpkhlpmfmmmbHoHbPflblkkLMoOhLBOMooobKoPBkMBOPoLlMBOmFPhoKkBlklfPMKoFhhMbmombHoHbhobKMoKhpopbOoOfOKobKoKbkPkbLoLbLpoOFoFbfokOBoBbbobbMoMbmombHoHbhohbPoPbpopBOoObooobKoofkokbLOLbLLlbFoFbFpfbBoBBbolpMoMbmobkHoHbhOhbhBPbpOpbmLObohOoKoKbkokOLoLBlolbLhFbfofbBOBbbobbMpMMmomBHoHLhohbPohfhmpbOOObpfobKoKbkoKpLoLBlolbFoFbfoFfFlBbbpbbloMbmombHpHMhohFPoPkpopbOoObHoobKhKbkOkbLoLblolbFoFLfofFBoBbboBfMoMbmmmbboHbhohbPoPbpopLOoOfooofKoKkkokbLhLbpFlbFOFbfHfbBhfobobbMolPmomBHoHbmkhbPHPbpPpbOoObOphHKoKkkoKoLoLbloLfFoFbfMfbFfBbbobbbpMbmomoHomOhohbPohfpopbpBObOfobKoKbKpkbLoLplokpFoFbfofbBoBbbMbbbfMbmpmbHoHbhohkPoPkpopKOoObooobKHKbkpkbLpLblmlbFoFlfoKPBoBBbobLMoMlbbmbHoHbfFhbPOPbpoPmOoOLoooFKoKbkoKfpLLblmlbLbFbfofbfpBbbobKMobpmombHomfhohbhbPbMKpbOoObOpobKoKOkoPBLoLbloLfFoFbFffbLoBbbobbMoMbmomKHoHphohfPoPbpopbOmObomobKMKbkokbLoLLlolfFoFffofkBoBbbhbbLFMbmOmbHHHbhhHoPoPbpoMPOoOBooobOkKbkHkbLPLblolbFpFMfofkBoBObobbMoMbMfmbHHHbhphbPpPbpmhmOoOLooHpKoKBkokbLoLlkblbFoFboffbBOBbboBmMoMLmomFHoHbhoHfbfPbpmpbHMObooobopKbkokKLokMlolbFolffofbfbBbfHbbMoMbmombHoHKhohKPoPopopkOoOboMobPFKbkOkbLOLblhLoFoFbfoLPBoBBboBfbhMbmMmbMfHbhohbhphhpopoOoPPooobKoofolkbkBLbLplbFoFbFpFhBoBpbobBMoMbmombmBHbhMhbhfPbpppbOopLoookKoKkkokKLoLkKklbFmFbkKfbBOBbbobbMhbomombHobMhohBPoPlhbpbOoObhoobKOKbKpKlLoLklooFFoFbfofbffBbbHbbMpMbmpmbHmbbhohlPobPpopBOoOLooolObKbkokbPFLblOlbFolmfofLBoBFbobbMobfFLmbHmHbbMhbPoPbPppbOoOKooOpKoKbkoKfLoLbLblbolFbfofbfpBbbobOMofFmombHomfhohbhfPbmbpbOoObooobKoKKkokpLoLflolbFoFbfmfbBmBbbMbbMoMbmomLHoHfhohfPoPkpopbOhObmFobKOKbkHkbLhkololbFooPfofBBoBbfkbbMHMbmPmbHoHbHpBLPoPkpomKOoObooOfKoKbkMkbKfLblolblpFbfofoBoFHbobbMobfmombmBHbmlhbPoPbPppbOoOpoohmKoKbkokbLoLblMlblfFbfpfbBoBbbobkMoMkmomKHoHbhohbPHPbpppbOpObooobKoKlkokLLoLblollFoFbfofbKFBbbObbMobPmomlHoHbhohbPoPbhfpbOhOboOobKoKbkmomLoLllopLFoFBfofbBoBlfbbbMoMblHmbHOHbMoMFPoPLpohkOoPoooOfOmKbkHkbkoLblolbFoLlfofbBoBBbobbMobfMhmbHHHbMKhbPoPbpmpmOoOkooooKoKBkokBLoLbkklbFoFbfpfbBoBbbobkMoMLmomfHoHBhohlHbPbpopbMoOboOobopolkokLLooblolbFolfKhfbBmBbBmbbMoMbbombHoHkhohkPoPkpoPfOoObObobOfKbkokbkpLblolOFolBfofbBoffbobbbfMbMlmbHoHbHphbPoPPpoHlOoObooobKoKbKbkbkFLblplbFoFbfofkBoBobobbMoMbmombHHHbhohbPpPbpopbOoOLoooBKoKfkoobkmLblmlbFHFbfPfbfpLhbobKMobpmombHomfhohbhbPbMppbOoObOpobKoKOkoohLoLbloLfFoFbFffbFhBbbobbMoMbmomKHoHphohfPohfpopbpbObpfobKoKbKpkbLoLOloKLFoFbfoFfBoBbBfbbbKMbmombmpHbhohPPomkpopbOoObooobobKbKFkbLpLblolOFoFkfofoBoBfbofblOMbmMmbHmHbbmhbhpPbpopOOoppooobKoofkokbkfLbLklbFoFbFpfbBoBPboFBMoMbmoMfHoHbHlhbmpPbpopbOoOboooOKoKhkokfLoLblolbFMFbFBfbBpBbfobbMoMomomKHobMhoHfPoPbPfpbPfObooobopKbkokPLooplolbFolfllfbflBblHbbMoMbMpfMHoHHhoHKPoPbpopbOoObOfoboLKbkpkbLoLbloloFoFpfoffBoFbbobbbBMbMbmbHMHbHphbPoPPpoPpOoObooOfKoKbKlkboBLblolblpFbfofHBoLlbobbMobfmombmkHbMMhbPoPbpopbOoOPooomKoKfkoKfLoLbLllbLfFbfofbfpfhbobHMoFomombHomfmlhbhkPbhkpbOoObOpOhKoKMkoklLoLblolblBFbFlfbfKBbbpbbMpMMmomHHoHBhohbPoPbMFpbpBObOLobKOKbookbLoLOloloFokhfoFfBoBbBFbbBfMbmombmpHbhohhPoPLpopbOopfoooboLKbPFkbLoLbLplbFoFmfoFlBoBbbobbMoMbMFmbmkHbhphbhpPbpophOoppooobKoofkokbkLLbLHlbFoFbFpfbBoBmbofbMoMbmoMfMlHbHKhbhBPbpopbOoOOooohKoKMkokfLoLfLKlblLFbfofbBoBbbolPMoMOmomHHoHBhombPoPbPBpbpbObhlobopKbkokPLokplolbFolffofbflBbfpbbMoMbMpmbHoHHhoHHPoPbpoPfOoObOkobPpKbkokbLoLblolPFoFmfoffBoffbobbblMbbfmbHoHbHphbPoPHpopoOoObooOfKoKbKkkbOFLblolblplhfofMBoBfbobbMoMbMBmbmlHbHKhbPpPbpppMOoOHoooKKoKbkokbpFLbLBlblLFbfOfbFoBbbobOMoMomomKHomfhohbhFPbhfpbOoObOpobKoKhkopBLoLbloLfFoFbFLfbLLBbbobbbpMbmommHofFhohbPoPbpopbpFObOkobKpKbKpkbLoLhloLpFoFbfoFfBoBbBLbbFkMbmombmpHbhohmPomOpopbOopfploboKKbOkkbLoLblolOFoFhfofMBoBfbobfbKMbMLmbHpHbhohbPoMPpopOOoOHoooBKoObkokbkBLbLblbKlFbFpfbBoBPboBpMoMbmoMfHoHbHlhbHOPbpopbppOboooHKoKPkokbLokflolblkFbFPfbBoBbbobbMoMPmommHoHfhoHfPoPbPlpbPfObooobopKbkokHLokPlolbFolffofbfkBbfMbbMoMbMpMhHoHMhomFPoPbpopbpBObOloboKKbkpkbLpLMlolHFoFlfofbBoBbFHbbbBMbMLmbHOHbhomlPoPbpopBOoObooopKoKbkokbLHLblolbhoFKfofbBolKlFBoBbHhhOppPhHmhohbPoHpHMPopOKoLplPBhbOPoPPOPKhLPflFhFbfofbkklbfhblMhMPmombHobFbkHpPopFkKkFFoFbMhmOLhKKkokbLoKpokkLlLBhMpmPfFBbbobbMpMMmombHoHbhohbPoPbMbpbOOObooobKoKbkokbLoLBlolBFoFBfoFfBoBbbObbMPMbmombMoHbhohBPoPBpopBOoPbooobKOKbkOkbLhLbkolbFoFBfofBBoBfbofbMoMbmOmbHOHbhHhbPoPbpopFOoObooobKoKbkokbLOLblPlbFOFbfofbBoBbbobBMoMbmomBHoHbhohbHkPbpopbKpObkoKMBOblofhHOplfLFlbFoFbLPLmFfBbMPPMPPObooLllBhfHBhbPoPbmBHlPfOmKoLPBhBoMHMmkBLblolbkKkoLFbFbbmhhbpkolMfmombHoHbhohbPoPbfppmOoObooPPPkOPkoLFBObhmpHkPbOFLlloFMbfBbbbMoMblofLMhHPhOKpLPlkohplOoObooHlpoOPkMklLhLblolboKKllkflFoBPbobbMofOBhMpmkhbpFLPLhFpBoBbmmObooobKoKbmopmOoOplmlbFoFbhffMBfmMkOOFKoMbmombHoHblobhMoFbpopbOoOboobbhPPbKpkLLoLbloOKKOLbFLBPFoBLbobbMofHBobFmhPhPphPPoPbpohpHhPOOOkhLLFPmoMlHlPkFOlHFoFbfokflObFPkKlfHMkpmLofkHkOKLBPhPkpopbOoKKPHFKhMloKKppLhLblolbokkblhflkfBhbobbMoBoflblmkOpOooKLoFpfbbPMbpfObobKoKbOBObKfLpFMBbMfHpomfhBoBbboFpfMBkMPppPkOkKFlPFkBmMLffplObooobPkpbooKFfLfmBBhfhKpooPkFmmBKbobbMofKfFMoMbPhpOopKfPOpopbOohOPhOpokkblFblMomMkollFoFbfoKmloFbBPKlMmMbmombkkBOMkBFBphboPpkOoObooHfphkkfhmbphkBLFlbFoFbKKFHHhOmFlmPlFBBmbokfMMmhohbPohfmfpbOoObOhobKoKbookbLoLblolbFolOfolbBoBbbobbMoMbmpmbMoHbhohBPoPbpoPkOoPbooobKpKbkOkbKbLbLplbFoFlfofKBoBbboBfMoMbmHmbMLHbhohbhpPbpopkOopFooobKoofkokbLMLbLLlbFoFbfofbBoBlbobKMoMfmombHoHbhphbPhPbpppbPoOboooFKoKfkoKoLokflolbFHFbfMfbBoBbBpbbMoMkmoMfHoHbhoHfPoPbpMpbPlObooobopKbkokoLoLPlolbFoFbfofbBHBbBbbbMpMbmombHoHFhohLPoPfpoPfOoObohoboKKbkokbkpLblolLFoFKfofbBoffbobbMmMbbkmbHoHbHphbPoPKpophOoObooOfKoKbKbkbkkLblolbFoFbfofLBoBobobfMoMbmombHhHbhphbPOPbPppbOoOlooOPKoKbkokbLoLblhlbFOFbfOfbFoBbboblMoMfmoMBHobbhohbPhPbPopbOOObpoobKoKlkokFLokKloKbFoFbfhfbfoBbbHbbBoMbmomlHoHFhoHLPombpopbOhObOoobKOKbookbLoLllolFFoFFfoLbBoBbbhbbboMbmHmbMoHbhohlPoPFpoPpOohbooobKhKbKokbLHLbkolbFoFlfofFBoBpboFbMoMbmhmbmoHbhHhbHoPbpoplOoOFooolKoofkokbLHLbLblbFoFblofbBoBLbobLMoMOmoMbHoHbhhhbhoPbpHpbPoObooolKoKFkokkLooblolbFhFbFofbBHBbbobbMoMbmomBHoHbhohbPoPbpopBpfObooobPlKkkokbLophoLkKFoBpbfkpBMBbbobbfMfPbbMohlPBOflfhOPbpopbHBhlpMoPkolffbBFmlhFOfOFkmLBfbbkmlFmBfbbMoMbBkBlbFhfPlpBoLLoFfBlbpObooobKoKbkokbOoBoLFlbFoFbLPLmFfBbMPPMPPObooLllBBpHfhbPoPbblHMPFOboFLlBfBbbfHKloLblolbFoFbfoBbLKbfbhbbMoMbFkBbMhHlblhpPoPbpohHHbPOohLplhFOBHmhHOkFlolbFoFbkLfbBOBbbobbMpMbMpmbHoHfhohOPoPbpohbOoObopobKpKbkhkbkpLblollFoFffofbBoBbbobbMpMbmhmbHpHbmohbPoPfpopfOoOkooObKoKbkOkbkbLblplbloFbfofBBoBLbobbMobfmombHpHbHBhbPoPbhopbOoOfooofKoKlkoKfLoLblhlbFPFbfofbBoBbbobfMoMlmomfHoMbhohbPpPbpppbOMObpoobKoKfkokfLoLploLfFoFbfhfbBOBbbobbMoMbmomLHoHBhohbPoPbpopbOhOboHobKoKbkokbLoLflolbFoFBfofbBoBbbobbMOMbmombHoHbhohbPOPhpopbOopBopobKoKbhKpKBfLKlolbFoKpkklLfLMhHphPOkMomombHoFbbHmlhFPBkflFfmhPOfobKoKbPOhHPKoHObomoFkKLflLhlBkbobbMomfKobHBkmpMhplhbPbpopbhFhoPfobkBlPflbFPmLHlolbFokOLhlLBPMhmOpppPKhkKlKBhMPFhhlPoPbpommhoPlohBmofKbkokbokolKFFfflBBMLhopfolhbbbMoMbmombHomhboLPPOOlPbpbOoObPKPlObKFlfFofOMlLOlbFoFbFpklBoBBbobBMoMbmoMbHoHbhOhbhlPbpopbppOboooBKoKBkokbLooblolbFOFbfmfbfFBbBpbbMoMBmomoHoHbhombPoPbpOpbOOObOBobopKbkokFLoLFlolbFolffofbBhBbbhbbMoMbMpmbHoHLhohLPoPbpoPfOoObomobofKbkokbLoLblolFFoFkfoffBoBbbobbMOMbmPmbHpHbmohbPoPBpopBOoOKoopbKoKbkOkbLOLblplbFpFMfofFBoBbbobbMoMbBHmbHOHbhPhbPOPbpohlOoOboooBKoKbkokBLoLblolblfFbfofbMhBPbobbMofFfkMpHohFoKoFLoLbBhbOLfOoooobKoOPpbopLoFOfFMhHPhbfMfbBoBbFMFPBbboHlhBpfOohhhbPoPbMkHbPhOlbpoLKoKbkoPKopkoLFFFphFlfofbBolLFoflMhPomhmbHoHbBHMlmKhFMBpfOoObooHMPMHkKfkbLoLbKkKlkFBMBPMbmoPlpBofKpMpmombHoMmMhmPppOhoOkHlbBpMhOmKoKbkoKfkhLblolblbFbfofbFofkbobbMoMbmomfHoHkMKhbPoPbpHpbOOOboOobKhookokbLoLLlolBFoFllbfbBoBbfLbbMOMbMpMlHoHbhohKPoPbpoPfHPOboOobKhKbkokbKoLblolBFoFBfofpBoffbobbMPMbmPmbHoHbhohbPoPBpopFOoOfoopbKoKbkOkbLOLbLBlbFoFbfofBBoBfbobfMoMlmombHoHbmFhbPOPbhoPkOoOLooolKoKkkoKfOBLblmlbFhFbfofbFoBbbobkMoMkmompHomfhohbhbPbpPpbOoObooobKoKkkokoLoLflokbFoFbfmfbBmBbbObbBoMbmomkHoHkhohkPoPkpopbOHObpfobKOKbkmkbLhkololbFolpfofBBoffBhbbMHMbmHmbHoHbhmhmPoPkpopbOoOBoooBKoKbokkbLoLblhlbFoFbfofkBoBLbobfMoMBmombmLHbhPhbPoPbpopbOmhBooobKoKHkokBLoLflollLbFbfofbfLBbbObbMoBlmombHoHBhohbPoPBpopbOoObOhobKoKbLpkoLoLbloKlkoLPfhBOMbhoPFMfMhMbmombBfboMOhlomPppopbOoPpPopLLpkklFfFbbHPPhlllfFbfofblBLBfobfmppfpmoPkmLBobhbPoPbpopbBomkhohpoBKbkokbofoKkbLBfbbfMFhlPBffBbbbMoMblofLMhHPhOKpLPlkMbpbOoObooobPohFpofoLmLblolbmOpFoPHFHbfMMokkLmLklmlkFmPkbKPfhlPbpopbHFHBpboHKflMfbBBmlhHpfOobbFkfofbBoFmbkBLKmMhPkBhmbHbhohbmKmlhbpFKfkoLOflboKKkokbLooHKhLplPfkbOppoPBLbobbMoFBMOohfhHfMFhbobPFpopbOomLPhpmLhobkokbLoKMohklFofLbkmbPPoOokkklPbKMomOhPfKhhhbPoPbMLPKkhBkFFofKoKbkoPMOMKPlolbFoFbkofbBoBbbobbMoMbbombHoHbhohbPoPkpohbOoObooobKoKbKpkbkpLblolBFoFmfofbBoFbbobbMOMbmOmbmOHbHphbPoPfpoPlOoOboopbKoKbkpkbLpLbLLlblpFbfofFBoflbobbMoBbmombHPHbhPhbhLPbPppbOoOlooOlKoKbkoobLoLblhlbFhFbFLfbBoBbbobBMoMlmomfHombhohbPoPbpppbOOObooobKoKbkokbLoLblokbFoFbfofbBoBbbmbbBoMbmombHoHbhoHfPombpopbOoObOFobofKbkokbLoLblolbFoFbfolbBoBbbobbMoMbmmmbMoHbhohbPoPbpoPfOopfooobKOKbkhkbLoLbkolbFoFBfofBBofBboBfMoMbmpmbHMHbhohbhpPbpopFOoOMooobKoofkokbLhLbLBlbFoFbFpfbBoBLbobLMoMbmombHoHbhphbPHPbpppbOoOboooBKoKfkokfLokblolbFoFbfhfbBOBbbobbMoMbmombHoHbhombPoPbpopbOoObomobOoKbkokbLoLbloLfFolffofbBOBbbMbbMoMbMpmbHoHfhoHFPoPbpoPfOoOboPobolKbkokbkpLblollFoFofofbBoBbbobbMOMbmhmbHpHbHohbPoPbpopBOoOBooobKoKbkokbLoLblolbLoFbfofbBoBbbobkMoBbmombHoHbhohbhpPbHopbOoOboooFKoobkokbLoLblolbFOFbfofbBoBbbobbMpMfmombHoOkhohbPoPbpopbOoObPkoLKoKbkoPKopkoLFFFLLFbfofbfpfhbobfMoMBmombHomfmlhbPPPbpOpbOoObOpOlKoKlkokfLoLblolklkFbfHfbBoBbbObbMhMbmoMmHoHbhohfPoPbpopbPkObooobKoKbkokbLokmlolbFoFFfofbBoBbfkbbMoMbmOmbHoHbhohkPoPlpopfOoOBoookoOKbkokbKBLblOlbFOFbfhFoBoBbboBOMoMBmomkmOHbhohbHBPbpOpbOOObohOoKoKbkoKOLoLBlolklOFbfOfbFBBbbObbMoMbmhMoHoHbhoHOPoPBpopbhlObohobKpKbkPkbLoKhlolLFoFFfoffBoBkfKbbMhMbMhmbHOHbhHhbPhhopopbOoploooBKoKlobkbLoLbkBlbFOFbfolhBoBlbobfMoMFmombblHbhHhbPPPbpppbOmpBooolKooOkokBLoLLlollLbFbfofbFBBbbObbMhbomombHomphohBPoPbhFpbOhObooobKoKbkoKpLoLllolBFoFbfofbFpBbbhbbMpMbmombHoMlhohbPoPBpopbOoOBooobKoKbkokbLoLblMlbFoFbfoLhBoBbbobBMoMbmombHoHbhohbPoPbpopbOoObooobKoKbkokbLoLblolbFoFbfPfbBoBbbobbMoMbmombHoHbhohbPoPbpopbOpObooobKoKbkokbLoLBlolbFoFbfofbBoBbfKbbMoMblmmoHoHbhofbMHHlPFpBLfFFBmHkKoKbkokbLoLbFoKMOmFPfofbBolFlkBpMomFpKpFKoKbFhfOKMPkpopbOoHfpKlomhopfPMbkbLblolbkbkHlffKbmMBhlpFOkMlmombHoMMMhHoPPMOpMpbOoObhphbofkBfmMBPoBklolbFoFbfofbOBLbfkbbMoMbmombLoBLbokhhBPbpopbhfhKpbOBkblfFFblMBBoLmlbFoFbLLLoFHBFHLHohBpfoFFfFKBoMPHFpkOKKoLfFKMobfPbMpKpkokbLoKpKoklFhfOMohlhkOPKhPpbHMbmombbfbbmhhlPBoblhlofHMOmmhmphkFkoLfFFbbmHhfplHhFHfbBoBbFfFbBhMlmBPbKhKbkKfOBmMmHhOFOoofkFFbBHMfHlPokfLblolbkkklLFBfblMBHLpoofklokmpHoHbhompmoHlphOOkoFPlbBKmhOmKLkbLoLbKfolkBlBBlMHmFOfObKhLllBBbmMHoFlhohbPoPbpopbHKHbmbokKoKbkookmbblkKObKlBlfmfbBoBbOlhFbOllfkbPKkHlhohbPoMmHohlOhKFObobKoKbpMPLokLFFOBFmkPpFpfkBoBbboLOfhBlMkHHphLfhhhbPoPbbkHbPopFKoobKoKbkokbOopLooOkFoFbfofbBoBbmoFMlfMOmombHofmbkmOhfppoKLoFpBhFlokKoKbkofPFHMmMfHlFpbkFLfbBoBbFfFbBhMlmBPbofolLBFOBlMfmFOfOMObooobpMpPobKollFBBfKMFoFbfoFfLpBbbobbBlMbmombMoHbhohbPoPbpoPBOoPbooobKoKbkokbKbLblolbFoFbfoffBoBBboBfMoMbmombMBHbhohbhpPbpopBOoOfooobKoKbkokbLoLblplbFOFbFpfbBoBbboBhMoMbmobbHoHbhohbPoPbPOpbppOboooBKookkokbLoKblolbFOFbfOfbfKBbBpbbMoMFmoMMHoHbhohbPoPbpOpbOPObopobOoKbkokBLoLBlolFFoLbfofbBOBbbObbbfMbbombHoHBhohBPoPPpoPfOoOboPobKOKbkokbkpLblollFolKfofbBoffbobbMHMbbLmbHoHbHphbPoPkpoPFOoObooobKoKbkPkbLmLblplbFoFbfofBBoBFbobfMobbmombHoHbmkhbPOPbPppbOoObooOhKoKbkoobLoLblolbFoFbFOfbfpBbbobBMoMBmombHomfhohbPpPbphpbOoObOpobKoKFkoKLLoLbloLfFoFbfhfbFfBbbobbMoMbmomBHoHlhohfPohbpopbOoObOoobKOKbKpkbLoLbloLkFoFbfolbBoBbbobbMoMbMKmbmpHbhohfPohMpopbOoObooobKoKbkpkbLpLbkolbFoFbfofbBoBFboFbMoMbmombmLHbmFhbhpPbpopbOopkooobKoObkokbLoLblolblKFbFpfbBoBfboBMMoMbmombHoHbhohbPpPbpppbPoObooobKoKbkokFLooblolbFoFbFkfbfbBbBpbbMoMbmoMkHoHbhombPoPbpopbOoObOKobopKbkokfLokMlolbFoFbfofbBoBbbpbbMpMbbombHoHbhohbPoPFpoPfOoOboOobKOKbkokbkpLblolfFoFKfofbBoffbobbMPMbMhmbHoHbHphbPoPlpopOOoObooobKoKbkOkbLhLblplbloFbfofbBoBhbobBMobfmombHoHbHmhbPoPbhopbOoObooobKoKMkoKfLoLblplbLKFbfofbBoBbbobbMoMfmomfHoMbhohbPoPbpopbOPObpoobKoKbkokbLoLplokbFoFbfofbBoBbbmbbfoMbmombHoHLhoHfPoPbpopbOoOboOobKoKbkokbLoLblPloFoFbfoHoBoBbbobbMoMbHoBMOfHlhohbPoMpHMPopOLoomobKoKbhfpFoBLoFHBkPoFbfofbBoBbboKbFoKfmPmbHoHbffblHBlHpopbOoObkholKoKbkopOpbKPlhmhllFbfofbLfLffFmKmbhFoLKokmlhffbLHOPbpopbppploooFKoKokokbLoLbLHlbFPFbfPfbBOBbbmfmMoMFmomKHoHBhohbPoPlhbpbOoOboMobKOKbKpKlLoLFloloFoFbfofbfHBbbPbbMPMbmOmbHoMfhohFPoPfpopbOopfplobKPKbkOkbLoLbLpoLFoFlfofkBoBbboBfMoMbmHmbHOHbhohbPoPbpopkOoObooobKoofkokbLMLblOlbFoFbfhfbBoBLboBHMoMBmombMkHbHBhbPhPbpopbppHKooopKoKFkokbLoKblolblfFbFffbBpBbfobbMoMPmombHoHLhohbPoPbPLpbpbObooobKoKbkokmLoLololbFoFbfofbfFBbBkbbMpMbbombHoHPhohPPoPKpopbOoObOFobKpKbkpkbLoLblolPFoFPfofFBoFbbobbbFMbMFmbHhHbhohbPoPppopfOoOfooobKoKbkhkbkBLbLflbFoFbfofOBoBFbobfMoBbmombHPHbHBhbPhPbphPfOoOLoooHKoKBkoKfkhLblHlblbFbfofbBoFobobLMoMBmomlHoHbmphbPhPbpppbOoObooplKoKbkokBLoLblolbFoFbfofBBOBbbobbLmMLmombHofKMpHohFpFPbpbOoObooOpKoKBkokbLoLbloLflhFbfpfbBOBbbobbMmMmmomFHoHbhohBPoPfpopbPkObooobKOKbkokbLokmlolbFoFbfofbBoBbbmbbMpMbmpmbHOHbhomfPoPBpopfOoObooobOhKbkokbLOLblolbFOFbfofbBoBlbobbMoMlMlmbHoHbBkMlmFPfOmKHkflFBbMHmFhfkhkpLoLbloObKpLFfpBFMkHpPhOOkhPoMlmbHoHbBobfhmPPomKfLPFmffblmBPlplkLLoLblooPkhlOFhbmfoBbbobbbpblmombHoHfhohbPoPkHKpbOoObOlobKOKbkOkbLhkololbFoFhfofBBoffBhbbMoMbmPmbHoHbhmmMPoPbpophOoOBoooBKoKlobkbLoLbLllbFOFbFpFlBoBbbobBMoMbmomkbkHbhohbhfPbpOpbOoObohOoKoKbkokpLoLBlollLbFbfofbflBbbObbbpblmombHoHlhohbPoHbPmpbOoObooobKOKbkoKKLoLBlolBFoFbfofbffBbbobbMpMbmpmbHoMPhohbPoPbpopbOoObphobKoKbkOkbLoLblolbFoFbfofLBoBbboMfbfMbmombBmMmmHhbpholkflbfPbPFloMKoKbkopmohKPLOfoBmMlhhPPooKPlofOBFmhPmmPHoHbhoBLmhHmppopKFLkFpBhMOhhffkmLoLbloOlkoLffhbkMmHOPbOPkhlofOBFmhOohhhbPoPbMkHbPhOlOLobKoKbKppkLoLblolfFoFbfoFfBoBbbObbMHMbmombHoHbhohbPoPfpopfOopfooobKOKbkhkbLoLblolbFoFffofbBoBbbobbMoMbmOmbHpHbhOhbHoPbpopBOoOboooBKoofkokbLpLblPlbFoFbfmfmBoBFbobbMoMBmomBHoHbmkhbPoPbpOpbOoObooopKoKfkokfLoLfloLbkBFbfofbBOBbbpbbMoBlmombHoHBhohbPoPBpopbOoOBOFobKoKbOkkkLoLbloLmPmhhhlkHmFhpbmbbMoMbllBHMMHbPfOpMlPopopbOoMbhHploFKBffbFmmoplolbFoFbfopbkHLbKhboMoMbmoFPBkMpHPPOObKLlmHPpPObooobhmPLopKflpffHMhPpPoKLffmMLmBhkpFkhLFfHpoHmHbhohbmolpHLloflbPmhobKoKbkokbLooMooOolOFbfofbkkllFFbHmbhhplofkblPfPbhmlHFpKomkFHOOfobKoKbpHKfBHPflfMkpLlPHhoPpoBLbobbMolPBoMOmFPhmOhbPoPbPpmBOoOfoooOKoKbkokbLoLblplbFOFbfpfbBoBbbobFMoMbmombHoHbhohbPhPbpopbOoObooobKoKFkokbLoLBloLflhFbfhfbBPBbbobbbpfmmomLHoHphohbPohfpopbOmOboMobKoKbKpkbLoLKlollFoFbfofbBoBbbhbbMMMbmpmbHmHbhohfPohopopBOoOlooolObKbkokbKbLblOlblpllfoflBoBLbobbMoMbfFmbHHHbhohbPoPbpopbOoOlooofKoKfkoKfLoLblHlbFPFbfofbfpBbbobkMoMkmombHomfhohbPMPbpOpbOoObOpobKoKokokoLoLblolbFoFbfHfbfbBbbpbbMmMbmomlHomKhohBPoPLpoplPbOboooboMKbkOkbLhkololbFolofofBBoBbfhbbMoMbmOmbHoHbhoHKPoPlpopbOoObooobPKKbkHkbLoLblolblpFbfofkBoBPbobbMoBbmombHmHbhmhbPpPbpopbOoOKoooFKoKbkokbLoLblmlbFMFbfofbBoBbboblMoMbmombHoHbhohbPhPbpopbOoObooobKoKbkokBLoLblolbFoFbfofbBOBbbobbFlMLmombHofKbOmbhLpPphpbOoObOpOlKoKbkokBLoLblolblMFbfOfbBoBbbobbMoMkmombHoHfhohBPoPbhhpbOoOboOobKoKbkokbLoLblolbFoFbfofBBoBbbobbBhMbmombHOHbhohbPoPbpopb");local M=(0x600/192)local l=112 local b=f;local o={}o={[(0xb2/(-71+0xf9))]=function()local O,p,f,o=v(g,b,b+C);b=b+w;l=(l+(M*w))%h;return(((o+l-(M)+k*(w*c))%k)*((c*j)^c))+(((f+l-(M*c)+k*(c^C))%h)*(k*h))+(((p+l-(M*C)+j)%h)*k)+((O+l-(M*w)+j)%h);end,[(-0x6d+111)]=function(o,o,o)local o=v(g,b,b);b=b+m;l=(l+(M))%h;return((o+l-(M)+j)%k);end,[(132-(195+-0x42))]=function()local o,f=v(g,b,b+c);l=(l+(M*c))%h;b=b+c;return(((f+l-(M)+k*(c*w))%k)*h)+((o+l-(M*c)+h*(c^C))%k);end,[(48-0x2c)]=function(l,o,b)if b then local o=(l/c^(o-f))%c^((b-m)-(o-f)+m);return o-o%f;else local o=c^(o-m);return(l%(o+o)>=o)and f or N;end;end,[(0x118/56)]=function()local b=o[(204/0xcc)]();local l=o[(8/0x8)]();local p=f;local O=(o[(27-0x17)](l,m,s+w)*(c^(s*c)))+b;local b=o[((0x7d4-1028)/244)](l,21,31);local o=((-f)^o[(0x38+-52)](l,32));if(b==N)then if(O==S)then return o*N;else b=m;p=S;end;elseif(b==(k*(c^C))-m)then return(O==N)and(o*(m/S))or(o*(N/S));end;return V(o,b-((h*(w))-f))*(p+(O/(c^T)));end,[(0x32a/135)]=function(O,p,p)local p;if(not O)then O=o[(160/0xa0)]();if(O==N)then return'';end;end;p=J(g,b,b+O-f);b=b+O;local o=''for b=m,#p do o=G(o,y((v(J(p,b,b))+l)%h))l=(l+M)%k end return o;end}local function J(...)return{...},Q('#',...)end local function g()local B={};local P={};local b={};local O={B,P,nil,b};local l={}local M=((-0x55+248)-0x8b)local b={[(69+-0x44)]=(function(b)return not(#b==o[(-27+0x1d)]())end),[(-24+0x1a)]=(function(b)return o[(108+-0x67)]()end),[(0x33-48)]=(function(b)return o[(-0x3b+65)]()end),[(118+-0x72)]=(function(b)local l=o[(0x5ac/242)]()local b=''local o=1 for f=1,#l do o=(o+M)%h b=G(b,y((v(l:sub(f,f))+o)%k))end return b end)};O[3]=o[(470/0xeb)]();local h=o[(32/0x20)]()for f=1,h do local o=o[(0x28-38)]();local h;local o=b[o%(0x34+-38)];l[f]=o and o({});end;for O=1,o[(0x2f-46)]()do local b=o[(51-0x31)]();if(o[(276/0x45)](b,f,m)==S)then local k=o[(0x24c/147)](b,c,C);local h=o[(21+-0x11)](b,w,c+w);local b={o[(-0x26+41)](),o[(0x66-99)](),nil,nil};local P={[(0x0/56)]=function()b[F]=o[(98-0x5f)]();b[U]=o[((0x106-139)+-120)]();end,[(-0x4f+80)]=function()b[L]=o[(0x75-116)]();end,[(-0x50+(0xe3-145))]=function()b[e]=o[(37+-0x24)]()-(c^s)end,[(573/0xbf)]=function()b[F]=o[((0x2490/144)-0x40)]()-(c^s)b[i]=o[(732/0xf4)]();end};P[k]();if(o[(0x5f-91)](h,m,f)==m)then b[n]=l[b[p]]end if(o[(110-0x6a)](h,c,c)==f)then b[F]=l[b[e]]end if(o[(0x33c/207)](h,C,C)==m)then b[t]=l[b[U]]end B[O]=b;end end;for o=m,o[(128+-0x7f)]()do P[o-m]=g();end;return O;end;local function v(o,N,M)local b=o[c];local k=o[C];local h=o[f];return(function(...)local j={...};local C=J local l={};local s={};local g=Q('#',...)-m;local y=b;local b=f;local S={};local k=k;local o=f o*=-1 local w=o;local h=h;for o=0,g do if(o>=k)then s[o-k]=j[o+m];else l[o]=j[o+f];end;end;local g=g-k+f local o;local k;while true do o=h[b];k=o[((-22+0x7b)+-100)];O=(736326)while(0x1555/127)>=k do O-= O O=(9499443)while k<=(2163/0x67)do O-= O O=(1563740)while(73-0x3f)>=k do O-= O O=(2021030)while(0x32-46)>=k do O-= O O=(473200)while(69-0x44)>=k do O-= O O=(1175776)while((67-0x43)/0xb)<k do O-= O local o={l,o};o[f][o[c][a]]=o[c][_]+o[c][e];break end while(O)/((0x16d9-2953))==406 do local o={l,o};o[m][o[c][K]]=o[f][o[c][_]]+o[m][o[c][d]];break end;break;end while 2275==(O)/(((0xf399/117)-325))do O=(7630092)while k<=(0x17-21)do O-= O local b=o[K]local O={l[b](l[b+1])};local h=0;for o=b,o[D]do h=h+f;l[o]=O[h];end break;end while 2279==(O)/((6790-0xd72))do O=(4536960)while k>(-0x3b+62)do O-= O local o=o[n]local h,b=C(l[o](l[o+m]))w=b+o-f local b=0;for o=o,w do b=b+f;l[o]=h[b];end;break end while(O)/((0xaa0/1))==1668 do local b=o[B]local h,o=C(l[b](r(l,b+1,o[L])))w=o+b-1 local o=0;for b=b,w do o=o+f;l[b]=h[o];end;break end;break;end break;end break;end while(O)/((0x39a8a/(534-0x134)))==1934 do O=(699643)while(-47+0x36)>=k do O-= O O=(870064)while(-77+(0x18fc/78))>=k do O-= O local b=o[p]l[b](r(l,b+m,o[H]))break;end while 712==(O)/((0x11016/57))do O=(9312693)while k>((28-0x2d)+0x17)do O-= O local o=o[K]l[o](r(l,o+m,w))break end while(O)/((0x1f710/48))==3471 do local o=o[P]l[o](l[o+m])break end;break;end break;end while(O)/((0x1c0d6/146))==889 do O=(2541987)while k<=(0x7a-114)do O-= O l[o[p]]();break;end while 1799==(O)/(((607131/0xcf)-1520))do O=(2301728)while k>(41-0x20)do O-= O local o=o[B]l[o]=l[o](l[o+m])break end while 1144==(O)/((18108/0x9))do local b=o[P]l[b]=l[b](r(l,b+f,o[x]))break end;break;end break;end break;end break;end while(O)/((-34+0x795))==820 do O=(339406)while(0x82-115)>=k do O-= O O=(2162048)while(0x600/128)>=k do O-= O O=(790525)while((2067/0x35)-0x1c)<k do O-= O local o=o[p]l[o]=l[o]()break end while(O)/((5192-0xa39))==307 do local o=o[B]l[o]=l[o](r(l,o+f,w))break end;break;end while 4064==(O)/((1175-0x283))do O=(5202288)while(79-0x42)>=k do O-= O local O=o[n];local f={};for o=1,#S do local o=S[o];for b=0,#o do local b=o[b];local h=b[1];local o=b[2];if h==l and o>=O then f[o]=h[o];b[1]=f;end;end;end;break;end while(O)/((0x20b40/92))==3573 do O=(2390856)while k>(0x41+-51)do O-= O l[o[P]]=v(y[o[L]],nil,M);break end while(O)/((0xc5a5a/214))==632 do local p=y[o[x]];local k;local f={};k=Y({},{__index=function(b,o)local o=f[o];return o[1][o[2]];end,__newindex=function(l,o,b)local o=f[o]o[1][o[2]]=b;end;});for O=1,o[i]do b=b+m;local o=h[b];if o[(54-0x35)]==30 then f[O-1]={l,o[e]};else f[O-1]={N,o[L]};end;S[#S+1]=f;end;l[o[K]]=v(p,k,M);break end;break;end break;end break;end while 1522==(O)/((0x22f-336))do O=(5356750)while(0x54+-66)>=k do O-= O O=(7906752)while k<=(-40+0x38)do O-= O local f=o[H];local b=l[f]for o=f+1,o[i]do b=b..l[o];end;l[o[p]]=b;break;end while(O)/((4754-0x977))==3392 do O=(3292756)while k>(4267/0xfb)do O-= O local f=o[n];local O=l[f+2];local h=l[f]+O;l[f]=h;if(O>0)then if(h<=l[f+1])then b=o[F];l[f+3]=h;end elseif(h>=l[f+1])then b=o[x];l[f+3]=h;end break end while(O)/(((0x384e8/227)+-84))==3533 do if(l[o[a]]==l[o[U]])then b=b+m;else b=o[H];end;break end;break;end break;end while 3061==(O)/((0xe25-1871))do O=(9861894)while k<=(71-0x34)do O-= O local f=o[K];local h=l[f]local O=l[f+2];if(O>0)then if(h>l[f+1])then b=o[H];else l[f+3]=h;end elseif(h<l[f+1])then b=o[x];else l[f+3]=h;end break;end while(O)/((5757-0xb70))==3486 do O=(5700920)while(0x6f-91)<k do O-= O l[o[K]]=l[o[H]][l[o[i]]];break end while 3590==(O)/((3299-0x6af))do l[o[n]]=M[o[d]];break end;break;end break;end break;end break;end break;end while 2391==(O)/((0x1f4c-4039))do O=(2902613)while k<=(-0x30+80)do O-= O O=(257856)while k<=(-29+0x37)do O-= O O=(7382580)while(0x142/14)>=k do O-= O O=(411600)while k>(161-0x8b)do O-= O l[o[n]]=N[o[d]];break end while 735==(O)/((626+-0x42))do l[o[a]]=l[o[e]][o[i]];break end;break;end while(O)/((0x1100-2222))==3466 do O=(13025269)while(2064/0x56)>=k do O-= O b=o[d];break;end while 4087==(O)/((0x1931-3262))do O=(2429191)while k>(176-(383-0xe8))do O-= O l[o[B]]=(o[F]~=0);break end while 713==(O)/((0x1abc-3437))do l[o[a]]=#l[o[L]];break end;break;end break;end break;end while 272==(O)/((1989-0x411))do O=(8857116)while(0x135f/171)>=k do O-= O O=(11487944)while k<=(177-0x96)do O-= O l[o[p]]=(o[d]~=0);b=b+m;break;end while(O)/((0x17f5-(0x188a-3165)))==3809 do O=(9951326)while k>(0x10f4/155)do O-= O l[o[p]]=l[o[H]]%o[t];break end while 3401==(O)/((0x1742-3028))do l[o[P]]=o[x];break end;break;end break;end while 3378==(O)/((0xa62+-36))do O=(1187054)while(82+-0x34)>=k do O-= O l[o[K]]=l[o[e]];break;end while 683==(O)/((0x2eacc/110))do O=(8282737)while k>(0x7a+-91)do O-= O if(l[o[p]]~=o[D])then b=b+m;else b=o[d];end;break end while 3013==(O)/((0xb39+-124))do if(l[o[P]]~=l[o[_]])then b=b+m;else b=o[e];end;break end;break;end break;end break;end break;end while(O)/((0xcc1-1664))==1813 do O=(1038956)while k<=(173-0x88)do O-= O O=(1291082)while(0x2024/242)>=k do O-= O O=(3919752)while k>(-48+(0xe3d/45))do O-= O do return l[o[K]]end break end while 1656==(O)/((4852-(5092-0xa2f)))do l[o[n]]={};break end;break;end while(O)/((0x16e4-2939))==442 do O=(3815900)while k<=(0xc2-159)do O-= O local o=o[a];do return r(l,o,w)end;break;end while 3469==(O)/((0x5a3c/21))do O=(2828970)while(61+-0x19)<k do O-= O local f=o[p];local b=l[o[e]];l[f+1]=b;l[f]=b[o[D]];break end while 1849==(O)/((168300/0x6e))do do return end;break end;break;end break;end break;end while(O)/((1026+(-0xb-33)))==1058 do O=(9844252)while(-39+0x4f)>=k do O-= O O=(1729756)while(0xb5-143)>=k do O-= O M[o[e]]=l[o[K]];break;end while(O)/((5306/(1673/0xef)))==2282 do O=(2455820)while(118-0x4f)<k do O-= O l[o[K]][l[o[d]]]=l[o[D]];break end while(O)/((-0x33+2381))==1054 do local o=o[n];local b=l[o];for o=o+1,w do A(b,l[o])end;break end;break;end break;end while(O)/((0xf95+-81))==2519 do O=(12744904)while k<=(-63+0x68)do O-= O l[o[K]][o[e]]=l[o[_]];break;end while 3764==(O)/((480812/0x8e))do O=(10020582)while k>(462/0xb)do O-= O N[o[e]]=l[o[P]];break end while(O)/((332046/0x81))==3893 do l[o[n]][o[d]]=o[D];break end;break;end break;end break;end break;end break;end break;end while 342==(O)/((0x1115-2220))do O=(299962)while(0xae-109)>=k do O-= O O=(15540360)while k<=(-89+0x8f)do O-= O O=(4626210)while k<=(76+-0x1c)do O-= O O=(9283425)while(0x15f9/125)>=k do O-= O O=(8168973)while k>(153+-0x6d)do O-= O local o=o[P];do return l[o](r(l,o+1,w))end;break end while(O)/((2239+-0x6e))==3837 do l[o[p]]=l[o[H]]-l[o[i]];break end;break;end while 3019==(O)/((202950/0x42))do O=(6107050)while k<=(112+-0x42)do O-= O if l[o[P]]then b=b+f;else b=o[d];end;break;end while(O)/((-31+0x6aa))==3646 do O=(1907100)while(0x90-97)<k do O-= O local f=l[o[t]];if not f then b=b+m;else l[o[a]]=f;b=o[F];end;break end while 1170==(O)/((-0x32+1680))do if not l[o[B]]then b=b+m;else b=o[e];end;break end;break;end break;end break;end while 1158==(O)/((171785/0x2b))do O=(3734164)while k<=(0x1e7b/153)do O-= O O=(2160811)while(165+-0x74)>=k do O-= O local h=o[K];local k=o[U];local O=h+2 local h={l[h](l[h+1],l[O])};for o=1,k do l[O+o]=h[o];end;local h=h[1]if h then l[O]=h b=o[e];else b=b+f;end;break;end while(O)/((0x1136e/110))==3371 do O=(8750750)while k>(0xd3-161)do O-= O local o={l,o};o[f][o[c][a]]=o[c][_]+o[c][d];break end while(O)/((0x1c62-3641))==2414 do local o=o[a];w=o+g-1;for b=o,w do local o=s[b-o];l[b]=o;end;break end;break;end break;end while(O)/((24318/0x9))==1382 do O=(1631256)while k<=(105+-0x35)do O-= O local b=o[P]local h,o=C(l[b](r(l,b+1,o[x])))w=o+b-1 local o=0;for b=b,w do o=o+f;l[b]=h[o];end;break;end while(O)/(((0x7d43d-256573)/64))==407 do O=(12165140)while k>(123-0x46)do O-= O local o={l,o};o[m][o[c][P]]=o[f][o[c][u]]+o[m][o[c][e]];break end while(O)/((7457-0xeb5))==3295 do local b=o[n]l[b](r(l,b+m,o[e]))break end;break;end break;end break;end break;end while 4026==(O)/((0x56b30/92))do O=(1242012)while k<=(10089/0xab)do O-= O O=(723858)while k<=(0x690/(0x1a5e/225))do O-= O O=(1290246)while k>(0xc2-(0x2fc8/88))do O-= O local h=o[P]local O={l[h](l[h+1])};local b=0;for o=h,o[D]do b=b+f;l[o]=O[b];end break end while(O)/((-34+0x189))==3594 do local o=o[a]local h,b=C(l[o](l[o+m]))w=b+o-f local b=0;for o=o,w do b=b+f;l[o]=h[b];end;break end;break;end while(O)/(((24170798/0xb2)/251))==1338 do O=(4644459)while k<=(0xd0-151)do O-= O local k;local O;l[o[a]]=M[o[H]];b=b+f;o=h[b];O=o[P];k=l[o[x]];l[O+1]=k;l[O]=k[o[u]];b=b+f;o=h[b];l[o[p]]=o[L];b=b+f;o=h[b];O=o[P]l[O]=l[O](r(l,O+f,o[F]))b=b+f;o=h[b];l[o[B]]=l[o[F]][o[u]];b=b+f;o=h[b];l[o[a]]=l[o[d]][o[i]];b=b+f;o=h[b];if(l[o[n]]~=l[o[u]])then b=b+m;else b=o[F];end;break;end while(O)/((0x9960c/252))==1863 do O=(11310156)while k>(-90+0x94)do O-= O local O;l[o[P]]=l[o[x]];b=b+f;o=h[b];O=o[n]l[O]=l[O](l[O+m])b=b+f;o=h[b];l[o[K]]=M[o[H]];b=b+f;o=h[b];l[o[a]]=o[F];b=b+f;o=h[b];l[o[p]]=o[x];b=b+f;o=h[b];l[o[K]]=o[d];b=b+f;o=h[b];O=o[B]l[O]=l[O](r(l,O+f,o[F]))b=b+f;o=h[b];if(l[o[p]]~=l[o[u]])then b=b+m;else b=o[d];end;break end while 3042==(O)/((0x1d61-3803))do local k;local O;l[o[B]]=M[o[e]];b=b+f;o=h[b];l[o[n]]=l[o[L]][o[D]];b=b+f;o=h[b];l[o[B]]=l[o[e]][o[_]];b=b+f;o=h[b];l[o[B]]=l[o[e]][o[t]];b=b+f;o=h[b];O=o[B];k=l[o[d]];l[O+1]=k;l[O]=k[o[U]];b=b+f;o=h[b];l[o[p]]=M[o[H]];b=b+f;o=h[b];l[o[p]]=o[F];b=b+f;o=h[b];l[o[p]]=o[x];b=b+f;o=h[b];l[o[K]]=o[e];b=b+f;o=h[b];O=o[a]l[O]=l[O](r(l,O+f,o[L]))b=b+f;o=h[b];O=o[K]l[O]=l[O](r(l,O+f,o[d]))b=b+f;o=h[b];O=o[K];k=l[o[H]];l[O+1]=k;l[O]=k[o[u]];b=b+f;o=h[b];l[o[n]]=M[o[F]];b=b+f;o=h[b];l[o[P]]=o[x];b=b+f;o=h[b];l[o[B]]=o[H];b=b+f;o=h[b];l[o[p]]=o[d];b=b+f;o=h[b];O=o[a]l[O]=l[O](r(l,O+f,o[L]))b=b+f;o=h[b];O=o[B]l[O]=l[O](r(l,O+f,o[x]))b=b+f;o=h[b];l[o[K]]=M[o[F]];b=b+f;o=h[b];l[o[p]]=M[o[e]];b=b+f;o=h[b];l[o[n]]=o[e];b=b+f;o=h[b];l[o[K]]=o[F];b=b+f;o=h[b];l[o[p]]=o[F];b=b+f;o=h[b];O=o[K]l[O]=l[O](r(l,O+f,o[x]))b=b+f;o=h[b];O=o[a]l[O](l[O+m])b=b+f;o=h[b];l[o[a]]=M[o[d]];b=b+f;o=h[b];l[o[P]]();b=b+f;o=h[b];l[o[p]]=l[o[d]][o[t]];b=b+f;o=h[b];l[o[n]][o[L]]=o[i];b=b+f;o=h[b];l[o[P]]=l[o[F]][o[U]];b=b+f;o=h[b];l[o[B]][o[e]]=o[U];b=b+f;o=h[b];l[o[p]]=l[o[H]][o[_]];b=b+f;o=h[b];l[o[P]][o[x]]=o[i];b=b+f;o=h[b];l[o[p]]=l[o[e]][o[_]];b=b+f;o=h[b];l[o[K]][o[F]]=o[U];b=b+f;o=h[b];l[o[P]]=l[o[d]][o[i]];b=b+f;o=h[b];l[o[p]][o[H]]=o[t];b=b+f;o=h[b];l[o[n]]=l[o[H]][o[t]];b=b+f;o=h[b];l[o[a]][o[L]]=o[_];b=b+f;o=h[b];l[o[B]]=l[o[F]][o[D]];b=b+f;o=h[b];l[o[n]]=M[o[L]];b=b+f;o=h[b];l[o[K]]=l[o[L]][o[D]];b=b+f;o=h[b];l[o[K]][o[d]]=l[o[t]];b=b+f;o=h[b];l[o[n]]=l[o[d]][o[_]];b=b+f;o=h[b];l[o[K]][o[H]]=o[t];b=b+f;o=h[b];do return end;break end;break;end break;end break;end while(O)/(((281268/0x4e)+-0x25))==348 do O=(5395358)while k<=(0x87+-73)do O-= O O=(7180375)while(-0x32+110)>=k do O-= O l[o[P]]=N[o[H]];b=b+f;o=h[b];l[o[p]]=#l[o[d]];b=b+f;o=h[b];N[o[d]]=l[o[K]];b=b+f;o=h[b];l[o[K]]=N[o[L]];b=b+f;o=h[b];l[o[P]]=#l[o[e]];b=b+f;o=h[b];N[o[F]]=l[o[a]];b=b+f;o=h[b];do return end;break;end while(O)/((0x1109-2236))==3379 do O=(1454130)while(0x89+-76)<k do O-= O local O;l[o[p]]=o[F];b=b+f;o=h[b];l[o[p]]=o[L];b=b+f;o=h[b];l[o[n]]=o[F];b=b+f;o=h[b];O=o[n]l[O]=l[O](r(l,O+f,o[L]))b=b+f;o=h[b];if(l[o[p]]==l[o[_]])then b=b+m;else b=o[L];end;break end while 906==(O)/((-70+0x68b))do local c;local t,_;local k;local O;l[o[p]]={};b=b+f;o=h[b];l[o[P]]=M[o[L]];b=b+f;o=h[b];O=o[K];k=l[o[F]];l[O+1]=k;l[O]=k[o[U]];b=b+f;o=h[b];l[o[B]]=o[d];b=b+f;o=h[b];O=o[P]l[O]=l[O](r(l,O+f,o[e]))b=b+f;o=h[b];l[o[n]]=l[o[L]][o[u]];b=b+f;o=h[b];l[o[p]][o[d]]=l[o[U]];b=b+f;o=h[b];l[o[B]][o[L]]=l[o[D]];b=b+f;o=h[b];l[o[a]]=M[o[L]];b=b+f;o=h[b];O=o[P];k=l[o[L]];l[O+1]=k;l[O]=k[o[i]];b=b+f;o=h[b];l[o[p]]=o[e];b=b+f;o=h[b];O=o[n]l[O]=l[O](r(l,O+f,o[d]))b=b+f;o=h[b];l[o[B]]=l[o[x]][o[U]];b=b+f;o=h[b];O=o[P];k=l[o[H]];l[O+1]=k;l[O]=k[o[i]];b=b+f;o=h[b];l[o[K]]=M[o[F]];b=b+f;o=h[b];l[o[P]]=l[o[d]];b=b+f;o=h[b];O=o[p]t,_=C(l[O](l[O+m]))w=_+O-f c=0;for o=O,w do c=c+f;l[o]=t[c];end;b=b+f;o=h[b];O=o[B]l[O](r(l,O+m,w))b=b+f;o=h[b];do return end;break end;break;end break;end while(O)/(((342375+-0x27)/192))==3026 do O=(87454)while(234-0xab)>=k do O-= O local k;local B,e;local O;l[o[p]]=l[o[H]];b=b+f;o=h[b];l[o[p]]=M[o[L]];b=b+f;o=h[b];l[o[K]]=l[o[L]][o[U]];b=b+f;o=h[b];l[o[P]]=l[o[H]];b=b+f;o=h[b];O=o[K]B,e=C(l[O](l[O+m]))w=e+O-f k=0;for o=O,w do k=k+f;l[o]=B[k];end;b=b+f;o=h[b];O=o[n];do return l[O](r(l,O+1,w))end;b=b+f;o=h[b];O=o[p];do return r(l,O,w)end;b=b+f;o=h[b];do return end;break;end while(O)/((-0x2b+189))==599 do O=(4663068)while k>(-0x7e+190)do O-= O local p;local k;local O;l[o[P]]=M[o[e]];b=b+f;o=h[b];O=o[n]l[O]=l[O]()b=b+f;o=h[b];l[o[B]]={};b=b+f;o=h[b];O=o[B];w=O+g-1;for o=O,w do k=s[o-O];l[o]=k;end;b=b+f;o=h[b];O=o[a];p=l[O];for o=O+1,w do A(p,l[o])end;break end while 3138==(O)/((0xc06-1592))do local O;l[o[B]]=N[o[d]];b=b+f;o=h[b];l[o[a]]=l[o[H]][o[U]];b=b+f;o=h[b];l[o[P]]=l[o[F]][o[t]];b=b+f;o=h[b];l[o[B]]=M[o[d]];b=b+f;o=h[b];l[o[p]]=l[o[L]][o[i]];b=b+f;o=h[b];l[o[K]]=M[o[L]];b=b+f;o=h[b];l[o[p]]=l[o[L]][o[u]];b=b+f;o=h[b];l[o[P]]=M[o[x]];b=b+f;o=h[b];l[o[K]]=l[o[x]][o[i]];b=b+f;o=h[b];l[o[p]]=M[o[H]];b=b+f;o=h[b];l[o[K]]=l[o[H]][o[D]];b=b+f;o=h[b];O=o[P]l[O]=l[O](r(l,O+f,o[e]))b=b+f;o=h[b];l[o[B]][o[F]]=l[o[t]];b=b+f;o=h[b];l[o[P]]=N[o[x]];b=b+f;o=h[b];l[o[a]]=l[o[H]][o[u]];b=b+f;o=h[b];l[o[n]]=l[o[L]][o[t]];b=b+f;o=h[b];l[o[p]][o[L]]=o[u];b=b+f;o=h[b];l[o[a]]=N[o[L]];b=b+f;o=h[b];l[o[B]]=l[o[e]][o[D]];b=b+f;o=h[b];l[o[n]]=l[o[H]][o[i]];b=b+f;o=h[b];l[o[p]]=M[o[d]];b=b+f;o=h[b];l[o[K]]=l[o[e]][o[_]];b=b+f;o=h[b];l[o[P]]=M[o[e]];b=b+f;o=h[b];l[o[n]]=o[H];b=b+f;o=h[b];l[o[a]]=o[x];b=b+f;o=h[b];l[o[n]]=o[e];b=b+f;o=h[b];O=o[a]l[O]=l[O](r(l,O+f,o[d]))b=b+f;o=h[b];O=o[B]l[O]=l[O](l[O+m])b=b+f;o=h[b];l[o[B]][o[L]]=l[o[t]];b=b+f;o=h[b];l[o[P]]=N[o[d]];b=b+f;o=h[b];l[o[K]]=l[o[L]][o[i]];b=b+f;o=h[b];l[o[p]]=l[o[F]][o[i]];b=b+f;o=h[b];l[o[n]]=M[o[d]];b=b+f;o=h[b];l[o[P]]=o[d];b=b+f;o=h[b];l[o[a]]=o[x];b=b+f;o=h[b];l[o[K]]=o[L];b=b+f;o=h[b];O=o[n]l[O]=l[O](r(l,O+f,o[H]))b=b+f;o=h[b];l[o[P]][o[L]]=l[o[D]];b=b+f;o=h[b];l[o[n]]=N[o[d]];b=b+f;o=h[b];l[o[B]]=l[o[H]][o[D]];b=b+f;o=h[b];l[o[B]]=l[o[d]][o[u]];b=b+f;o=h[b];l[o[B]][o[H]]=o[u];b=b+f;o=h[b];do return end;break end;break;end break;end break;end break;end break;end while 278==(O)/((0x8d3-(0x99c-1280)))do O=(3878350)while k<=(0x48bc/245)do O-= O O=(2727504)while k<=(0x4ec/18)do O-= O O=(564308)while k<=(0xb8-117)do O-= O O=(5280755)while(0x15ea/85)<k do O-= O local e;local P;local k;local O;l[o[B]]=M[o[F]];b=b+f;o=h[b];O=o[p];k=l[o[d]];l[O+1]=k;l[O]=k[o[_]];b=b+f;o=h[b];l[o[B]]=o[L];b=b+f;o=h[b];O=o[B]l[O]=l[O](r(l,O+f,o[x]))b=b+f;o=h[b];O=o[K];k=l[o[d]];l[O+1]=k;l[O]=k[o[t]];b=b+f;o=h[b];O=o[B]P={l[O](l[O+1])};e=0;for o=O,o[t]do e=e+f;l[o]=P[e];end b=b+f;o=h[b];b=o[x];break end while 2305==(O)/((-0x61+2388))do local k;local O;l[o[P]]=M[o[H]];b=b+f;o=h[b];l[o[P]]=l[o[F]][o[u]];b=b+f;o=h[b];O=o[n];k=l[o[e]];l[O+1]=k;l[O]=k[o[_]];b=b+f;o=h[b];O=o[a]l[O](l[O+m])b=b+f;o=h[b];l[o[n]]=M[o[H]];b=b+f;o=h[b];l[o[a]]=o[L];b=b+f;o=h[b];O=o[B]l[O](l[O+m])b=b+f;o=h[b];l[o[n]]=M[o[e]];b=b+f;o=h[b];l[o[P]]=l[o[L]][o[t]];b=b+f;o=h[b];l[o[P]]=M[o[L]];b=b+f;o=h[b];O=o[P];k=l[o[H]];l[O+1]=k;l[O]=k[o[_]];b=b+f;o=h[b];l[o[a]]=o[x];b=b+f;o=h[b];O=o[B]l[O]=l[O](r(l,O+f,o[d]))b=b+f;o=h[b];l[o[K]]=l[o[e]][o[_]];b=b+f;o=h[b];l[o[B]]=l[o[d]][o[U]];b=b+f;o=h[b];O=o[p];k=l[o[H]];l[O+1]=k;l[O]=k[o[D]];b=b+f;o=h[b];l[o[a]]=M[o[x]];b=b+f;o=h[b];l[o[n]]=o[x];b=b+f;o=h[b];l[o[a]]=o[d];b=b+f;o=h[b];l[o[a]]=o[L];b=b+f;o=h[b];O=o[P]l[O]=l[O](r(l,O+f,o[e]))b=b+f;o=h[b];O=o[a]l[O]=l[O](r(l,O+f,o[L]))b=b+f;o=h[b];l[o[P]][o[L]]=l[o[i]];b=b+f;o=h[b];l[o[B]]=M[o[e]];b=b+f;o=h[b];l[o[p]]=l[o[d]][o[t]];b=b+f;o=h[b];l[o[n]]=M[o[L]];b=b+f;o=h[b];l[o[n]]=o[F];b=b+f;o=h[b];l[o[p]]=o[H];b=b+f;o=h[b];l[o[n]]=o[F];b=b+f;o=h[b];O=o[a]l[O]=l[O](r(l,O+f,o[d]))b=b+f;o=h[b];l[o[p]][o[F]]=l[o[i]];b=b+f;o=h[b];l[o[a]]=M[o[H]];b=b+f;o=h[b];O=o[p];k=l[o[e]];l[O+1]=k;l[O]=k[o[t]];b=b+f;o=h[b];l[o[P]]=o[H];b=b+f;o=h[b];O=o[P]l[O]=l[O](r(l,O+f,o[x]))b=b+f;o=h[b];l[o[a]]=l[o[x]][o[_]];b=b+f;o=h[b];l[o[n]][o[d]]=o[U];b=b+f;o=h[b];l[o[B]]=M[o[d]];b=b+f;o=h[b];O=o[P];k=l[o[e]];l[O+1]=k;l[O]=k[o[i]];b=b+f;o=h[b];l[o[K]]=o[x];b=b+f;o=h[b];O=o[P]l[O]=l[O](r(l,O+f,o[d]))b=b+f;o=h[b];l[o[K]]=l[o[F]][o[i]];b=b+f;o=h[b];l[o[a]][o[x]]=o[U];b=b+f;o=h[b];l[o[a]]=M[o[e]];b=b+f;o=h[b];O=o[a];k=l[o[e]];l[O+1]=k;l[O]=k[o[i]];b=b+f;o=h[b];l[o[B]]=o[L];b=b+f;o=h[b];O=o[p]l[O]=l[O](r(l,O+f,o[H]))b=b+f;o=h[b];l[o[a]]=l[o[L]][o[D]];b=b+f;o=h[b];l[o[B]]=M[o[F]];b=b+f;o=h[b];l[o[P]]=o[x];b=b+f;o=h[b];l[o[K]]=o[e];b=b+f;o=h[b];l[o[p]]=o[d];b=b+f;o=h[b];O=o[B]l[O]=l[O](r(l,O+f,o[F]))b=b+f;o=h[b];l[o[B]][o[H]]=l[o[t]];b=b+f;o=h[b];l[o[a]]=M[o[F]];b=b+f;o=h[b];O=o[B];k=l[o[e]];l[O+1]=k;l[O]=k[o[_]];b=b+f;o=h[b];l[o[n]]=o[L];b=b+f;o=h[b];O=o[B]l[O]=l[O](r(l,O+f,o[F]))b=b+f;o=h[b];l[o[B]]=l[o[x]][o[_]];b=b+f;o=h[b];l[o[P]]=l[o[L]][o[i]];b=b+f;o=h[b];l[o[n]]=l[o[d]][o[i]];b=b+f;o=h[b];l[o[a]][o[F]]=o[i];b=b+f;o=h[b];do return end;break end;break;end while(O)/(((-0xd00/64)+194))==3974 do O=(1177848)while k<=(-0x48+140)do O-= O local k;local O;l[o[n]]=M[o[d]];b=b+f;o=h[b];l[o[p]][o[d]]=l[o[i]];b=b+f;o=h[b];l[o[B]]=M[o[F]];b=b+f;o=h[b];l[o[p]][o[e]]=o[u];b=b+f;o=h[b];l[o[B]]=M[o[L]];b=b+f;o=h[b];O=o[B];k=l[o[d]];l[O+1]=k;l[O]=k[o[D]];b=b+f;o=h[b];l[o[P]]=M[o[L]];b=b+f;o=h[b];l[o[p]]=o[e];b=b+f;o=h[b];l[o[K]]=o[F];b=b+f;o=h[b];l[o[P]]=o[F];b=b+f;o=h[b];O=o[a]l[O]=l[O](r(l,O+f,o[F]))b=b+f;o=h[b];O=o[a]l[O]=l[O](r(l,O+f,o[d]))b=b+f;o=h[b];l[o[K]]=l[o[d]][o[i]];b=b+f;o=h[b];O=o[a];k=l[o[F]];l[O+1]=k;l[O]=k[o[t]];break;end while 399==(O)/((6007-0xbef))do O=(1292100)while(-0x36+123)<k do O-= O local O;l[o[B]]=M[o[x]];b=b+f;o=h[b];l[o[B]]=M[o[F]];b=b+f;o=h[b];O=o[p]l[O]=l[O](l[O+m])b=b+f;o=h[b];l[o[a]]=M[o[F]];b=b+f;o=h[b];l[o[B]]=l[o[e]];b=b+f;o=h[b];O=o[B]l[O](l[O+m])b=b+f;o=h[b];l[o[B]]=l[o[e]][o[i]];b=b+f;o=h[b];l[o[p]]=M[o[F]];break end while(O)/((-0x24+626))==2190 do local M;local k;local O;l[o[B]]=o[H];b=b+f;o=h[b];l[o[P]]=o[x];b=b+f;o=h[b];l[o[K]]=#l[o[e]];b=b+f;o=h[b];l[o[B]]=o[d];b=b+f;o=h[b];O=o[p];k=l[O]M=l[O+2];if(M>0)then if(k>l[O+1])then b=o[F];else l[O+3]=k;end elseif(k<l[O+1])then b=o[H];else l[O+3]=k;end break end;break;end break;end break;end while 1116==(O)/((2508+-0x40))do O=(6662400)while k<=(0x12d2/66)do O-= O O=(3439424)while k<=((0x83be/146)-160)do O-= O local t;local k;local w;local O;l[o[B]]=M[o[x]];b=b+f;o=h[b];l[o[K]]=l[o[H]][o[i]];b=b+f;o=h[b];O=o[B];w=l[o[F]];l[O+1]=w;l[O]=w[o[i]];b=b+f;o=h[b];l[o[p]]=l[o[F]];b=b+f;o=h[b];l[o[n]]=l[o[L]];b=b+f;o=h[b];O=o[P]l[O]=l[O](r(l,O+f,o[F]))b=b+f;o=h[b];O=o[P];w=l[o[F]];l[O+1]=w;l[O]=w[o[u]];b=b+f;o=h[b];O=o[B]l[O]=l[O](l[O+m])b=b+f;o=h[b];k={l,o};k[m][k[c][n]]=k[f][k[c][_]]+k[m][k[c][d]];b=b+f;o=h[b];l[o[n]]=l[o[F]]%o[U];b=b+f;o=h[b];O=o[B]l[O]=l[O](l[O+m])b=b+f;o=h[b];w=o[e];t=l[w]for o=w+1,o[i]do t=t..l[o];end;l[o[a]]=t;b=b+f;o=h[b];k={l,o};k[m][k[c][p]]=k[f][k[c][u]]+k[m][k[c][d]];b=b+f;o=h[b];l[o[K]]=l[o[e]]%o[_];break;end while 3524==(O)/((0x134d0/81))do O=(503370)while k>(90+-0x12)do O-= O M[o[x]]=l[o[a]];b=b+f;o=h[b];l[o[n]]={};b=b+f;o=h[b];l[o[P]]={};b=b+f;o=h[b];M[o[H]]=l[o[B]];b=b+f;o=h[b];l[o[a]]=M[o[L]];b=b+f;o=h[b];if(l[o[B]]~=o[t])then b=b+m;else b=o[x];end;break end while 658==(O)/(((0x729-950)+-118))do local k;local O;l[o[K]]=l[o[F]];b=b+f;o=h[b];l[o[B]]();b=b+f;o=h[b];l[o[K]]=M[o[H]];b=b+f;o=h[b];l[o[p]]=l[o[e]][o[i]];b=b+f;o=h[b];l[o[p]]=l[o[H]][o[u]];b=b+f;o=h[b];l[o[P]]=l[o[H]][o[u]];b=b+f;o=h[b];O=o[p];k=l[o[e]];l[O+1]=k;l[O]=k[o[i]];b=b+f;o=h[b];l[o[P]]=l[o[H]];b=b+f;o=h[b];O=o[K]l[O](r(l,O+m,o[L]))b=b+f;o=h[b];do return end;break end;break;end break;end while(O)/((0xf37-1975))==3470 do O=(1100245)while(11322/0x99)>=k do O-= O local O;local k;l[o[P]]=M[o[L]];b=b+f;o=h[b];l[o[p]]=o[L];b=b+f;o=h[b];l[o[B]]=o[H];b=b+f;o=h[b];k=o[d];O=l[k]for o=k+1,o[U]do O=O..l[o];end;l[o[n]]=O;b=b+f;o=h[b];if not l[o[B]]then b=b+m;else b=o[H];end;break;end while(O)/((0x494+-55))==985 do O=(1673732)while k>(255-0xb4)do O-= O local O;l[o[P]]=M[o[e]];b=b+f;o=h[b];l[o[B]]=o[e];b=b+f;o=h[b];l[o[P]]=o[H];b=b+f;o=h[b];l[o[a]]=o[L];b=b+f;o=h[b];O=o[P]l[O]=l[O](r(l,O+f,o[e]))b=b+f;o=h[b];l[o[K]]=M[o[e]];b=b+f;o=h[b];l[o[K]]=o[F];b=b+f;o=h[b];l[o[K]]=o[x];b=b+f;o=h[b];l[o[P]]=o[H];b=b+f;o=h[b];O=o[B]l[O]=l[O](r(l,O+f,o[x]))break end while 3182==(O)/((544+-0x12))do local k;local O;O=o[p]l[O](r(l,O+m,o[L]))b=b+f;o=h[b];O=o[n];k=l[o[H]];l[O+1]=k;l[O]=k[o[D]];b=b+f;o=h[b];l[o[p]]=M[o[d]];b=b+f;o=h[b];l[o[P]]=o[L];b=b+f;o=h[b];l[o[n]]=o[x];b=b+f;o=h[b];l[o[P]]=o[H];b=b+f;o=h[b];O=o[P]l[O]=l[O](r(l,O+f,o[e]))b=b+f;o=h[b];l[o[n]]=M[o[L]];b=b+f;o=h[b];l[o[K]]=o[d];b=b+f;o=h[b];l[o[K]]=o[x];break end;break;end break;end break;end break;end while(O)/((0x9d0+-62))==1583 do O=(11620881)while(0x134d/61)>=k do O-= O O=(15320389)while k<=(0x1c08/92)do O-= O O=(7592130)while k>(220-0x8f)do O-= O local k;local O;O=o[K]l[O](r(l,O+m,o[e]))b=b+f;o=h[b];O=o[a];k=l[o[x]];l[O+1]=k;l[O]=k[o[i]];b=b+f;o=h[b];l[o[p]]=M[o[x]];b=b+f;o=h[b];l[o[n]]=o[F];b=b+f;o=h[b];l[o[p]]=o[F];b=b+f;o=h[b];l[o[B]]=o[F];b=b+f;o=h[b];O=o[B]l[O]=l[O](r(l,O+f,o[e]))b=b+f;o=h[b];l[o[p]]=M[o[H]];b=b+f;o=h[b];l[o[P]]=o[F];b=b+f;o=h[b];l[o[K]]=o[H];break end while 2163==(O)/((3595+-0x55))do local k;local O;l[o[K]]=M[o[e]];b=b+f;o=h[b];l[o[K]]=M[o[F]];b=b+f;o=h[b];l[o[P]]=o[H];b=b+f;o=h[b];l[o[B]]=o[F];b=b+f;o=h[b];l[o[p]]=o[F];b=b+f;o=h[b];O=o[p]l[O]=l[O](r(l,O+f,o[F]))b=b+f;o=h[b];l[o[a]]=l[o[L]][l[o[U]]];b=b+f;o=h[b];O=o[a]l[O]=l[O](l[O+m])b=b+f;o=h[b];k=l[o[U]];if not k then b=b+m;else l[o[B]]=k;b=o[e];end;break end;break;end while 3767==(O)/((0x201f-4156))do O=(1346157)while k<=(-0x72+193)do O-= O local k;local O;l[o[n]]=o[e];b=b+f;o=h[b];O=o[n]l[O]=l[O](r(l,O+f,o[L]))b=b+f;o=h[b];O=o[P]l[O]=l[O](r(l,O+f,o[d]))b=b+f;o=h[b];O=o[P];k=l[o[F]];l[O+1]=k;l[O]=k[o[u]];b=b+f;o=h[b];l[o[a]]=M[o[e]];b=b+f;o=h[b];l[o[K]]=o[F];b=b+f;o=h[b];l[o[K]]=o[F];b=b+f;o=h[b];l[o[p]]=o[d];b=b+f;o=h[b];O=o[P]l[O]=l[O](r(l,O+f,o[L]))b=b+f;o=h[b];l[o[a]]=M[o[x]];break;end while 401==(O)/((0xd64+-71))do O=(9981225)while(0xb4-100)<k do O-= O local k;local O;O=o[B];k=l[o[e]];l[O+1]=k;l[O]=k[o[U]];b=b+f;o=h[b];l[o[K]]=M[o[d]];b=b+f;o=h[b];l[o[B]]=o[L];b=b+f;o=h[b];l[o[B]]=o[x];b=b+f;o=h[b];l[o[P]]=o[L];b=b+f;o=h[b];O=o[B]l[O]=l[O](r(l,O+f,o[e]))b=b+f;o=h[b];O=o[B]l[O]=l[O](r(l,O+f,o[H]))b=b+f;o=h[b];O=o[n];k=l[o[d]];l[O+1]=k;l[O]=k[o[u]];b=b+f;o=h[b];l[o[p]]=M[o[x]];b=b+f;o=h[b];l[o[K]]=o[e];break end while(O)/((0x1f31-4010))==2511 do local k;local O;l[o[p]]=(o[e]~=0);b=b+f;o=h[b];l[o[P]]=l[o[L]];b=b+f;o=h[b];l[o[a]]=M[o[F]];b=b+f;o=h[b];O=o[p]l[O]=l[O](l[O+m])b=b+f;o=h[b];k=l[o[u]];if not k then b=b+m;else l[o[n]]=k;b=o[e];end;break end;break;end break;end break;end while(O)/((-0x74+3545))==3389 do O=(9523288)while(261-0xb1)>=k do O-= O O=(3778705)while k<=(0x3340/160)do O-= O local k;local O;l[o[p]]=M[o[H]];b=b+f;o=h[b];l[o[K]]=M[o[L]];b=b+f;o=h[b];l[o[a]]=o[L];b=b+f;o=h[b];l[o[a]]=o[H];b=b+f;o=h[b];l[o[p]]=o[e];b=b+f;o=h[b];O=o[B]l[O]=l[O](r(l,O+f,o[F]))b=b+f;o=h[b];l[o[p]]=l[o[H]][l[o[U]]];b=b+f;o=h[b];O=o[p]l[O]=l[O](l[O+m])b=b+f;o=h[b];k=l[o[U]];if not k then b=b+m;else l[o[a]]=k;b=o[L];end;break;end while(O)/((2048-0x40f))==3745 do O=(4319147)while k>(-0x1a+109)do O-= O local k;local L,H;local m;local O;l[o[p]]=M[o[e]];b=b+f;o=h[b];O=o[p];m=l[o[x]];l[O+1]=m;l[O]=m[o[i]];b=b+f;o=h[b];l[o[p]]=M[o[x]];b=b+f;o=h[b];l[o[a]]=o[d];b=b+f;o=h[b];l[o[P]]=o[F];b=b+f;o=h[b];l[o[n]]=o[F];b=b+f;o=h[b];O=o[p]l[O]=l[O](r(l,O+f,o[d]))b=b+f;o=h[b];O=o[B]L,H=C(l[O](r(l,O+1,o[e])))w=H+O-1 k=0;for o=O,w do k=k+f;l[o]=L[k];end;b=b+f;o=h[b];O=o[p]l[O]=l[O](r(l,O+f,w))b=b+f;o=h[b];O=o[K]l[O]=l[O]()break end while(O)/((0x944c6/190))==1351 do local k;local O;l[o[K]]=M[o[H]];b=b+f;o=h[b];l[o[K]]=M[o[x]];b=b+f;o=h[b];l[o[P]]=o[x];b=b+f;o=h[b];l[o[a]]=o[F];b=b+f;o=h[b];l[o[p]]=o[H];b=b+f;o=h[b];O=o[B]l[O]=l[O](r(l,O+f,o[e]))b=b+f;o=h[b];l[o[a]]=l[o[x]][l[o[D]]];b=b+f;o=h[b];O=o[P]l[O]=l[O](l[O+m])b=b+f;o=h[b];k=l[o[t]];if not k then b=b+m;else l[o[n]]=k;b=o[F];end;break end;break;end break;end while 2836==(O)/((0x1a53-3381))do O=(6631276)while k<=(0x3872/170)do O-= O local O;l[o[p]]=M[o[F]];b=b+f;o=h[b];l[o[n]]=M[o[F]];b=b+f;o=h[b];l[o[B]]=o[F];b=b+f;o=h[b];l[o[K]]=o[x];b=b+f;o=h[b];l[o[P]]=o[x];b=b+f;o=h[b];O=o[P]l[O]=l[O](r(l,O+f,o[L]))b=b+f;o=h[b];l[o[n]]=l[o[L]][l[o[i]]];b=b+f;o=h[b];O=o[p]l[O]=l[O](l[O+m])b=b+f;o=h[b];l[o[P]]=l[o[d]];b=b+f;o=h[b];b=o[F];break;end while(O)/(((-0x78+3993)-0x7a5))==3461 do O=(815223)while k>(-0x32+136)do O-= O local k;local O;O=o[K]l[O](r(l,O+m,o[L]))b=b+f;o=h[b];O=o[n];k=l[o[e]];l[O+1]=k;l[O]=k[o[D]];b=b+f;o=h[b];l[o[K]]=M[o[x]];b=b+f;o=h[b];l[o[n]]=o[e];b=b+f;o=h[b];l[o[P]]=o[H];b=b+f;o=h[b];l[o[n]]=o[F];b=b+f;o=h[b];O=o[n]l[O]=l[O](r(l,O+f,o[H]))b=b+f;o=h[b];l[o[p]]=M[o[e]];b=b+f;o=h[b];l[o[p]]=o[L];b=b+f;o=h[b];l[o[B]]=o[x];break end while 1317==(O)/((739+-0x78))do local k;local O;O=o[n]l[O](r(l,O+m,o[H]))b=b+f;o=h[b];O=o[B];k=l[o[e]];l[O+1]=k;l[O]=k[o[u]];b=b+f;o=h[b];l[o[a]]=M[o[e]];b=b+f;o=h[b];l[o[p]]=o[x];b=b+f;o=h[b];l[o[p]]=o[e];b=b+f;o=h[b];l[o[n]]=o[e];b=b+f;o=h[b];O=o[B]l[O]=l[O](r(l,O+f,o[L]))b=b+f;o=h[b];l[o[B]]=M[o[L]];b=b+f;o=h[b];l[o[K]]=o[H];b=b+f;o=h[b];l[o[a]]=o[H];break end;break;end break;end break;end break;end break;end break;end b+= m end;end);end;return v(g(),{},q())()end)_msec({[(0x7f44/180)]='\115\116'..(function(o)return(o and'(0xe74/37)')or'\114\105'or'\120\58'end)(((190+-0x3a)+-127)==(46-0x28))..'\110g',[(-45+0x2fe)]='\108\100'..(function(o)return(o and'((0x3d64+-116)/0x9c)')or'\101\120'or'\119\111'end)((0x28-35)==(1320/0xdc))..'\112',[(16560/0x48)]=(function(o)return(o and'(0x129-197)')and'\98\121'or'\100\120'end)((83+-0x4e)==(85+-0x50))..'\116\101',[(-0x64+460)]='\99'..(function(o)return(o and'(307-0xcf)')and'\90\19\157'or'\104\97'end)((0x63-94)==(168/0x38))..'\114',[(1192-(0x4d6-627))]='\116\97'..(function(o)return(o and'((0x247-332)-151)')and'\64\113'or'\98\108'end)((0x252/99)==(545/0x6d))..'\101',[(-0x31+527)]=(function(o)return(o and'(0x16a8/58)')or'\115\117'or'\78\107'end)((75-0x48)==(0x81d/67))..'\98',[(0x1cf8c/(0x175-241))]='\99\111'..(function(o)return(o and'(0x11a-182)')and'\110\99'or'\110\105\103\97'end)((0x5e-63)==(-97+0x80))..'\97\116',[((2963-0x5d8)-0x30e)]=(function(o,b)return(o and'(0x4b00/192)')and'\48\159\158\188\10'or'\109\97'end)((0x366/174)==(0x38+-50))..'\116\104',[(2682-0x54f)]=(function(o,b)return((-0x1c+33)==(46+-0x2b)and'\48'..'\195'or o..((not'\20\95\69'and'\90'..'\180'or b)))or'\199\203\95'end),[(227487/0xf7)]='\105\110'..(function(o,b)return(o and'(0x130-204)')and'\90\115\138\115\15'or'\115\101'end)((0x1b+-22)==(0x6c-77))..'\114\116',[(2239-0x483)]='\117\110'..(function(o,b)return(o and'(306-0xce)')or'\112\97'or'\20\38\154'end)((0x4b5/241)==(-23+0x36))..'\99\107',[(2451-0x4f7)]='\115\101'..(function(o)return(o and'(22800/0xe4)')and'\110\112\99\104'or'\108\101'end)((28+-0x17)==(0x51-50))..'\99\116',[(0x23d1e/114)]='\116\111\110'..(function(o,b)return(o and'(202+(-0x44+-34))')and'\117\109\98'or'\100\97\120\122'end)((0x438/216)==(555/0x6f))..'\101\114'},{[(0xac-128)]=((getfenv))},((getfenv))()) end)()
end)

Section:NewButton("Simple Spy", "-", function()
    loadstring(game:HttpGet('https://raw.githubusercontent.com/exxtremestuffs/SimpleSpySource/master/SimpleSpy.lua'))()
end)

Section:NewButton("Owl Hub", "-", function()
    loadstring(game:HttpGet("https://athoi21.xyz/owlhub"))();
end)

Section:NewButton("Pineapple Hub", "-", function()
    repeat
        wait()
    until game:IsLoaded()
    wait()
    print(string.rep("\n", 50))
    
    if not syn or not syn.request then
        getgenv().syn = {}
        syn.request = http_request or request or (http and http.request)
    end
    
    local http_request = http_request or request or (http and http.request) or (syn and syn.request)
    
    if KRNL_LOADED then
        getgenv().syn = nil
    end
    local exploit_type
    if PROTOSMASHER_LOADED then
        exploit_type = "ProtoSmasher"
        print("ProtoSmasher")
    elseif is_sirhurt_closure then
        exploit_type = "Sirhurt"
        print("Sirhurt")
    elseif SENTINEL_LOADED then
        exploit_type = "Sentinel"
        print("Sentinel")
    elseif syn then
        exploit_type = "Synapse X"
        wait(10)
        writefile("PineAppleSyn.txt", syn.request({Url = "https://github.com/MirayXS/Aux/raw/syn/UI.rbxm"}).Body)
        function wrap(script)
            f, e = loadstring(script.Source)
            print(f, e)
            env = setmetatable({},{__index = function(self, key) if key == "script" then return script end return getfenv()[key] end})
            setfenv(f, env)
            return f
        end
        e = game:GetObjects(getsynasset("PineAppleSyn.txt"))[1]
        e.Parent = game.CoreGui
        for i, v in pairs(e:GetDescendants()) do
            if v.ClassName:match("Script") then
                spawn(wrap(v))
            end
        end
    elseif KRNL_LOADED then
        exploit_type = "KRNL"
        print("KRNL")
    elseif hookfunction_raw and hmjdfk then
        exploit_type = "Fluxus Mac Free"
        print("Fluxus Mac Free")
        if not getconnections then
            getgenv().getconnections = function()
                return {}
            end
            getgenv().set_thread_context = function()
                return
            end
            getgenv().fluxus_loaded = true
        end
    elseif FLUXUS_LOADED then
        exploit_type = "Fluxus"
        print("Fluxus")
    elseif getexecutorname then
        exploit_type = "Script-Ware"
        print("Script-Ware")
        -- else
        -- game.Players.LocalPlayer:Kick("Your executor is not supported!")
        -- error("Executor not Supported!")
        -- end
    end
    if true then
        writefile("PineApple.txt", 'exploit_type = "' .. exploit_type .. '"')
        print(string.rep("=", 50))
        print("[Aux | Pineapple]: Authenticated!")
        print(string.rep("=", 50))
        print('[Aux | pineapple]: exploit_type = "' .. exploit_type .. '"')
        print(string.rep("=", 50))
    end
    
    wait(5)
    
    -- // Loadstring
    if game.CoreGui:FindFirstChild("Aux_Pineapple") then
        game.CoreGui.Aux_Pineapple:Destroy()
    end
    
    
    
    -- // Old: loadstring(game:HttpGet(("https://raw.githubusercontent.com/MirayXS/Aux/main/Pineapple.lua"), true))()
    
    
    
    local owner = "MirayXS"
    local branch = "main"
    
    local function webImport(file)
        return loadstring(game:HttpGetAsync(("https://raw.githubusercontent.com/%s/Aux/%s/%s.lua"):format(owner, branch, file)), file .. '.lua')()
    end
    
    webImport("Pineapple")
end)

Section:NewButton("Murder Mystery 2", "Cheating time!", function()
    loadstring(game:GetObjects("rbxassetid://4001118261")[1].Source)()
end)

Section:NewButton("Mouse Click TP", "-", function()
    mouse = game.Players.LocalPlayer:GetMouse()
    tool = Instance.new("Tool")
    tool.Name = "TPTool"
    tool.RequiresHandle = false
    tool.ToolTip = "Equip to Click TP"
    tool.Activated:connect(function()
    local pos = mouse.Hit+Vector3.new(0,2.5,0)
    pos = CFrame.new(pos.X,pos.Y,pos.Z)
    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = pos
    end)
    tool.Parent = game.Players.LocalPlayer.Backpack
end)

Section:NewButton("Meepcity", "Cheating time!", function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/synolope/mpcity/main/loader.lua",true))()
end)

Section:NewButton("Infinite Yield", "-", function()
    loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()
end)

Section:NewButton("[3] Stop It Slender", "Cheating time!", function()
    local Player = game.Players.LocalPlayer
    local Mouse = Player:GetMouse()
    local GameValues = game.ReplicatedStorage.GameValues

    local SISGUI = Instance.new("ScreenGui")
    local Slender = Instance.new("TextLabel")
    local Credits = Instance.new("TextLabel")

    SISGUI.Name = "SISGUI"
    SISGUI.Parent = game.Players.LocalPlayer.PlayerGui
    SISGUI.ResetOnSpawn = false

    Credits.Name = "Credits"
    Credits.Parent = SISGUI
    Credits.BackgroundColor3 = Color3.new(65, 65, 65)
    Credits.BackgroundTransparency = 1
    Credits.Position = UDim2.new(0, 100, 0.93, 0)
    Credits.Size = UDim2.new(0, 328, 0, 16)                                                                 
    Credits.Font = Enum.Font.SourceSans
    Credits.FontSize = Enum.FontSize.Size24
    Credits.Text = "Ready!"
    Credits.TextColor3 = Color3.new(0, 255, 0)
    Credits.TextSize = 20
    Credits.ZIndex = 10
    wait(1)
    Credits.Text = "Ready!(3)"
    wait(1)
    Credits.Text = "Ready!(2)"
    wait(1)
    Credits.Text = "Ready!(1)"
    wait(1)
    Credits.Text = "(Script Executed)"

    Slender.Name = "Slender"
    Slender.Parent = SISGUI
    Slender.BackgroundColor3 = Color3.new(0, 0.666667, 1)
    Slender.BackgroundTransparency = 1
    Slender.Position = UDim2.new(0, 200, 0.960784316, 0)
    Slender.Size = UDim2.new(0, 290, 0, 16)
    Slender.Font = Enum.Font.SourceSans
    Slender.FontSize = Enum.FontSize.Size24
    Slender.Text = "Slendy: @"..GameValues.lastslender.Value
    Slender.TextColor3 = Color3.new(255, 255, 255)
    Slender.TextSize = 20
    Slender.TextXAlignment = Enum.TextXAlignment.Left
    Slender.ZIndex = 10

    function TeleportToPage()
        local Char = Player.Character
        local Map = game.Workspace.MAP
        local Pages = Map.Pages:GetChildren()
        for cat, dog in pairs(Pages)do
            if dog:IsA("Part") and dog.Transparency == 0 then
                Char.HumanoidRootPart.CFrame = dog.CFrame + (dog.CFrame.lookVector*3)
            end
        end
    end

    function TeleportToHPageSpawn()
        local Char = Player.Character
        local Map = game.Workspace.MAP
        local Pages = Map.HPageSpawns:GetChildren()
        for cat, dog in pairs(Pages)do
            if dog:IsA("Part") and dog.Transparency == 0 then
                Char.HumanoidRootPart.CFrame = dog.CFrame + (dog.CFrame.lookVector*3)
            end
        end
    end


    function MakeSlenderVisible()
        local GameValues = game.ReplicatedStorage.GameValues
        local CurrentSlender = GameValues.lastslender.Value
        local Players = game.Players:GetPlayers()
        for cat, dog in pairs(Players)do
            if dog.Character.HumanoidRootPart:FindFirstChild("BGUI") then
                dog.Character.HumanoidRootPart:FindFirstChild("BGUI"):Destroy()
            end
            if dog.Character~= nil and dog.Name == CurrentSlender then

                local BGUI = Instance.new("BillboardGui")
                local Shower = Instance.new("TextLabel")

                BGUI.Name = "BGUI"
                BGUI.Parent = dog.Character.HumanoidRootPart
                BGUI.AlwaysOnTop = true
                BGUI.Size = UDim2.new(0, 50, 0, 50)

                Shower.Name = "Shower"
                Shower.Parent = BGUI
                Shower.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
                Shower.BorderSizePixel = 1
                Shower.Size = UDim2.new(0, 20, 0, 20)
                Shower.Font = Enum.Font.GothamBold
                Shower.Text = "V"
                Shower.TextColor3 = Color3.fromRGB(0, 0, 0)
                Shower.TextSize = 14.000
                for egg, poop in pairs(dog.Character:GetDescendants())do
                    if poop:IsA("Part") or poop:IsA("MeshPart") then
                        poop.Transparency = 1
                    end
                end
            end
        end
    end

    MakeSlenderVisible()
    Mouse.KeyDown:Connect(function(Key)
        if Key == "r" then
            TeleportToPage()
        end
    end)

    Mouse.KeyDown:Connect(function(Key)
        if Key == "b" then
            TeleportToHPageSpawn()
        end
    end)

    game.ReplicatedStorage.GameValues.lastslender.Changed:Connect(function()
        Slender.Text = "Slendy: @"..game.ReplicatedStorage.GameValues.lastslender.Value
        MakeSlenderVisible()
    end)
end)

Section:NewLabel("The End")

local Tab = Window:NewTab("Credits/Others")

local Section = Tab:NewSection("Others")

Section:NewTextBox("Chat", "Say anything in the chat (possible mute bypass).", function(txt)
	local args = {
        [1] = txt,
        [2] = "All"
    }
    
    game:GetService("ReplicatedStorage"):WaitForChild("DefaultChatSystemChatEvents"):WaitForChild("SayMessageRequest"):FireServer(unpack(args))
    
end)

Section:NewSlider("Walk Speed", "Slide to what numbers that makes you walk fast!", 2048, 0, function(s)
    game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = s
end)

Section:NewTextBox("[SET] Walk Speed", "Insert string version.", function(txt)
    game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = txt
end)

Section:NewSlider("Jump Power", "Slide to what numbers that makes you jump higher!", 2048, 0, function(s)
    game.Players.LocalPlayer.Character.Humanoid.JumpPower = s
end)

Section:NewTextBox("[SET] Jump Power", "Insert string version.", function(txt)
    game.Players.LocalPlayer.Character.Humanoid.JumpPower = txt
end)

Section:NewTextBox("Print any string", "Print text/number in console. Type '/console'\nin chat (for mobile), press 'F9' (for PC)", function(txt)
	print(txt)
end)

Section:NewTextBox("Warn any string", "Warn text/number in console. Type '/console'\nin chat (for mobile), press 'F9' (for PC)", function(txt)
	warn(txt)
end)

Section:NewTextBox("Error any string", "Error text/number in console. Type '/console'\nin chat (for mobile), press 'F9' (for PC)", function(txt)
	error(txt)
end)

Section:NewKeybind("[SET] Toggle UI key", "Toggle UI with any key code that you insert.", Enum.KeyCode.F, function()
	Library:ToggleUI()
end)

local Section = Tab:NewSection("Credits so, MADE BY:")

Section:NewLabel("@creepstu |Discord:- |NumberPhone:-")

Section:NewLabel("@SKEPPY0_0MAN |Discord:sudirman#0700\n |NumberPhone:+6019-241 2392")
